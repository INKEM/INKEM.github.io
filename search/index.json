[{"content":"程序实验7\u0026amp;8.IO扩展-LED点阵 IO扩展-74HC595 外围设备占用的IO口较多，而51单片机提供的IO口非常有限，如果想要连接更多的外围设备，就需要通过扩展IO来实现。这里使用的是74HC595的串转并芯片。\n74HC595芯片介绍 74HC95是一个8位串行输入、并行输出的位移缓存器，其中并行输出位三态输出（高电平、低电平和高阻抗）。\nQ0~Q7为并行数据输出，Q7\u0026rsquo;为串行数据输出，DS为串行数据输入。通过串行数据输出连接串行移位输入可以级联多个595芯片，从而实现IO扩展功能。\nMR为低电平复位引脚，名称上面一杠说明低电平有效。\nSH_CP为移位寄存器的时钟输入，控制移位寄存器一位一位地移动存储数据；ST_CP为存储寄存器的时钟输入，控制移位寄存器中的八位数据一次性全部存储到存储寄存器当中。存储寄存器的输出连接到并行输出口Q0~Q7。\nOE为使能引脚，如果该信号为低电平则并行输出口可以输出。\n硬件介绍 在51单片机中，595芯片被用于LED点阵。LED点阵的原理与矩阵按键类似，对行共阳、列共阴二极管来说，列线路低电平、行线路高电平时相应的二极管被点亮。\n595芯片的两个时钟输入分别连接P35-36引脚，串行输入连接P34引脚，用于接受并行输出的数据。并行输出引脚与LED点阵行线路引脚一一对应。\n实验7-1 IO扩展 实现功能：通过72HC595模块控制LED点阵以行为单位循环滚动显示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026#34;reg52.h\u0026#34; typedef unsigned char u8; typedef unsigned int u16; //定义两个时钟输入和串行输入端口 sbit SRCLK = P3^6; sbit rCLK = P3^5; sbit SER = P3^4; //定义LED点阵端口 #define LED_COL_PORT P0 //存储点亮LED点阵每一行的串行输入数据 u8 ghc595_buf[8] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80}; //延时函数 void delay_10us(u16 time) { while(time --); } //写入串行输入数据函数 void hc595_write_data(u8 dat) { u8 i = 0; for(i = 0;i \u0026lt; 8;i++) { //移位寄存器从高位到低位依次存储数据 SER = dat \u0026gt;\u0026gt; 7; //存储最高位 dat \u0026lt;\u0026lt;= 1; //将数据的次高位移到最高位 //移位寄存器时钟产生上升沿（低电平转高电平瞬间）控制SER写入寄存器 SRCLK = 0; delay_10us(1); //寄存器对传输延时有要求（详见芯片手册），该芯片寄存器延时为纳秒级 SRCLK = 1; } //移位寄存器存储完8位数据，存储寄存器时钟产生上升沿控制数据转入存储寄存器 rCLK = 0; delay_10us(1); rCLK = 1; } void main() { u8 i = 0; //LED点阵列线路有下拉电阻默认高电平，需全部设为低电平 LED_COL_PORT = 0x00; while(1) { for(i = 0;i \u0026lt; 8;i++) { //将使LED点阵每一行点亮的串行输入数据依次写入芯片 hc595_write_data(ghc595_buf[i]); delay_10us(50000); } } } 使用LED点阵需要用黄色跳线帽插在GND和OE上将OE接地，使并行输出口有效。不使用时则插在OE和VCC上。\n实验7-2 IO扩展（595级联） 当多个595芯片级联时，数据会以字节为单位从前一个芯片推向后一个芯片。以上图为例，当四个字节的数据存入移位寄存器后，在转入存储寄存器时，最后一个字节在该芯片并行输出，而前三个字节溢出到串行输出口传输到第二个芯片。以此类推，第二个芯片并行输出倒数第二个字节，前两个字节溢出到第三个芯片；第三个芯片并行输出第二个字节，第一个字节溢出到最后一个芯片并行输出。其中前两个芯片分别控制前八行、后八行，后两个芯片分别控制前八列、后八列。\n实现功能：通过72HC595模块控制LED点阵以行为单位循环滚动显示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026#34;reg52.h\u0026#34; typedef unsigned char u8; typedef unsigned int u16; sbit SRCLK = P3^6; sbit rCLK = P3^5; sbit SER = P3^4; //传入四个一字节的参数，按并行输出芯片序号命名，如dat1由第一个芯片并行输出 void hc595_write_data(u8 dat1, u8 dat2, u8 dat3, u8 dat4) { u8 i = 0; //输入顺序与输出芯片顺序相反，所以按倒序依次写入四个字节的数据 for(i = 0;i \u0026lt; 8;i++) { SER = dat4 \u0026gt;\u0026gt; 7; dat4 \u0026lt;\u0026lt;= 1; SRCLK = 0; delay_10us(1); SRCLK = 1; } for(i = 0;i \u0026lt; 8;i++) { SER = dat3 \u0026gt;\u0026gt; 7; dat3 \u0026lt;\u0026lt;= 1; SRCLK = 0; delay_10us(1); SRCLK = 1; } for(i = 0;i \u0026lt; 8;i++) { SER = dat2 \u0026gt;\u0026gt; 7; dat2 \u0026lt;\u0026lt;= 1; SRCLK = 0; delay_10us(1); SRCLK = 1; } for(i = 0;i \u0026lt; 8;i++) { SER = dat1 \u0026gt;\u0026gt; 7; dat1 \u0026lt;\u0026lt;= 1; SRCLK = 0; delay_10us(1); SRCLK = 1; } //四个字节的数据都写入移位寄存器后传入存储寄存器 rCLK = 0; delay_10us(1); rCLK = 1; } void main() { u8 i = 0; while(1) { //先通过第一个芯片遍历1~8行，再通过第二个芯片遍历9~16行，后两个芯片控制所有列线路为低电平 for(i = 0;i \u0026lt; 8;i++) { hc595_write_data(ghc595_buf[i], 0, 0, 0); delay_10us(50000); } for(i = 0;i \u0026lt; 8;i++) { hc595_write_data(0, ghc595_buf[i], 0, 0); delay_10us(50000); } } } LED点阵 LED点阵介绍 LED点阵是由发光二极管排列组成的显示器件，被广泛应用于汽车报站器、广告屏等。\nLED点阵每一行的阳极并联在一起，每一列的阴极并列在一起，行为高电平、列为低电平的二极管被点亮。硬件结构在上一节已经介绍过。\n实验8-1 点亮一个点 实现功能：在点阵屏上点亮一个点，以左上角的点为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //main函数之外的程序与实验7-1相同 #include \u0026#34;reg52.h\u0026#34; typedef unsigned char u8; typedef unsigned int u16; sbit SRCLK = P3^6; sbit rCLK = P3^5; sbit SER = P3^4; #define LED_COL_PORT P0 void delay_10us(u16 time) { while(time --); } void hc595_write_data(u8 dat) { u8 i = 0; for(i = 0;i \u0026lt; 8;i++) { SER = dat \u0026gt;\u0026gt; 7; dat \u0026lt;\u0026lt;= 1; SRCLK = 0; delay_10us(1); SRCLK = 1; } rCLK = 0; delay_10us(1); rCLK = 1; } void main() { LED_COL_PORT = 0x7f; //列线路设为01111111 while(1) { hc595_write_data(0x80); //行线路设为10000000 } } 实验8-2 显示数字 实现功能：在点阵屏上显示一个数字。\n数字、文字等点阵图像较为复杂，可以通过字模提取软件方便地生成点阵数据。\n软件界面：\n基本操作-新建图像，根据点阵屏大小选择行列数，生成空白点阵：\n模拟动画-放大格点：\n在点阵上点选需要点亮的点：\n参数设置-其他选项，取模方式根据扫描方式选择横向或纵向，横向取模数据为每一行点亮对应列LED的数据，纵向取模数据为每一列点亮对应行LED的数据，字节倒序根据开发板接线顺序按需勾选，输出数据的数位对应点阵上的行和列上高下低、左高右低时不勾选，反之则勾选：\n取模方式-C51格式，在点阵生成区生成字模数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026#34;reg52.h\u0026#34; typedef unsigned char u8; typedef unsigned int u16; sbit SRCLK = P3^6; sbit rCLK = P3^5; sbit SER = P3^4; #define LED_COL_PORT P0 //控制数字0每一列上哪些行的点被点亮的数据，即纵向取模生成的字模数据 u8 gled_row[8] = {0x00, 0x7C, 0x82, 0x82, 0x82, 0x7C, 0x00, 0x00}; //控制点阵依次扫描每一列的数据，即被扫描列为低电平，其余为高电平 u8 gled_col[8] = {0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0xfe}; void delay_10us(u16 time) { while(time --); } void hc595_write_data(u8 dat) { u8 i = 0; for(i = 0;i \u0026lt; 8;i++) { SER = dat \u0026gt;\u0026gt; 7; dat \u0026lt;\u0026lt;= 1; SRCLK = 0; delay_10us(1); SRCLK = 1; } rCLK = 0; delay_10us(1); rCLK = 1; } void main() { u8 i = 0; while(1) { for(i = 0;i \u0026lt; 8;i++) { //扫描相应的列 LED_COL_PORT = gled_col[i]; //将该列上的行点亮 hc595_write_data(gled_row[i]); delay_10us(100); //延时控制在人眼视觉暂留范围内 hc595_write_data(0x00); //消隐 } } } 实验8-3 显示数字（595级联） 本实验采用横向取模。8×8点阵上面对应595芯片并行输出的高位，下面对应低位，而16×16点阵上面为低位，下面为高位，因此勾选字节倒序，取模参数如下：\n当对16×16点阵横向取模时，取模软件对每一行先取前八列数据为一个字节，再取后八列数据为一个字节，从上往下，得到取模结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include \u0026#34;reg52.h\u0026#34; typedef unsigned char u8; typedef unsigned int u16; sbit SRCLK = P3^6; sbit rCLK = P3^5; sbit SER = P3^4; //控制数字0每一行上哪些列的点被点亮的数据，即横向取模生成的字模数据 //根据取模顺序可知，奇数位的数据对应前八列，传给第三个芯片，偶数位的数据对应后八列，传给第四个芯片 //取模的规则为高电平点亮、低电平不点亮，这与列线路点亮规则相反，因此后续使用要取反 u8 gled_col[32] = {0x00, 0x00, 0xE0, 0x03, 0x10, 0x04, 0x08, 0x08, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x04, 0x10, 0x08, 0x08, 0x10, 0x04, 0xE0, 0x03, 0x00, 0x00} //控制点阵依次扫描每一行的数据 //我们将前两个芯片的数据写在一个数组里，前十六个传给第一个芯片，后十六个传给第二个芯片 //扫描前八列时，对应后八列的第二个芯片全为0x00；扫描后八列时，对应前八列的第一个芯片全为0x00 u8 gled_row[32] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,} void hc595_write_data(u8 dat1, u8 dat2, u8 dat3, u8 dat4) { u8 i = 0; for(i = 0;i \u0026lt; 8;i++) { SER = dat4 \u0026gt;\u0026gt; 7; dat4 \u0026lt;\u0026lt;= 1; SRCLK = 0; delay_10us(1); SRCLK = 1; } for(i = 0;i \u0026lt; 8;i++) { SER = dat3 \u0026gt;\u0026gt; 7; dat3 \u0026lt;\u0026lt;= 1; SRCLK = 0; delay_10us(1); SRCLK = 1; } for(i = 0;i \u0026lt; 8;i++) { SER = dat2 \u0026gt;\u0026gt; 7; dat2 \u0026lt;\u0026lt;= 1; SRCLK = 0; delay_10us(1); SRCLK = 1; } for(i = 0;i \u0026lt; 8;i++) { SER = dat1 \u0026gt;\u0026gt; 7; dat1 \u0026lt;\u0026lt;= 1; SRCLK = 0; delay_10us(1); SRCLK = 1; } rCLK = 0; delay_10us(1); rCLK = 1; } void main() { u8 i = 0; while(1) { //依次扫描每一行点亮对应列的数据，对参数的详细解释见定义数组的注释 for(i = 0;i \u0026lt; 16;i++) { hc595_write_data(gled_row[i], gled_row[i + 16], ~gled_col[i * 2], ~gled_col[i * 2 + 1]); delay_10us(10); //由于传输四个字节的数据的延时较长，所以这里延时较短 } } } ","date":"2024-11-27T00:00:00Z","permalink":"https://INKEM.github.io/p/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%AE%9E%E9%AA%8C78.io%E6%89%A9%E5%B1%95-led%E7%82%B9%E9%98%B5/","title":"【51单片机】程序实验7\u00268.IO扩展-LED点阵"},{"content":"Python面向对象编程 面向对象编程简介 Python中每一个数据都是一个对象。正如房屋是照蓝图建造的一样，对象是用类创建的，创建自定义类就是创建一种新的数据类型。类是面向对象编程的核心技术之一，创建有价值的类对构建满足需求的应用程序会有所帮助。\n在创建新类时，可以通过继承已定义基类（也称作父类）的属性（类版本的变量）和方法（类版本的函数）指定新类的初始组成，新类被称为派生类（或子类）。继承后，还可以自定义派生类以满足应用程序的具体需求。\n多态可以简单地将同样的方法调用发送到可能是许多不同类型的对象，每一个对象都会根据对象所属类型决定执行哪个类的方法，因此同样的方法调用可能产生多种不同的处理。\n自定义Account类 我们以银行的Account（账户）类开始本节内容，这里考虑的Account类仅包括持有者姓名和余额这两个信息。\n试用Account类 在定义Account类之前，先了解一下Account类的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 In [1]: from account import Account #导入Account类 In [2]: from decimal import Decimal #Account类以Decimal类型保存和操作账户余额，因此导入Decimal类 #类的对象使用类名+括号创建，被称为构造器表达式，构造器表达式创建新对象，并利用小括号中指定的参数初始化新对象中的数据 In [3]: account1 = Account(\u0026#39;John Green\u0026#39;, Decimal(\u0026#39;50.00\u0026#39;)) #访问Account对象的name和balance属性 In [4]: account1.name Out[4]: \u0026#39;John Green\u0026#39; In [5]: account1.balance Out[5]: Decimal(\u0026#39;50.00\u0026#39;) #Account的deposit方法接收一个正数美元金额并将其加到余额上，传入错误参数导致ValueError异常 In [6]: acount1.deposit(Decimal(\u0026#39;25.53\u0026#39;)) #此时account1.balance为75.53 定义Account类 一个类的定义以class关键字开始，后面跟着类名和冒号，这行代码被称为类头。紧跟着类头通常提供一个描述性的文档字符串。\n1 2 3 4 from decimal import Decimal class Account: \u0026#34;\u0026#34;\u0026#34;Account class for maintaining a bank account balance.\u0026#34;\u0026#34;\u0026#34; __init__方法 构造器表达式创建新对象通过调用类的__init__方法初始化对象数据，每个新类都可以提供一个__init__方法指定一个对象的数据属性的初始化方式。\n当指定对象调用一个方法时，Python隐式地将这个对象的引用传递给所调用的方法并作为这个方法的第一个参数，因此一个类中的每个方法都必须至少包含一个参数，按照惯例接收对象引用的第一个参数被命名为self。\n1 2 3 4 5 6 7 def __init__(self, name, balance): #验证balance参数是否有效，若为负数则返回一个ValueError异常 if balance \u0026lt; Decimal(\u0026#39;0.00\u0026#39;): raise ValueError(\u0026#39;Initial balance must be \u0026gt;= to 0.00.\u0026#39;) self.name = name #为对象添加属性 self.balance = balance Python类可以定义许多特殊方法，如__init__，每一个特殊方法的方法名都是以双下划线开头和结尾。\ndeposit方法 1 2 3 4 def deposit(self, amount): if amount \u0026lt; Decimal(\u0026#39;0.00\u0026#39;): raise ValueError(\u0026#39;amount must be positive.\u0026#39;) self.balance += amount 属性访问控制 一个类的客户端代码是使用类对象的任何代码。\n大多数面向对象编程语言能够封装（或隐藏）一个对象的数据，被称为私有数据。\nPython没有私有数据，但是通过命名约定将类的属性分为直接访问属性（attribute）和间接访问属性（property），间接访问属性命名以下划线开始，仅供类内使用，但这只是一种约定，其仍能在客户端代码中访问。\n同样的，一些方法也可以作为仅在类内使用的工具方法，命名以单下划线开始。\n对于直接访问属性而言，直接给数据属性赋值无法验证赋值的有效性，而间接访问属性不一样，将在下一节中具体讨论。\nTime类与property 试用Time类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 In [1]: from timewithproperties import Time #创建一个Time对象 In [2]: wake_up = Time(hour = 6, minute = 30) #Time类的__init__方法有hour、minute和second三个参数，每个参数的默认值为0 #显示Time对象 #__repr__特殊方法生成该对象的字符串表示 In [3]: wake_up Out[3]: Time(hour=6, minute=30, second=0) #__str__特殊方法创建12小时时钟格式的字符串 In [4]: print(wake_up) 6:30:00 AM #通过property获取属性值 In [5]: wake_up.hour Out[5]: 6 #property以方法的形式实现，此处调用hour方法返回数据属性的值而不是简单获取 #设置时间 In [6]: wake_up.set_time(hour = 7, minute = 45) #通过property设置属性值 In [7]: wake_up.hour = 6 #property调用hour方法以6为参数，该方法会先验证值是否有效 Time类的定义 __init__方法 1 2 3 4 5 6 class Time: \u0026#34;\u0026#34;\u0026#34;Class Time with read-write properties.\u0026#34;\u0026#34;\u0026#34; def __init__(self, hour = 0, minute = 0, second = 0): self.hour = hour self.minute = minute self.second = second 命名为hour的可读写property 以下代码定义了可公开访问、命名为hour的可读写property，用于操作名为_hour的数据属性，即间接访问。\nproperty像是数据属性，但被实现为方法。\n1 2 3 4 5 6 7 8 9 10 11 12 @property #每个property定义了一个getter方法用于获取一个数据属性的值，以@property装饰器开始 def hour(self): return self._hour @hour.setter #选择性地定义一个setter方法用于设置一个数据属性的值，以@property_name.setter形式的装饰器开始 def hour(self, hour): if not (0 \u0026lt;= hour \u0026lt;= 24): raise ValueError(f\u0026#39;Hour ({hour}) must be 0-23\u0026#39;) self._hour = hour #单独使用wake_up.hour调用getter方法，用赋值语句wake_up.hour=8调用setter方法 #可读写property既有getter方法也有setter方法，而只读property只有getter方法 分别命名为minute和second的可读写property 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @property def minute(self): return self.minute @minute.setter def minute(self, minute): if not (0 \u0026lt;= minute \u0026lt; 60): raise ValueError(f\u0026#39;Minute ({minute}) must be 0-59\u0026#39;) self._minute = minute @property def second(self): return self._second @second.setter def second(self, second): if not (0 \u0026lt;= second \u0026lt; 60): raise ValueError(f\u0026#39;Second ({second}) must be 0-59\u0026#39;) self._second = second set_time方法 1 2 3 4 5 #使用set_time方法以单一的方法调用同时修改3个属性的值 def set_time(self, hour = 0, minute = 0, second = 0): self.hour = hour self.minute = minute self.second = second __repr__特殊方法 1 2 3 #在IPython会话中评估一个变量会隐式地执行内置函数repr，对应类的__repr__方法会被调用得到该对象的字符串表示 def __repr__(self): return (f\u0026#39;Time(hour={self.hour}, minute={self.minute}, second={self.second})\u0026#39;) __str__特殊方法 1 2 3 4 5 #当使用内置函数str将一个对象转成字符串时（print函数隐式调用str），__str__方法被隐式调用 def __str__(self): return ((\u0026#39;12\u0026#39; if self.hour in (0, 12) else str(self.hour % 12)) + f\u0026#39;:{self.minute:0\u0026gt;2}:{self.second:0\u0026gt;2}\u0026#39; + (\u0026#39; AM\u0026#39; if self.hour \u0026lt; 12 else \u0026#39; PM\u0026#39;)) 模拟“私有”属性 Python对象的属性始终是可访问的，但是对“私有”属性有命名约定。\n如果要创建一个Time类的对象，并禁止下面的赋值语句：\n$\\texttt{wake}\\_\\texttt{up.}\\_\\texttt{hour = 100}$\n则应该用以双下划线开始的“私有”属性名__hour，因为Python会自动对“私有”属性加前缀_ClassName（ClassName为属性所属的类名），如__hour修饰为_Time__hour，这被称为命名修饰。如果使用__hour对其赋值，会显示类中没有该属性。\n类属性 一个类的每个对象都有关于类中数据属性的独立的值，这种属于对象的属性称为实例属性。\n有些情况下，一个属性需要由一个类的所有对象共享。类属性用于表示类范围的信息，这个信息属于类，而不属于该类的一个特定对象。\n例如在表示扑克牌的Card类中，我们会这样定义类属性：\n1 2 3 class Card: FACES = [\u0026#39;Ace\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;10\u0026#39;, \u0026#39;Jack\u0026#39;, \u0026#39;Queen\u0026#39;, \u0026#39;King\u0026#39;] SUITS = [\u0026#39;Hearts\u0026#39;, \u0026#39;Diamonds\u0026#39;, \u0026#39;Clubs\u0026#39;, \u0026#39;Spades\u0026#39;] 在类定义内部但在所有方法和property外，可以通过赋值定义一个类属性。每个Card对象不需要单独保存这两个列表就可以访问列表中的值。\n","date":"2024-11-24T00:00:00Z","permalink":"https://INKEM.github.io/p/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","title":"【Python】面向对象编程"},{"content":"操作臂动力学 刚体的加速度 对刚体的线速度和角速度进行求导分别得到线加速度和角加速度：\n$^B\\dot{V}_Q=\\frac{\\mathrm{d}}{\\mathrm{d}t}^BV_Q=\\lim_{\\Delta t\\rightarrow0}\\frac{^BV_Q(t+\\Delta t)-^BV_Q(t)}{\\Delta t}$\n$^A\\dot{\\Omega}_B=\\frac{\\mathrm{d}}{\\mathrm{d}t}^A\\Omega_B=\\lim_{\\Delta t\\rightarrow0}\\frac{^A\\Omega_B(t+\\Delta t)-^A\\Omega_B(t)}{\\Delta t}$\n当刚体所处的瞬时参考坐标系为世界坐标系$\\{U\\}$时，可用下列符号表示：\n$\\dot{v}_a=^U\\dot{V}_AORG$\n$\\dot{\\omega}_A=^U\\dot{\\Omega}_A$\n线加速度 应用第五章所得公式：\n$^AV_Q=^AV_{BORG}+^A_BR^BV_Q+^A\\Omega_B\\times^A_BR^BQ$\n当$\\{A\\}$与$\\{B\\}$原点重合：\n$^AV_Q=\\frac{\\mathrm{d}}{\\mathrm{d}t}(^A_BR^BQ)=^A_BR^BV_Q+^A\\Omega_B\\times^A_BR^BQ$①\n对上式求导：\n$^A\\dot{V}_Q=\\frac{\\mathrm{d}}{\\mathrm{d}t}(^A_BR^BQ)+^A\\dot{\\Omega}_B\\times^A_BR^BQ+^A\\Omega_B\\times\\frac{\\mathrm{d}}{\\mathrm{d}t}(^A_BR^BQ)$\n$=^A_BR^B\\dot{V}_Q+^A\\Omega_B\\times^A_BR^BV_Q+^A\\dot{\\Omega}_B\\times^A_BR^BQ+^A\\Omega_B\\times(^A_BR^BV_Q+^A\\Omega_B\\times^A_BR^BQ)$\n$=^A_BR^B\\dot{V}_Q+2^A\\Omega_B\\times^A_BR^BV_Q+^A\\dot{\\Omega}_B\\times^A_BR^BQ+^A\\Omega_B\\times(^A\\Omega_B\\times^A_BR^BQ)$\n再考虑原点不重合的情况，加上$\\{B\\}$原点的加速度：\n$^A\\dot{V}_Q=^A\\dot{V}_{BORG}+^A_BR^B\\dot{V}_Q+2^A\\Omega_B\\times^A_BR^BV_Q+^A\\dot{\\Omega}_B\\times^A_BR^BQ+^A\\Omega_B\\times(^A\\Omega_B\\times^A_BR^BQ)$②\n上式为求解加速度的一般公式。\n当计算旋转关节操作臂连杆线加速度时，$^BQ$为常量，即：\n$^BV_Q=^B\\dot{V}_Q=0$\n此时②简化为：\n$^A\\dot{V}_Q=^A\\dot{V}_{BORG}+^A\\dot{\\Omega}_B\\times^A_BR^BQ+^A\\Omega_B\\times(^A\\Omega_B\\times^A_BR^BQ)$③\n角加速度 假设$\\{B\\}$以$^A\\Omega_B$相对于$\\{A\\}$转动，同时$\\{C\\}$以$^B\\Omega_C$相对于$\\{B\\}$转动，则：\n$^A\\Omega_C=^A\\Omega_B+^A_BR^B\\Omega_C$\n对上式求导：\n$^A\\dot{\\Omega}_C=^A\\dot{\\Omega}_B+\\frac{\\mathrm{d}}{\\mathrm{d}t}(^A_BR^B\\Omega_C)$\n最后一项用$^B\\Omega_C$代入①中$^BQ$：\n$^A\\dot{\\Omega}_C=^A\\dot{\\Omega}_B+^A_BR^B\\dot{\\Omega}_C+^A\\Omega_B\\times^A_BR^B\\Omega_C$④\n上式用于计算操作臂连杆的角加速度。\n质量分布 对一个可以在三维空间自由移动的刚体来说可能存在无穷个旋转轴。在一个刚体绕任意轴做旋转运动时，我们需要一种能够表征刚体质量分布的方式。我们引入惯性张量，可以看做是对一个物体惯性矩的广义度量。\n惯性张量可以在任何坐标系中定义，但一般在刚体自身坐标系中定义，用左上标表明已知惯性张量所在的坐标系。$\\{A\\}$中的惯性张量可用$3\\times3$矩阵表示如下：\n$^AI=\\begin{bmatrix}I_{xx}\u0026-I_{xy}\u0026-I_{xz}\\\\-I_{xy}\u0026I_{yy}\u0026-I_{yz}\\\\-I_{xz}\u0026-I_{yz}\u0026I_{zz}\\end{bmatrix}$\n矩阵中各元素为：\n$I_{xx}=\\iiint_V(y^2+z^2)\\rho\\mathrm{d}v$\n$I_{yy}=\\iiint_V(x^2+z^2)\\rho\\mathrm{d}v$\n$I_{zz}=\\iiint_V(x^2+y^2)\\rho\\mathrm{d}v$\n$I_{xy}=\\iiint_Vxy\\rho\\mathrm{d}v$\n$I_{xz}=\\iiint_Vxz\\rho\\mathrm{d}v$\n$I_{yz}=\\iiint_Vyz\\rho\\mathrm{d}v$\n式中刚体由单元体$\\mathrm{d}v$组成，单元体的密度为$\\rho$，每个单元体的位置由矢量$^AP=(x,y,z)^T$确定。\n$I_{xx}$、$I_{yy}$和$I_{zz}$称为惯性矩，其余三个交叉项称为惯量积。对一个刚体来说，该六个相互独立的参量取决于所在坐标系的位置和姿态。当选择的坐标系姿态使刚体的惯量积为零时，该坐标系的轴被称为主轴，而相应的惯量矩被称为主惯性矩。\n平行移轴定理描述了一个以刚体质心为原点的坐标系平移到另一个坐标系时惯性张量的变换关系。假设$\\{C\\}$是以刚体质心为原点的坐标系，$\\{A\\}$为任意平移后的坐标系，则平行移轴定理可以表示为：\n$^AI_{zz}=^CI_{zz}+m(x^2_c+y^2_c)$\n$^AI_{xy}=^CI_{xy}-mx_cy_c$\n式中矢量$P_c=(x_c,y_c,z_c)^T$表示刚体质心在$\\{A\\}$中的位置，其余轴下标的变换公式同理。\n平行移轴定理的矢量-矩阵形式为：\n$^AI=^CI+m(P^T_cP_cI_3-P_cP_c^T)$\n式中$I_3$为$3\\times3$单位矩阵。\n惯性张量的其他性质：\n如果坐标系的两个坐标轴构成的平面为刚体质量分布的对称平面，则第三个坐标轴与这两个坐标轴的惯性积为零。 三个惯量矩的和与参考坐标系的姿态无关。 惯性张量的特征值为刚体的主惯性矩，特征矢量为主轴。 大多数操作臂连杆的几何形状及结构组成都比较复杂，因而很难直接应用公式求解，一般使用测量装置来测量每个连杆的惯性矩。\n牛顿-欧拉方程递推动力学方程 牛顿方程和欧拉方程 牛顿方程以及描述旋转运动的欧拉方程描述了力、惯量和加速度之间的关系。\n牛顿方程\n$F=m\\dot{v}_c$\n$F$：作用在质心上的力；\n$m$：刚体的总质量；\n$\\dot{v}_c$：刚体质心的加速度。\n欧拉方程\n$N=^CI\\dot{\\omega}+\\omega\\times^CI\\omega$\n$N$：作用在刚体上的力矩；\n$^CI$：刚体在$\\{C\\}$中的惯性张量，$\\{C\\}$的原点在质心；\n$\\omega$和$\\dot{\\omega}$：刚体旋转的角速度和角加速度。\n计算速度和加速度的外推法 为了计算作用在连杆上的惯性力，需要计算操作臂每个连杆质心在某一时刻的角速度、线加速度和角加速度。可应用递推方法完成这些计算，首先对连杆$1$进行计算，接着计算下一个连杆，一直外推到连杆$n$。\n第五章机器人连杆的运动中我们给出了角速度在连杆之间的传播方程：\n$^{i+1}\\omega_{i+1}=^{i+1}_{i}R^i\\omega_i+\\dot{\\theta}_{i+1}{}^{i+1}\\hat{Z}_{i+1}$\n本章④给出了连杆之间角加速度变换的方程：\n$^{i+1}\\dot{\\omega}_{i+1}=^{i+1}_iR^i\\dot{\\omega}_i+^{i+1}_iR^i\\omega_i\\times\\dot{\\theta}_{i+1}\\hat{Z}_{i+1}+\\ddot{\\theta}_{i+1}{}^{i+1}\\hat{Z}_{i+1}$\n当第$i+1$个关节为移动关节时，上式可简化为：\n$^{i+1}\\dot{\\omega}_{i+1}=^{i+1}_{i}R^i\\dot{\\omega}_i$\n本章③可得到每个连杆坐标系原点的线加速度：\n$^{i+1}\\dot{v}_{i+1}=^{i+1}_iR[^i\\dot{\\omega}_i\\times^iP_{i+1}+^i\\omega_i\\times(^i\\omega_i\\times^iP_{i+1})+^i\\dot{v}_i]$\n当第$i+1$个关节为移动关节时，上式变为②：\n$^{i+1}\\dot{v}_{i+1}=^{i+1}_iR[^i\\dot{\\omega}_i\\times^iP_{i+1}+^i\\omega_i\\times(^i\\omega_i\\times^iP_{i+1})+^i\\dot{v}_i]+2^{i+1}\\omega_{i+1}\\times\\dot{d}_{i+1}{}^{i+1}\\hat{Z}_{i+1}+\\ddot{d}_{i+1}{}^{i+1}\\hat{Z}_{i+1}$\n同理用③可得到每个连杆质心的线加速度：\n$^i\\dot{v}_{C_i}=^i\\dot{\\omega}_i\\times^iP_{C_i}+^i\\omega_i\\times(^i\\omega_i\\times^iP_{C_i})+^i\\dot{v}_i$\n其中$\\{C_i\\}$原点位于连杆质心，姿态与$\\{i\\}$相同。\n作用在连杆上的力和力矩 计算出每个连杆质心的线加速度和角加速度之后，运用牛顿-欧拉公式可以计算出作用在连杆质心上的惯性力和力矩：\n$F_i=m\\dot{v}_{C_i}$\n$N_i=^{C_i}I\\dot{\\omega}_i+\\omega_i\\times^{C_i}I\\omega_i$\n计算力和力矩的内推法 计算出每个连杆上的作用力和力矩之后，需要计算这些产生施加在连杆上的力和力矩所对应的关节力矩。\n第五章操作臂的静力一节中定义了：\n$f_i=$连杆$i-1$作用在连杆$i$上的力；\n$n_i=$连杆$i-1$作用在连杆$i$上的力矩。\n则作用在连杆$i$上的合力：\n$^iF_i=^if_i-^i_{i+1}R^{i+1}f_{i+1}$⑤\n作用在连杆质心上的合力矩：\n$^iN_i=^in_i-^in_{i+1}+(-^iP_{C_i})\\times^if_i-(^iP_{i+1}-^iP_{C_i})\\times^if_{i+1}$\n利用⑤和旋转矩阵变换上式可写成：\n$^iN_i=^in_i-^i_{i+1}R^{i+1}n_{i+1}-^iP_{C_i}\\times^iF_i-^iP_{i+1}\\times^i_{i+1}R^{i+1}f_{i+1}$\n最后重新排列力和力矩方程形成相邻连杆从高序号向低序号的迭代关系：\n$^if_i=^i_{i+1}R^{i+1}f_{i+1}+^iF_i$\n$^in_i=^iN_i+^i_{i+1}R^{i+1}n_{i+1}+^iP_{C_i}\\times^iF_i+^iP_{i+1}\\times^i_{i+1}R^{i+1}f_{i+1}$\n应用这些方程从连杆$n$开始向内递推到机器人基座依次求解。\n最终由第五章操作臂的静力一节给出关节驱动力为：\n$\\tau_i=^in_i^T{}^i\\hat{Z}_i$\n对于移动关节：\n$\\tau_i=^if_i^T{}^i\\hat{Z}_i$\n牛顿-欧拉递推动力学算法 由关节运动计算关节力矩的完整算法由两部分组成：第一部分是对每个连杆应用牛顿-欧拉方程从连杆$1$到连杆$n$向外递推计算连杆的速度和加速度；第二部分是从连杆$n$到连杆$1$跌倒计算连杆间的相互作用力和力矩以及关节驱动力矩。对于转动关节，该算法归纳如下：\n外推：\n$^{i+1}\\omega_{i+1}=^{i+1}_{i}R^i\\omega_i+\\dot{\\theta}_{i+1}{}^{i+1}\\hat{Z}_{i+1}$\n$^{i+1}\\dot{\\omega}_{i+1}=^{i+1}_iR^i\\dot{\\omega}_i+^{i+1}_iR^i\\omega_i\\times\\dot{\\theta}_{i+1}\\hat{Z}_{i+1}+\\ddot{\\theta}_{i+1}{}^{i+1}\\hat{Z}_{i+1}$\n$^{i+1}\\dot{v}_{i+1}=^{i+1}_iR[^i\\dot{\\omega}_i\\times^iP_{i+1}+^i\\omega_i\\times(^i\\omega_i\\times^iP_{i+1})+^i\\dot{v}_i]$\n$^{i+1}\\dot{v}_{C_{i+1}}=^{i+1}\\dot{\\omega}_{i+1}\\times^{i+1}P_{C_{i+1}}+^{i+1}\\omega_{i+1}\\times(^{i+1}\\omega_{i+1}\\times^{i+1}P_{C_{i+1}})+^{i+1}\\dot{v}_{i+1}$\n$F_{i+1}=m\\dot{v}_{C_{i+1}}$\n$N_{i+1}=^{C_{i+1}}I\\dot{\\omega}_{i+1}+\\omega_{i+1}\\times^{C_{i+1}}I\\omega_{i+1}$\n内推：\n$^if_i=^i_{i+1}R^{i+1}f_{i+1}+^iF_i$\n$^in_i=^iN_i+^i_{i+1}R^{i+1}n_{i+1}+^iP_{C_i}\\times^iF_i+^iP_{i+1}\\times^i_{i+1}R^{i+1}f_{i+1}$\n$\\tau_i=^in_i^T{}^i\\hat{Z}_i$\n考虑重力的动力学算法 令$^0\\dot{v}_0=G$即可将作用在连杆上的重力因素包括到动力学方程中去，其中$G$与重力矢量等大反向。\n操作臂动力学方程的结构 迭代形式与封闭形式 上述动力学方程主要应用于数值计算（迭代形式）或作为分析方法用于符号方程的推导（封闭形式）。\n对于数值计算，只要将待求操作臂的惯性张量、连杆质量、连杆质心位置矢量和相邻连杆的旋转矩阵代入这些方程中即可计算出任何运动情况下的关节力矩。\n当需要对方程的结构进行研究，例如重力项的形式、重力和惯性力的影响效果等，就要给出封闭形式的动力学方程。\n一个如图所示的RR操作臂，为简单起见假设每个连杆的质量都集中在连杆的末端，应用上述方程得到的封闭形式的动力学方程如下：\n$\\tau_1=m_2l_2^2(\\ddot{\\theta}_1+\\ddot{\\theta}_2)+m_2l_1l_2c_2(2\\ddot{\\theta}_1+\\ddot{\\theta}_2)+(m_1+m_2)l^2_1\\ddot{\\theta}_1-m_2l_1l_2s_2\\dot{\\theta}_2^2-2m_2l_1l_2s_2\\dot{\\theta}_1\\dot{\\theta}_2+m_2l_2gc_{12}+(m_1+m_2)l_1gc_1$\n$\\tau_2=m_2l_1l_2c_2\\ddot{\\theta}_1+m_2l_1l_2s_2\\dot{\\theta}^2_1+m_2l_2gc_{12}+m_2l^2_2(\\ddot{\\theta}_1+\\ddot{\\theta}_2)$\n如此复杂的函数表达式描述的只是一个最简单的操作臂，可见一个封闭形式的六自由度操作臂的动力学方程是相当复杂的。\n状态空间方程 忽略一个方程中的某些细节而仅显示方程的某些结构可以很方便地表示操作臂的动力学方程。\n用牛顿-欧拉方程对操作臂进行分析时，动力学方程可写成如下形式：\n$\\tau=M(\\Theta)\\ddot{\\Theta}+V(\\Theta,\\dot{\\Theta})+G(\\Theta)$\n式中$M(\\Theta)$为操作臂的$n\\times n$质量矩阵，$V(\\Theta,\\dot{\\Theta})$为$n\\times1$的离心力和科氏力矢量，$G(\\Theta)$是$n\\times1$重力矢量。上式称为状态空间方程，因为矢量$V(\\Theta,\\dot{\\Theta})$取决于位置和速度。\n以上面给出的RR操作臂为例：\n$\\tau=\\begin{bmatrix}\\tau_1\\\\\\tau_2\\end{bmatrix},\\ddot{\\Theta}=\\begin{bmatrix}\\ddot{\\theta}_1\\\\\\ddot{\\theta}_2\\end{bmatrix}$\n质量矩阵$M(\\Theta)$的所有各项均为$\\Theta$的函数并与$\\ddot{\\Theta}$相乘：\n$M(\\Theta)=\\begin{bmatrix}l^2_2+2l_1l_2m_2c_2+l_1^2(m_1+m_2)\u0026l^2_2m_2+l_1l_2m_2c_2\\\\l^2_2m_2+l_1l_2m_2c_2\u0026l^2_2m_2\\end{bmatrix}$\n速度项$V(\\Theta,\\dot{\\Theta})$包含了所有与关节速度有关的项：\n$V(\\Theta,\\dot{\\Theta})=\\begin{bmatrix}-m_2l_1l_2s_2\\dot{\\theta}^2_2-2m_2l_1l_2s_2\\dot{\\theta}_1\\dot{\\theta}_2\\\\m_2l_1l_2s_2\\dot{\\theta}^2_1\\end{bmatrix}$\n$-m_2l_1l_2s_2\\dot{\\theta}^2_1$是与离心力有关的项，因为它是关节速度的平方；\n$-2m_2l_1l_2s_2\\dot{\\theta}_1\\dot{\\theta}_2$是与科氏力有关的项，因为它总是包含两个不同关节速度的乘积。\n重力项$G(\\Theta)$包含了所有与重力加速度$g$有关的项：\n$G(\\Theta)=\\begin{bmatrix}m_2l_2gc_{12}+(m_1+m_2)l_1gc_1\\\\m_2l_2gc_{12}\\end{bmatrix}$\n位形空间方程 将动力学方程中速度项$V(\\Theta,\\dot{\\Theta})$离心力和科氏力拆开来，并提取出关节速度项，写成另外一种形式如下：\n$\\tau=M(\\Theta)\\ddot{\\Theta}+B(\\Theta)(\\dot{\\Theta}\\dot{\\Theta})+C(\\Theta)(\\dot{\\Theta}^2)+G(\\Theta)$⑥\n式中$B(\\Theta)$为$n\\times n(n-1)/2$阶科氏力系数矩阵，$(\\dot{\\Theta}\\dot{\\Theta})$是$n(n-1)/2\\times1$阶关节速度矢量，即：\n$(\\dot{\\Theta}\\dot{\\Theta})=(\\dot{\\theta}_1\\dot{\\theta}_2,\\dot{\\theta}_1\\dot{\\theta}_3,\\cdots,\\dot{\\theta}_{n-1}\\dot{\\theta}_n)^T$\n$C(\\Theta)$是$n\\times n$阶离心力系数矩阵，$(\\dot{\\Theta}^2)$是$n\\times1$阶矢量，即：\n$(\\dot{\\Theta}^2)=(\\dot{\\theta}^2_1,\\dot{\\theta}^2_2,\\cdots,\\dot{\\theta}^2_n)T$\n⑥称为位形空间方程，因为它的系数矩阵仅是操作臂位置的函数。\n以上面给出的RR操作臂为例：\n$(\\dot{\\Theta}\\dot{\\Theta})=(\\dot{\\theta}_1\\dot{\\theta}_2),(\\dot{\\Theta}^2)=\\begin{bmatrix}\\dot{\\theta}^2_1\\\\\\dot{\\theta}^2_2\\end{bmatrix}$\n$B(\\Theta)=\\begin{bmatrix}-2m_2l_1l_2s_2\\\\0\\end{bmatrix}$\n$C(\\Theta)=\\begin{bmatrix}0\u0026-m_2l_1l_2s_2\\\\m_2l_1l_2s_2\u00260\\end{bmatrix}$\n操作臂动力学的拉格朗日方程 牛顿-欧拉公式是一种解决动力学问题的力平衡方法，而拉格朗日公式则是一种基于能量的动力学方法。对于同一个操作臂来说，两种方法得到的动力学方程式相同的。\n第$i$个连杆的动能$k_i$可以表示为：\n$k_i=\\frac{1}{2}m_iv^T_{C_i}v_{C_i}+\\frac{1}{2}{}^i\\omega^T_i{}^{C_i}I_i{}^i\\omega_i$\n式中第一项是连杆质心线速度动能，第二项是连杆角速度动能。整个操作臂的动能是各个连杆动能之和：\n$k=\\Sigma^n_{i=1}k_i$\n式中$v_{C_i}$和$^i\\omega_i$是$\\Theta$和$\\dot{\\Theta}$的函数，因此操作臂的动能$k$可描述为关节位置和速度的标量函数：\n$k(\\Theta,\\dot{\\Theta})=\\frac{1}{2}\\dot{\\Theta}^TM(\\Theta)\\dot{\\Theta}$\n这里$M(\\Theta)$为状态空间方程中介绍的$n\\times n$质量矩阵。\n第$i$个连杆的势能$u_i$可以表示为：\n$u_i=-m_i{}^0g^T{}^0P_{C_i}+u_{ref_i}$\n这里$^0g$是$3\\times1$重力矢量，$^0P_{C_i}$是位于第$i$个连杆质心的矢量，$u_{ref_i}$是使$u_i$的最小值为零的常数（即最小取到势能零点，实际上可以相对于任意一个参考零点）。操作臂的总势能为各个连杆势能之和：\n$u=\\Sigma^n_{i=1}u_i$\n式中$^0P_{C_i}$是$\\Theta$的函数，因此操作臂的势能$u$可以描述为关节位置的标量函数。\n拉格朗日力学公式给出了一种从标量函数推导动力学方程的方法，该标量函数称为拉格朗日函数，即一个机械系统的动能和势能的差值：\n$\\mathcal{L}(\\Theta,\\dot{\\Theta})=k(\\Theta,\\dot{\\Theta})-u(\\Theta)$\n则操作臂的运动方程为：\n$\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{\\partial\\mathcal{L}}{\\partial\\dot{\\Theta}}-\\frac{\\partial\\mathcal{L}}{\\partial\\Theta}=\\frac{\\mathrm{d}}{\\mathrm{d}t}\\frac{\\partial k}{\\partial\\dot{\\Theta}}-\\frac{\\partial k}{\\partial\\Theta}+\\frac{\\partial u}{\\partial\\Theta}=\\tau$\n笛卡尔空间中的操作臂动力学 笛卡尔状态空间方程 已知关节变量建立的状态空间方程为：\n$\\tau=M(\\Theta)\\ddot{\\Theta}+V(\\Theta,\\dot{\\Theta})+G(\\Theta)$⑦\n在操作臂控制当中，有时我们希望用笛卡尔变量的一般形式建立操作臂动力学方程：\n$\\mathcal{F}=M_x(\\Theta)\\ddot{\\chi}+V_x(\\Theta,\\dot{\\Theta})+G_x(\\Theta)$\n式中$\\mathcal{F}$是作用于机器人末端执行器上的力-力矩矢量，$\\chi$是表达末端执行器位置和姿态的笛卡尔矢量。\n与关节空间相对应，$M_x(\\Theta)$是笛卡尔质量矩阵，$V_x(\\Theta,\\dot{\\Theta})$是笛卡尔空间中的速度项矢量，$G_x(\\Theta)$是笛卡尔空间中的重力项矢量。\n在第五章力域中的雅可比一节中有：\n$\\tau=J^T(\\Theta)\\mathcal{F}$⑧\n其中$J(\\Theta)$与$\\mathcal{F}$和$\\chi$在同一个笛卡尔坐标系下。\n接下来推导关节变量与笛卡尔变量的状态空间方程之间的关系：\n对⑦两边同乘$J^{-T}$并结合⑧得到：\n$J^{-T}\\tau=\\mathcal{F}=J^{-T}M(\\Theta)\\ddot{\\Theta}+J^{-T}V(\\Theta,\\dot{\\Theta})+J^{-T}G(\\Theta)$⑨\n又由雅可比矩阵的定义得：\n$\\dot{\\chi}=J\\dot{\\Theta}$\n两边求导：\n$\\ddot{\\chi}=\\dot{J}\\dot{\\Theta}+J\\ddot{\\Theta}$\n$\\ddot{\\Theta}=J^{-1}\\ddot{\\chi}-J^{-1}\\dot{J}\\dot{\\Theta}$\n将上式代入⑨得：\n$\\mathcal{F}=J^{-T}M(\\Theta)J^{-1}\\ddot{\\chi}-J^{-T}M(\\Theta)J^{-1}\\dot{J}\\dot{\\Theta}+J^{-T}V(\\Theta,\\dot{\\Theta})+J^{-T}G(\\Theta)$\n由此得出笛卡尔空间动力学方程中各项的表达式：\n$M_x(\\Theta)=J^{-T}(\\Theta)M(\\Theta)J^{-1}(\\Theta)$\n$V_x(\\Theta,\\dot{\\Theta})=J^{-T}(\\Theta)(V(\\Theta,\\dot{\\Theta})-M(\\Theta)J^{-1}(\\Theta)\\dot{J}(\\Theta)\\dot{\\Theta})$\n$G_x(\\Theta)=J^{-T}(\\Theta)G(\\Theta)$\n笛卡尔位形空间中的力矩方程 用笛卡尔空间动力学方程写出等价的关节力矩：\n$\\tau=J^T(\\Theta)(M_x(\\Theta)\\ddot{\\chi}+V_x(\\Theta,\\dot{\\Theta})+G_x(\\Theta))$\n按与⑥类似的思路将上式改写为位形空间方程得：\n$\\tau=J^T(\\Theta)M_x(\\Theta)\\ddot{\\chi}+B_x(\\Theta)(\\dot{\\Theta}\\dot{\\Theta})+C_x(\\Theta)(\\dot{\\Theta}^2)+G(\\Theta)$\n式中$B_x(\\Theta)$是$n\\times n(n-1)/2$阶科氏力系数矩阵，$(\\dot{\\Theta}\\dot{\\Theta})$是$n(n-1)/2\\times1$阶关节速度矢量，即：\n$(\\dot{\\Theta}\\dot{\\Theta})=(\\dot{\\theta}_1\\dot{\\theta}_2,\\dot{\\theta}_1\\dot{\\theta}_3,\\cdots,\\dot{\\theta}_{n-1}\\dot{\\theta}_n)^T$\n$C_x(\\Theta)$是$n\\times n$阶离心力系数矩阵，$(\\dot{\\Theta}^2)$是$n\\times1$阶矢量，即：\n$(\\dot{\\Theta}^2)=(\\dot{\\theta}^2_1,\\dot{\\theta}^2_2,\\cdots,\\dot{\\theta}^2_n)T$\n$G(\\Theta)$与关节空间方程中的相同，但一般情况下$B_x(\\Theta)\\neq B(\\Theta),C_x(\\Theta)\\neq C(\\Theta)$。\n考虑非刚体影响 我们推导出的动力学方程没有包含摩擦力。\n最简单的摩擦力模型为粘性摩擦力，摩擦力矩与关节运动速度成正比：\n$\\tau_{friction}=v\\dot{\\theta}$\n式中$v$是粘性摩擦系数。\n有时应用另一个简单的摩擦力模型，就是库伦摩擦。库伦摩擦是一个常数，它的符号取决于关节速度：\n$\\tau_{friction}=c\\mathrm{sgn}(\\dot{\\theta})$\n式中$c$是库伦摩擦系数。当$\\dot{\\theta}=0$，$c$一般取$1$，称为静摩擦系数；当$\\dot{\\theta}\\neq0$，$c\u003c1$，称为动摩擦系数。\n（书中给出的公式及其解释博主未能理解，但根据定义，库伦摩擦即静摩擦定律和滑动摩擦定律的结合）\n比较合理的模型是二者兼顾：\n$\\tau_{friction}=c\\mathrm{sgn}(\\dot{\\theta})+v\\dot{\\theta}$\n在许多操作臂关节中，摩擦力也与节点位置有关。主要原因是齿轮不是理想圆，齿轮的偏心会导致摩擦力随关节位置而变化，因此一个比较复杂的摩擦力模型为：\n$\\tau_{friction}=f(\\theta,\\dot{\\theta})$\n将其附加到刚体力学模型的动力学方程中得到一个更完整的模型：\n$\\tau=M(\\Theta)\\ddot{\\Theta}+V(\\Theta,\\dot{\\Theta})+G(\\Theta)+F(\\Theta,\\dot{\\Theta})$\n还有其他一些影响因素，例如连杆弯曲效应引起谐振等，但是这些因素建模十分复杂，暂不讨论。\n本章完\n","date":"2024-11-23T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep6.%E6%93%8D%E4%BD%9C%E8%87%82%E5%8A%A8%E5%8A%9B%E5%AD%A6/","title":"【机器人学导论】Ep6.操作臂动力学"},{"content":"程序实验5\u0026amp;6.独立按键-矩阵按键 独立按键 按键介绍 一个按键拥有四个脚，其中①和②、③和④之间初始导通，而①和③、②和④之间只有按下按键才会导通。\n在下拉电阻作用下，按键所处管脚默认为高电平，当按下按键时线路接地变成低电平。\n在实际情况中，按键的状态切换过程存在抖动，而不是在高低电平之间瞬时、稳定地切换。由于抖动过程中的电平变化会造成按键状态的误判，因此需要采取消抖措施，有软件消抖和硬件消抖两种方法：\n软件消抖根据实际经验估计抖动时间在5~10ms，于是可以在检测到第一次低电平后延时10ms再次检测，若仍为低电平可认为按键已处于按下状态。\n硬件消抖在电路上并联滤波电容，利用按下按键后给电容充电的时间来滤除抖动影响。\n由于硬件消抖占用的电路面积较大且产生的成本较高，在实际开发应用中通常使用软件消抖。\n实验5 独立按键 实现功能：通过开发板上的独立按键K1控制D1指示灯的亮灭。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026#34;reg52.h\u0026#34; typedef unsigned char u8; typedef unsigned int u16; //定义四个按键的控制管脚 sbit KEY1 = P3^1; sbit KEY2 = P3^0; sbit KEY3 = P3^2; sbit KEY4 = P3^3; //定义D1指示灯的控制管脚 sbit LED1 = P2^0; //延时函数 void delay_10us(u16 time) { while(time --); } /* 按键扫描函数 扫描有两种方式：一种只对按下瞬间扫描，不考虑按下后是保持还是松开（点按控制）；另一种为持续扫描按键按下的状态（长按控制） mode参数决定该函数采用哪种扫描，0为点按，1为长按 */ u8 key_scan(u8 mode) { //定义控制是否检测按下状态的变量，1检测，0不检测，注意静态变量赋值只生效一次 static u8 key = 1; //如果为长按扫描则检测按下状态 if(mode) key = 1; //如果需要检测按下状态且有按键按下（低电平），则消抖后再检测具体是哪个按键被按下 if(key == 1 \u0026amp;\u0026amp; (KEY1 == 0 || KEY2 == 0 || KEY3 == 0 || KEY4 == 0)) { key = 0; //重置key变量默认下一次不需要检测按下状态 delay_10us(1000); //消抖 //检测到哪个按键按下则返回对应的按键序号 if(KEY1 == 0) return 1; else if(KEY2 == 0) return 2; else if(KEY3 == 0) return 3; else if(KEY4 == 0) return 4; } //如果没有按键被按下则下一次继续检测是否有按键被按下 else if(KEY1 == 1 \u0026amp;\u0026amp; KEY2 == 1 \u0026amp;\u0026amp; KEY3 == 1 \u0026amp;\u0026amp; KEY4 == 1) { key = 1; } return 0; } void main() { u8 key = 0; //存储按下按键序号的变量，没有按键被按下则为0 while(1) { key = key_scan(0); //循环按键扫描函数 if(key == 1) LED1 = !LED1; //如果按键K1被按下则切换D1指示灯状态 } } 矩阵按键 矩阵按键介绍 在独立按键中，一个按键占用一个I/O口。当按键数量较多时，如果采用独立按键的接法会占用非常多的I/O资源。单片机为了减少I/O占用的引脚，引入了矩阵按键。\n矩阵按键的一端串联在行线路上，另一端串联在列线路上，当按键按下时，按键所在的行线路和列线路接通。所有线路在下拉电阻作用下默认为高电平。\n矩阵按键的扫描有两种方法：\n行列式扫描按行（列）将矩阵按键拆成多组独立按键，对每一行（列）进行扫描时，将该行（列）设为低电平以达到独立按键中接地的条件，然后按独立按键扫描方法扫描，依次扫描完每一行（列）。\n线翻转扫描按先列（行）后行（列）的方式确定按下按键的位置，先将所有行（列）线路接地，检测哪一列（行）有按键被按下，则对应的列（行）接通为低电平；再将所有列（行）线路接地，检测哪一行（列）有按键被按下，结合被按下按键的列（行）坐标确认其序号。\n实验6-1 行列式扫描 实现功能：按下矩阵按键S1到S16使数码管第一位显示0到F。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include \u0026#34;reg52.h\u0026#34; typedef unsigned char u8; typedef unsigned int u16; //宏定义矩阵按键端口 #define KEY_MATRIX_PORT P1 //宏定义数码管端口 #define SEG_A_DP_PORT P0 //数码管0~F编码 u8 gseg_code[16]={0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71}; //延时函数 void delay_10us(u16 time) { while(time --); } //行列式扫描函数 u8 key_matrix_ranks_scan() { u8 key_value = 0; //存储按下按键序号的变量，没有按键被按下则为0 KEY_MATRIX_PORT = 0xf7; //第一列设为低电平，即P1端口高位到低位输出11110111（前四位为行，后四位为列），再转换为十六进制 if(KEY_MATRIX_PORT != 0xf7) //如果第一列有按键按下，则具体检测第一列哪一行按键被按下 { delay_10us(1000); //消抖 switch(KEY_MATRIX_PORT) //检测哪一行为低电平 { case 0x77: key_value = 1; break; case 0xb7: key_value = 5; break; case 0xd7: key_value = 9; break; case 0xe7: key_value = 13; break; } } while(KEY_MATRIX_PORT != 0xf7); //点按扫描在按下按键松开之前不再检测 KEY_MATRIX_PORT = 0xfb; //扫描第二列 if(KEY_MATRIX_PORT != 0xfb) { delay_10us(1000); switch(KEY_MATRIX_PORT) { case 0x7b: key_value = 2; break; case 0xbb: key_value = 6; break; case 0xdb: key_value = 10; break; case 0xeb: key_value = 14; break; } } while(KEY_MATRIX_PORT != 0xfb); KEY_MATRIX_PORT = 0xfd; //扫描第三列 if(KEY_MATRIX_PORT != 0xfd) { delay_10us(1000); switch(KEY_MATRIX_PORT) { case 0x7d: key_value = 3; break; case 0xbd: key_value = 7; break; case 0xdd: key_value = 11; break; case 0xed: key_value = 15; break; } } while(KEY_MATRIX_PORT != 0xfd); KEY_MATRIX_PORT = 0xfe; //扫描第四列 if(KEY_MATRIX_PORT != 0xfe) { delay_10us(1000); switch(KEY_MATRIX_PORT) { case 0x7e: key_value = 4; break; case 0xbe: key_value = 8; break; case 0xde: key_value = 12; break; case 0xee: key_value = 16; break; } } while(KEY_MATRIX_PORT != 0xfe); return key_value; } void main() { u8 key = 0; //存储按下按键序号的变量，没有按键被按下则为0 while(1) { key = key_matrix_ranks_scan(); //循环行列式扫描函数 if(key != 0) SEG_A_DP_PORT = gseg_code[key - 1]; //按下按键将数码管切换到对应的值 } } 实验6-2 线翻转扫描 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //线翻转扫描函数，将实验6-1中调用行列式扫描函数的地方替换为该函数即可 u8 key_matrix_flip_scan() { u8 key_value = 0; //存储按下按键序号的变量，没有按键被按下则为0 KEY_MATRIX_PORT = 0x0f; //将行线路全部接地，即P1端口输出00001111 if(KEY_MATRIX_PORT != 0x0f) //如果有按键按下则进入具体检测 { delay_10us(1000); //消抖 if(KEY_MATRIX_PORT != 0x0f) { switch(KEY_MATRIX_PORT) //检测哪一列为低电平，则该列有按键被按下 { case 0x07: key_value = 1; break; case 0x0b: key_value = 2; break; case 0x0d: key_value = 3; break; case 0x0e: key_value = 4; break; } KEY_MATRIX_PORT = 0xf0; //将列线路全部接地 switch(KEY_MATRIX_PORT) //检测哪一行为低电平 { case 0x70: key_value += 0; break; //按键序号 = 列序号 + 4 * (行序号 - 1) case 0xb0: key_value += 4; break; case 0xd0: key_value += 8; break; case 0xe0: key_value += 12; break; } while(KEY_MATRIX_PORT != 0xf0); //点按扫描在按下按键松开之前不再检测 } } return key_value; } 本篇完\n","date":"2024-11-22T00:00:00Z","permalink":"https://INKEM.github.io/p/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%AE%9E%E9%AA%8C56.%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE-%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE/","title":"【51单片机】程序实验5\u00266.独立按键-矩阵按键"},{"content":"Python基础语法速览（下） 字典和集合 字典 字典是无序的键-值对的合集，像传统字典中字和释义的映射一样，键-值对存储不可变的键到值的映射。\n字典的键必须是不可变且唯一的，多个键可以具有相同的值。\n创建字典 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 In [1]: country_codes = {\u0026#39;Finland\u0026#39;: \u0026#39;fi\u0026#39;, \u0026#39;South Africa\u0026#39;: \u0026#39;za\u0026#39;, \u0026#39;Nepal\u0026#39;: \u0026#39;np\u0026#39;} #用{}和逗号分隔的“键: 值”创建一个用国家名称作为键的字典，对应互联网国家代码值 In [2]: country_codes Out[2]: {\u0026#39;Finland\u0026#39;: \u0026#39;fi\u0026#39;, \u0026#39;South Africa\u0026#39;: \u0026#39;za\u0026#39;, \u0026#39;Nepal\u0026#39;: \u0026#39;np\u0026#39;} In [3]: len(country_codes) #内置函数len返回字典中键-值对的数量 Out[3]: 3 In [4]: if country_codes: #非空的字典等价于True，空字典等价于False ...: print(\u0026#39;country_codes is not empty\u0026#39;) ...: else: ...: print(\u0026#39;country_codes is empty\u0026#39;) country_codes is not empty In [5]: country_codes.clear() #清空字典 遍历字典 1 2 3 4 5 6 7 days_per_month = {\u0026#39;January\u0026#39;: 31, \u0026#39;February\u0026#39;: 28, \u0026#39;March\u0026#39;: 31} for month,days in days_per_month.items(): #items方法返回由键-值对构成的元组 print(f\u0026#39;{month} has {days} days\u0026#39;) ------ January has 31 days February has 28 days March has 31 days 基本的字典操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 In [1]: roman_numerals = {\u0026#39;I\u0026#39;: 1, \u0026#39;II\u0026#39;: 2, \u0026#39;III\u0026#39;: 3, \u0026#39;V\u0026#39;: 5, \u0026#39;X\u0026#39;: 100} In [2]: roman_numerals[\u0026#39;V\u0026#39;] #获取键\u0026#39;V\u0026#39;对应的值 Out[2]: 5 In [3]: roman_numerals[\u0026#39;X\u0026#39;] = 10 #更新与键\u0026#39;X\u0026#39;关联的值 In [4]: roman_numerals[\u0026#39;L\u0026#39;] = 50 #给不存在的键复制会在字典中插入新的键-值对 In [5]: del roman_numerals[\u0026#39;III\u0026#39;] #del语句从字典中删除键-值对 In [6]: roman_numerals.pop[\u0026#39;X\u0026#39;] #pop方法删除键-值对的同时返回已删除键的值 Out[6]: 10 In [7]: roman_numerals.get(\u0026#39;III\u0026#39;) #get方法通常返回其参数的对应值，如果找不到该键则返回None，可避免KeyError错误 In [8]: roman_numerals.get(\u0026#39;III\u0026#39;, \u0026#39;III not in dictionary\u0026#39;) #第二个参数是未找到键时返回的自定义消息 Out[8]: III not in dictionary In [9]: \u0026#39;V\u0026#39; in roman_numerals #运算符in和not in用于确定字典是否包含指定的键 Out[9]: True In [10]: \u0026#39;III\u0026#39; not in roman_numerals Out[10]: \u0026#39;True\u0026#39; 字典的keys和values方法 1 2 3 4 5 6 7 8 9 In [1]: months = {\u0026#39;January\u0026#39;: 1, \u0026#39;February\u0026#39;: 2, \u0026#39;March\u0026#39;: 3} In [2]: for month_name in months.keys(): #keys方法返回字典的键 ...: print(month_name, end = \u0026#39; \u0026#39;) January February March In [3]: for month_number in months.values(): #values方法返回字典的值 ...: print(month_name, end = \u0026#39; \u0026#39;) 1 2 3 字典的items、keys、values方法返回的是字典的数据视图而不是单纯复制出一个数据副本，因此储存其返回值的变量能反映字典当前的实际内容：\n1 2 3 4 5 6 7 8 In [4]: months_view = months.keys() In [5]: months[\u0026#39;December\u0026#39;] = 12 In [6]: for key in months_view: ...: print(key, end = \u0026#39; \u0026#39;) January February March December #即使没有对months_view重新赋值，其依旧储存了字典更新后的内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #以下内容将字典的键、值和键-值对转换为列表 In [7]: list(months.keys()) Out[7]: [\u0026#39;January\u0026#39;, \u0026#39;February\u0026#39;, \u0026#39;March\u0026#39;, \u0026#39;December\u0026#39;] In [7]: list(months.values()) Out[7]: [1, 2, 3, 12] In [7]: list(months.items()) Out[7]: [(\u0026#39;January\u0026#39;, 1), (\u0026#39;February\u0026#39;, 2), (\u0026#39;March\u0026#39;, 3), (\u0026#39;December\u0026#39;, 12)] #内置sorted函数可以按字母顺序遍历键 In [8]: for month_name in sorted(month.keys()) ...: print(month_name, end = \u0026#39; \u0026#39;) December February January March 字典的比较 比较运算符==和!=分别用于确定两个字典是否具有相同或不同的内容，当两个字典具有相同的键-值对（无论顺序）时，相等运算符返回True。\n1 2 3 4 5 6 7 8 9 10 11 In [1]: country_capitals1 = {\u0026#39;Belgium\u0026#39;: \u0026#39;Brussels\u0026#39;, \u0026#39;Haiti\u0026#39;: \u0026#39;Port-au-Prince\u0026#39;} In [2]: country_capitals2 = {\u0026#39;Nepal\u0026#39;: \u0026#39;Kathmandu\u0026#39;, \u0026#39;Uruguay\u0026#39;: \u0026#39;Montevideo\u0026#39;} In [3]: country_capitals3 = {\u0026#39;Haiti\u0026#39;: \u0026#39;Port-au-Prince\u0026#39;, \u0026#39;Belgium\u0026#39;: \u0026#39;Brussels\u0026#39;} In [4]: country_capitals1 == country_capitals3 Out[4]: True In [5]: country_caputals1 != country_capitals2 Out[5]: False 字典的update方法 1 2 3 4 5 6 7 In [1]: country_codes = {} In [2]: country_codes.update({\u0026#39;South Africa\u0026#39;: \u0026#39;za\u0026#39;}) #插入键-值对 In [3]: country_codes.update(Australia = \u0026#39;ar\u0026#39;) #自动将参数名称转换为字符串键并插入键-值对 In [4]: country_codes.update(Australia = \u0026#39;au\u0026#39;) #更新与\u0026#39;Austrailia\u0026#39;相关的值 字典推导式 字典推导式为快速生成字典提供了一种方便的表示方法，通常是将一个字典映射到另一个字典。\n1 2 3 4 5 6 7 8 9 In [1]: months = {\u0026#39;January\u0026#39;: 1, \u0026#39;February\u0026#39;: 2, \u0026#39;March\u0026#39;: 3} In [2]: months2 = {number: name for name, number in months.items()} # for左边的表达式指定了key: value形式的键-值对，右边遍历months.items()将每个键-值对解包到变量name和number中，得到一个从月份数映射到月份名的新字典 In [3]: grades = {\u0026#39;Sue\u0026#39;: [98, 87, 94], \u0026#39;Bob\u0026#39;: [84, 95, 91]} In [4]: grades2 = {k: sum(v) / len(v) for k, v in grades.items()} #推导式将grades.items()返回的每个元组解包为k（名称）和v（成绩列表），并用键k和sum(v)/len(v)的值创建一个新的键-值对，得到一个从学生姓名映射到平均成绩的新字典 集合 集合是元素值不重复的无序合集，只可以包含不可变的元素，比如字符串、整型、浮点数和元组。\n创建集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 In [1]: colors = {\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;} #创建一个颜色的字符串集合 In [2]: len(colors) #内置len函数确定一个集合中元素的数量 Out[2]: 5 In [3]: \u0026#39;red\u0026#39; in colors #使用in和not in操作符检查一个集合是否包含特定的值 Out[3]: True In [4]: \u0026#39;purple\u0026#39; not in colors Out[4]: True In [5]: for color in colors: #集合可迭代，可用for循环处理每个元素 ...: print(color.upper(), end = \u0026#39; \u0026#39;) RED GREEN YELLOW BLUE ORANGE #集合是无序的，迭代处理方法不能依赖元素访问顺序 In [6]: numbers = list(range(10)) + list(range(5)) #[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4] In [7]: set(numbers) #内置set函数根据一组元素值创建一个集合，集合会合并重复的元素 Out[7]: {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} In [8]: set() #创建空集合必须用set()函数，空花括号代表空字典 Out[8]: set() 集合是可变的，即可以添加或删除元素，但集合元素不可变，所以一个集合不能将其他集合作为元素，但frozenset是一个不可变的集合，即创建之后不能被修改，所以一个集合可以包含frozenset对象作为元素。\n集合的比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #==和!=运算符检验集合是否包含相同的值 In [1]: {1, 3, 5} == {3, 5, 1} Out[1]: True In [2]: {1, 3, 5} != {3, 5, 1} Out[2]: False #\u0026lt;运算符检验左边的集合是否是右边集合的真子集 In [3]: {1, 3, 5} \u0026lt; {3, 5, 1} Out[3]: False In [4]: {1, 3, 5} \u0026lt; {7, 3, 5, 1} Out[4]: True #\u0026lt;=运算符检验左边的集合是否是右边集合的非真子集 In [5]: {1, 3, 5} \u0026lt;= {3, 5, 1} Out[5]: True In [6]: {1, 3, 5} \u0026lt;= {7, 3, 5, 1} Out[6]: True #也可用集合的issubset方法检验非真子集 In [7]: {1, 3, 5}.issubset({3, 5, 1}) Out[7]: True #\u0026gt;和\u0026gt;=运算符分别检验左边的集合是否是右边集合的真超集和非真超集，也可理解为\u0026lt;和\u0026lt;=换了方向 #可用集合的issuperset方法检验非真超集 #issubset或issuperset能将任何可迭代参数转换为集合再操作 集合的数学运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #并集 In [1]: {1, 3, 5} | {2, 3, 4} Out[1]: {1, 2, 3, 4, 5} In [2]: {1, 3, 5}.union([20, 20, 3, 40, 40]) Out[2]: {1, 3, 5, 20, 40} #交集 In [3]: {1, 3, 5} \u0026amp; {2, 3, 4} Out[3]: {3} In [4]: {1, 3, 5}.intersection([1, 2, 2, 3, 3, 4, 4]) Out[4]: {1, 3} #差集 In [5]: {1, 3, 5} - {2, 3, 4} Out[5]: {1, 5} In [6]: {1, 3, 5, 7}.difference([2, 2, 3, 3, 4, 4]) Out[6]: {1, 5, 7} #对称差集（两个集合中互不相同的元素） In [7]: {1, 3, 5} ^ {2, 3, 4} Out[7]: {1, 2, 4, 5} In [8]: {1, 3, 5, 7}.symmetric_difference{[2, 2, 3, 3, 4, 4]} Out[8]: {1, 2, 4, 5, 7} #不相交集（检验两个集合有无公共元素） In [9]: {1, 3, 5}.isdisjoint({2, 4, 6}) Out[9]: True In [10]: {1, 3, 5}.isdisjoint({4, 6, 1}) Out[10]: False 集合的可变运算符和方法 集合也有增强赋值运算符，执行相应集合运算操作并重新赋值给左边的集合。\n名称 运算符 方法 并集增强赋值 |= update 交集增强赋值 \u0026amp;= intersection_update 差集增强赋值 -= difference_update 对称差集增强赋值 ^= symmetric_difference_update 用于添加和删除元素的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 In [1]: numbers = {1, 2, 3} In [2]: numbers.add(17) #add方法将参数插入进来 In [3]: numbers.add(3) #插入已有元素时集合不变 In [4]: numbers.remove(3) #remove方法将参数从集合中移除，但参数不在集合中会引发KeyError In [5]: numbers.discard(2) #discard方法也能移除，且参数不在集合中不会报错 In [6]: numbers.pop() #pop方法随机删除集合中一个元素且输出，若使用时集合为空会引发KeyError Out[6]: 1 In [7]: numbers.clear() #clear方法清空集合 集合推导式 与字典推导式一样，在花括号中定义集合推导式。\n1 2 3 4 In [1]: numbers = [1, 2, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 10] In [2]: evens = {item for item in numbers if item % 2 == 0} #{2, 4, 6, 8, 10} 面向数组的编程 NumPy库是实现Python数组的首选的库，它提供了一种高性能的、功能丰富的n维数组类型ndarray。\n创建数组 从现有数据创建数组 array函数接收一个数组或其他元素合集作为参数并返回一个由参数元素组成的新数组。\n1 2 3 4 5 6 7 8 9 10 In [1]: import numpy as np #将Numpy模块作为np导入 In [2]: numbers = np.array([2, 3, 5, 7, 11]) In [3]: numbers Out[3]: array([2, 3, 5, 7, 11]) In [4]: np.array([[1, 1, 4], [5, 1, 4]]) #多维参数创建多维数组 Out[4]: array([1, 1, 4], [5, 1, 4]) #NumPy自动格式化数组对齐每行的列 用特定值填充数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 In [1]: import numpy as np In [2]: np.zeros(5) #创建全是0.的数组，默认为元素类型float64 Out[2]: array([0., 0., 0., 0., 0.]) In [3]: np.ones((2, 4), dtype = int) #创建全是1的数组，用dtype参数指定元素类型为int64 Out[3]: array([[1, 1, 1, 1], [1, 1, 1, 1]]) In [4]: np.full((3, 5), 13) #创建以第二个参数为元素值和类型的数组 Out[4]: array([[13, 13, 13, 13, 13], [13, 13, 13, 13, 13], [13, 13, 13, 13, 13]]) 从范围创建数组 使用arange创建整数范围 arange函数使用类似内置函数range，前两个参数为范围，第三个参数为步长。\n1 2 3 4 5 6 7 8 9 10 In [1]: import numpy as np In [2]: np.arange(5) Out[2]: array([0, 1, 2, 3, 4]) In [3]: np.arange(5, 10) Out[3]: array([5, 6, 7, 8, 9]) In [4]: np.arange(10, 1, -2) Out[4]: array([10, 8, 6, 4, 2]) 使用linspace创建浮点范围 1 2 In [5]: np.linspace(0.0, 1.0, num = 5) #创建从0.0到1.0的5个等间距元素 Out[5]: array([0. , 0.25, 0.5 , 0.75, 1. ]) 显示大数组 在显示数组时如果有1000及以上个项，NumPy会省略中间的行和列，保留最前和最后的三行和三列。\n1 2 3 4 5 6 7 8 9 In [7]: np.arange(1, 100001).reshape(100, 1000) Out[7]: array([[ 1, 2, 3, ..., 998, 999, 1000], [ 1001, 1002, 1003, ..., 1998, 1999, 2000], [ 2001, 2002, 2003, ..., 2998, 2999, 3000], ..., [97001, 97002, 97003, ..., 97998, 97999, 98000], [98001, 98002, 98003, ..., 98998, 98999, 99000], [99001, 99002, 99003, ..., 99998, 99999, 100000]]) 数组属性 本节以以下数组为例：\n1 2 3 4 5 6 7 8 In [1]: import numpy as np In [2]: integers = np.array([[1, 2, 3], [4, 5, 6]]) In [3]: floats = np.array([0.0, 0.1, 0.2, 0.3, 0.4]) In [4]: floats Out[4]: array([0., 0.1, 0.2, 0.3, 0.4]) #NumPy在浮点值中不显示小数点右侧尾随的0 元素类型 1 2 3 4 5 In [5]: integers.dtype #属性dtype包含数组的元素类型 Out[5]: dtype(\u0026#39;int64\u0026#39;) #64位整型 In [6]: floats.dtype Out[6]: dtype(\u0026#39;float64\u0026#39;) #64位浮点型 NumPy支持的完整的类型列表间见https://docs.scipy.org/doc/numpy/user/basics.types.html\n维数 1 2 3 4 5 6 7 8 9 10 11 In [7]: integers.ndim #属性ndim包含数组的维数 Out[7]: 2 In [8]: floats.ndim Out[8]: 1 In [9]: integers.shape #属性shape包含数组每个维度上元素的个数的元组 Out[9]: (2, 3) #2行3列 In [10]: floats.shape Out[10]: (5,) #5个 元素数和元素大小 1 2 3 4 5 6 7 8 9 10 11 In [11]: integers.size #属性size包含一个数组的元素总数 Out[11]: 6 In [12]: integers.itemsize #属性itemsize包含存储每个元素所需的字节数 Out[12]: 8 In [13]: floats.size Out[13]: 5 In [14]: floats.itemsize Out[14]: 8 遍历多维数组 1 2 3 4 5 6 7 8 9 10 In [15]: for row in integers: #以多维方式迭代数组 ...: for column in row: ...:\tprint(column, end = \u0026#39; \u0026#39;) ...:\tprint() 1 2 3 4 5 6 In [16]: for i in integers.flat: #用flat属性按一维形式迭代数组 ...: print(i, end = \u0026#39; \u0026#39;) 1 2 3 4 5 6 数组运算符 数组和单个数值的算术运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #单个数值的算术运算对数组中每个元素都生效 In [1]: import numpy as np In [2]: numbers = np.arange(1, 6) In [3]: numbers * 2 Out[3]: array([2, 4, 6, 8, 10]) In [4]: numbers ** 3 Out[4]: array([1, 8, 27, 64, 125]) #增强赋值修改左操作数的每个元素 In [5]: numbers += 10 In [6]: numbers Out[6]: array([11, 12, 13, 14, 15]) 数组间的算术运算 1 2 3 4 5 #相同形状的数组间执行算术运算或增强赋值，两个数组相同位置的元素各自运算得到新数组的元素 In [7]: numbers2 = np.linspace(1.1, 5.5, 5) In [8]: numbers * numbers2 Out[8]: array([12.1, 26.4, 42.9, 61.6, 82.5]) 比较数组 1 2 3 4 5 In [9]: numbers \u0026gt;= 13 #数组的每个元素分别与单个值作比较，返回一个布尔值数组 Out[9]: array([False, False, True, True, True]) In [10]: numbers2 \u0026lt; numbers #两个数组相同位置的元素之间作比较 Out[10]: array([True, True, True, True, True]) NumPy计算方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 In [1]: import numpy as np In [2]: grades = np.array([[87, 96, 70], [100, 87, 90], [94, 77, 90], [100, 81, 82]]) In [3]: grades.sum() #sum方法计算数组所有元素的和 Out[3]: 1054 In [4]: grades.min() #min方法计算数组所有元素的最小值 Out[4]: 70 In [5]: grades.max() #max方法计算数组所有元素的最大值 Out[5]: 100 In [6]: grades.mean() #mean方法计算数组所有元素的平均值 Out[6]: 87.83333333333333 In [7]: grades.std() #std方法计算数组所有元素的标准偏差 Out[7]: 8.792357792739987 In [8]: grades.var() #var方法计算数组所有元素的方差 Out[8]: 77.30555555555556 #axis关键字参数指定在计算中使用哪个维度 In [9]: grades.mean(axis = 0) #对每个列的所有行值进行计算 Out[9]: array([95.25, 85.25, 83. ]) In [10]: grades.mean(axis = 1) #对每个行的所有列值进行计算 Out[10]: array([84.33333333, 92.33333333, 87. , 87.66666667]) NumPy数组的更多计算方法详见https://docs.scipy.org/doc/numpy/reference/arrays.ndarray.html\n通用函数 NumPy提供许多通用函数承担算术运算符的作用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 In [1]: import numpy as np In [2]: numbers = np.array([1, 4, 9, 16, 25, 36]) In [3]: np.sqrt(numbers) #sqrt函数对数组每个元素开方 Out[3]: array([1., 2., 3., 4., 5.]) In [4]: numbers2 = np.arange(1, 7) * 10 In [5]: np.add(numbers, numbers2) #add函数等价于+运算符 Out[5]: array([11, 24, 39, 56, 75, 96]) In [6]: np.multiply(numbers2, 5) #multiply函数等价于*运算符 Out[6]: array([ 50, 100, 150, 200, 250, 300]) 其他通用函数\n分类 举例 数学函数 add, subtract, multiply, divide, remainder, exp, log, sqrt, power 三角函数 sin, cos, tan, hypot, arcsin, arccos, arctan 位运算函数 bitwise_and, bitwise_or, bitwise_xor, invert, left_shift, right_shift 比较函数 greater, greater_equal, less, less_equal, equal, not_equal, logical_and, logical_or, logical_xor, logical_not, minimum, maximum 浮点运算函数 floor, ceil, isinf, isnan, fabs, trunc 完整列表详见https://docs.scipy.org/doc/numpy/reference/ufuncs.html\n索引和切片 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #二维数组索引 In [1]: import numpy as np In [2]: grades = np.array([[87, 96, 70], [100, 87, 90], [94, 77, 90], [100, 81, 82]]) In [3]: grades[0, 1] #第0行第1列 Out[3]: 96 #选择二维数组的行子集 In [4]: grades[1] #选择第1行 Out[4]: array([100, 87, 90]) In [5]: grades[0:2] #选择多个连续的行用切片表示 Out[5]: array([[ 87, 96, 70], [100, 87, 90]]) In [6]: grades[[1, 3]] #选择多个非连续行用行索引列表 Out[6]: array([[100, 87, 90], [100, 81, 82]]) #选择二维数组的列子集与行子集参数语法相同，逗号前选择该列中的哪些行，可以是特定的行号、一个表示行子集的切片或一个特定行索引的列表，本例“:”表示所有行的切片 In [7]: grades[:, 1:3] Out[7]: array([[96, 70], [87, 90], [77, 90], [81, 82]]) 视图与浅拷贝 在字典的keys和values方法中我们引入了视图对象，即能“看到”其他对象中的数据的对象，而不是拥有自己的数据副本。\n视图是浅拷贝，视图与原始数据的改变是同步的。\n各种数组方法和切片操作均生成数组数据的视图。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 In [1]: import numpy as np In [2]: numbers = np.arange(1, 6) In [3]: numbers2 = numbers.view() #view方法返回包含原始数组对象数据的视图的新数组 In [4]: numbers[1] *= 10 In [5]: numbers2 Out[5]: array([ 1, 20, 3, 4, 5]) #改变原始数组中的值会改变视图中的值 In [6]: numbers2[1] /= 10 In [7]: numbers Out[7]: array([1, 2, 3, 4, 5]) #改变视图中的值也会改变原始数组中的值 切片视图 1 2 3 4 5 6 In [8]: numbers2 = numbers[0:3] #切片操作返回相应切片的视图 In [9]: numbers[1] *= 20 In [10]: numbers2 Out[10]: [ 1, 40, 3] 深拷贝 有时为了保持数据的独立性，需要使用原始数据的深拷贝，原始数据和拷贝数据之间不会相互影响。\n1 In [11]: numbers3 = numbers.copy() #copy方法返回原始数组对象数据的深拷贝 重塑和转置 reshape和resize（一维到多维） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 In [1]: import numpy as np In [2]: grades = np.array([[87, 96, 70], [100, 87, 90]]) #reshape方法产生一个具有新维度的原始数组的视图 In [3]: grades.reshape(1, 6) #将一维数组转换为1行6列的二维数组 Out[3]: array([ 87, 96, 70, 100, 87, 90]) #视图和原始数组共享数据，但是保持各自的形状 In [4]: grades Out[4]: array([[ 87, 96, 70], [100, 87, 90]]) #原始数组形状不改变 #resize方法改变原始数组的形状 In [5]: grades.resize(1, 6) In [6]: grades Out[6]: array([ 87, 96, 70, 100, 87, 90]) flatten和ravel（多维到一维） 1 2 3 4 5 6 7 8 9 10 In [7]: grades = np.array([[87, 96, 70], [100, 87, 90]]) #flatten方法创建原始数组数据的深拷贝 In [8]: flattened = grades.flatten() In [9]: flattend Out[9]: array([ 87, 96, 70, 100, 87, 90]) #ravel方法产生一个原始数据的视图 In [10]: raveled = grades.ravel() 转置行和列 1 2 3 4 5 In [11]: grades.T #T属性返回一个转置的数组视图 Out[11]: array([[100, 100], [ 96, 87], [ 70, 90]]) 水平堆叠和垂直堆叠 可以按行或列组合数组，称为水平堆叠和垂直堆叠。\n1 2 3 4 5 6 7 8 9 10 11 12 13 In [12]: grades2 = np.array([[94, 77, 90], [100, 81, 82]]) In [13]: np.hstack((grades, grades2)) #hstack函数将元组中的数组水平堆叠起来 Out[13]: array([[100, 96, 70, 94, 77, 90], [100, 87, 90, 100, 81, 82]]) In [14]: np.vstack((grades, grades2)) #vstack函数将元组中的数组垂直堆叠起来 Out[14]: array([[100, 96, 70], [100, 87, 90], [ 94, 77, 90], [100, 81, 82]]) 字符串 格式化字符串 在变量、输入输出与运算符一章我们引入了格式化字符串，在本章将深入探讨。\n表示类型 当为f字符串中的值指定占位符时，除非指定另一种类型，否则Python假定该值应该显示为字符串。\n1 2 3 4 5 6 7 8 9 10 11 In [1]: f\u0026#39;{10:d}\u0026#39; #d表示类型将整数值格式化为字符串 Out[1]: \u0026#39;10\u0026#39; In [2]: f\u0026#39;{65:c}{97:c}\u0026#39; #c表示类型将整数字符代码格式化为对应的字符 Out[2]: \u0026#39;A a\u0026#39; In [3]: f\u0026#39;{\u0026#34;hello\u0026#34;:s}\u0026#39; #s是默认的字符串表示类型，其格式化的值必须是引用字符串的变量或生成字符串的表达式 Out[3]: \u0026#39;hello\u0026#39; In [4]: f\u0026#39;{17.489:.2f}\u0026#39; #f表示类型将浮点数格式化为字符串，“.2”表示四舍五入保留两位小数 Out[4]: \u0026#39;17.49\u0026#39; 字段宽度和对齐方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #表示类型前用字段宽度设置指定宽度字符串中文本出现的位置，本例设置输出宽度为10的字符串，默认右对齐 In [1]: f\u0026#39;{27:10d}\u0026#39; Out[1]: \u0026#39; 27\u0026#39; In [2]: f\u0026#39;{3.5:10f}\u0026#39; Out[2]: \u0026#39; 3.5\u0026#39; In [3]: f\u0026#39;{\u0026#34;hello\u0026#34;:10}\u0026#39; Out[3]: \u0026#39; hello\u0026#39; #可以使用\u0026lt;和\u0026gt;指定左对齐和右对齐，用^将值居中 In [4]: f\u0026#39;{27:\u0026lt;15d}\u0026#39; Out[4]: \u0026#39;27 \u0026#39; In [5]: f\u0026#39;{\u0026#34;hello\u0026#34;:\u0026gt;15}\u0026#39; Out[5]: \u0026#39; hello\u0026#39; In [6]: f\u0026#39;{3.5:^7.1f}\u0026#39; Out[6]: \u0026#39; 3.5 \u0026#39; #如果剩余奇数个字符位置，Python会将多余的空间放在右侧 数字格式化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 In [1]: f\u0026#39;{27:+10d}\u0026#39; #强制显示正数符号 Out[1]: \u0026#39; +27\u0026#39; In [2]: f\u0026#39;{27:+010d}\u0026#39; #字符宽度前的0指定用0而不是默认的空格填充其余字符 Out[2]: \u0026#39;+000000027\u0026#39; In [3]: f\u0026#39;{27:d}\\n{27: d}\\n{-27: d}\u0026#39; #在符号位值用空格替代+以对齐正负数 27 27 -27 In [4]: f\u0026#39;{\u0026#39;12345678\u0026#39;:,d}\u0026#39; #逗号将数字与千位分隔符格式化 Out[4]: \u0026#39;12,345,678\u0026#39; In [5]: f\u0026#39;{\u0026#39;123456.78\u0026#39;:,.2f}\u0026#39; Out[5]: \u0026#39;123,456.78\u0026#39; 拼接和重复字符串 1 2 3 4 5 In [1]: \u0026#39;birth\u0026#39; + \u0026#39;day\u0026#39; #+运算符拼接字符串 Out[1]: \u0026#39;birthday\u0026#39; In [2]: \u0026#39;\u0026gt;\u0026#39; * 5 #*运算符重复字符串 Out[2]: \u0026#39;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#39; 去除字符串中的空白字符 1 2 3 4 5 6 7 8 9 10 In [1]: sentence = \u0026#39;\\t \\n This is a test string. \\t\\t \\n\u0026#39; In [2]: sentence.strip() #strip方法删去一个字符串开头和结尾的空白字符 Out[2]: \u0026#39;This is a text string\u0026#39; In [3]: sentence.lstrip() #lstrip方法只删去开头的空白字符 Out[3]: \u0026#39;This is a test string. \\t\\t \\n\u0026#39; In [4]: sentence.rstrip() #rstrip方法只删去结尾的空白字符 Out[4]: \u0026#39;\\t \\n This is a test string.\u0026#39; 字符大小写转换 1 2 3 4 5 In [1]: \u0026#39;happy birthday\u0026#39;.capitalize() #capitalize方法返回只有首字母大写的新字符串 Out[1]: \u0026#39;Happy birthday\u0026#39; In [2]: \u0026#39;strings: a deeper look\u0026#39;.title() #title方法返回仅大写每个单词的首字母的新字符串 Out[2]: \u0026#39;Strings: A Deeper Look\u0026#39; 字符串的比较运算符 字符串基于字符的ASCII码值比较，字母从小到大的顺序为A-Z、a-z，可使用ord函数查看字符对应的整数。\n按照字典顺序比较字符串，如\u0026rsquo;App\u0026rsquo; \u0026lt; \u0026lsquo;app\u0026rsquo; \u0026lt; \u0026lsquo;apple\u0026rsquo; \u0026lt; \u0026lsquo;bAnana\u0026rsquo; \u0026lt; \u0026lsquo;baNana\u0026rsquo;。\n查找字符串 计算子字符串出现次数 1 2 3 4 5 6 7 8 9 10 In [1]: sentence = \u0026#39;to be or not to be that is the question\u0026#39; In [2]: sentence.count(\u0026#39;to\u0026#39;) #count方法计算子字符串在整个字符串中的出现次数 Out[2]: 2 In [3]: sentence.count(\u0026#39;to\u0026#39;, 12) #第二个参数start_index指定count方法搜索字符串切片[start_index:] Out[3]: 1 In [4]: sentence.count(\u0026#39;to\u0026#39;, 12, 13) #第三个参数end_index指定字符串切片[start_index:end_index] Out[4]: 0 本节其他字符串方法都有start_index和end_index参数指定搜索原始字符串的切片。\n定位子字符串 1 2 3 4 5 6 In [5]: sentence.index(\u0026#39;be\u0026#39;) #index方法搜索子字符串并返回其所在的第一个索引，找不到则引起ValueError Out[5]: 3 In [6]: sentence.rindex(\u0026#39;be\u0026#39;) #rindex方法从末尾搜索子字符串并返回其所在的最后一个索引，找不到则引起ValueError Out[6]: 16 #find和rfind作用与index和rindex相同，但找不到会返回-1而不是引起ValueError 确定是否包含子字符串 1 2 3 4 5 In [7]: \u0026#39;that\u0026#39; in sentence #in和not in运算符确定字符串是否包含指定的子字符串 Out[7]: True In [8]: \u0026#39;That\u0026#39; not in sentence Out[8]: True 在开头或结尾定位子字符串 1 2 3 4 5 In [9]: sentence.startwith(\u0026#39;to\u0026#39;) #startwith方法判断字符串是否以指定的子字符串开始 Out[9]: True In [10]: sentence.endwith(\u0026#39;quest\u0026#39;) #endwith方法判断字符串是否以指定的字符串结束 Out[10]: False 替换子字符串 1 2 3 4 In [1]: values = \u0026#39;1\\t2\\t3\\t4\\t5\u0026#39; In [2]: values.replace(\u0026#39;\\t\u0026#39;, \u0026#39;,\u0026#39;) #replace方法搜索第一个参数的字符串并用第二个参数的字符串替换，第三个参数可指定最大替换次数 Out[2]: \u0026#39;1,2,3,4,5\u0026#39; 字符串拆分和连接 拆分字符串 1 2 3 4 5 6 7 8 9 10 In [1]: letters = \u0026#39;A, B, C, D\u0026#39; #split方法将第一个参数作为定界符把字符串分成子字符串进行标记后返回标记列表，界定符默认为空白字符 In [2]: letters.split(\u0026#39;, \u0026#39;) Out[2]: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;] #第二个参数指定最大拆分数，最后一个标记是经最多次拆分后字符串的其余部分 In [3]: letters.split(\u0026#39;, \u0026#39;, 2) Out[3]: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C, D\u0026#39;] #rsplit方法任务与split相同，但是会从末尾逆向处理给定最多次数的标记拆分 连接字符串 1 2 3 4 In [4]: letters_list = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;] In [5]: \u0026#39;,\u0026#39;.join(letters_list) #join方法以调用该方法的字符串为分隔符将参数中的字符串拼接起来 Out[5]: \u0026#39;A,B,C,D\u0026#39; partition和rpartition方法 1 2 3 4 #partition方法根据分隔符参数将一个字符串拆分为有三个字符串的 元组，分别是分隔符之前的字符串部分、分隔符本身和分隔符之后的字符串部分 In [7]: \u0026#39;Amanda: 89, 97, 92\u0026#39;.partition(\u0026#39;: \u0026#39;) Out[7]: (\u0026#39;Amanda\u0026#39;, \u0026#39;: \u0026#39;, \u0026#39;89, 97, 92\u0026#39;) #rpartition方法从字符串末尾搜索分隔符 splitlines方法 1 2 3 4 5 6 7 8 #splitlines方法将多行文本字符串按行拆分为一个列表 In [1]: lines = \u0026#34;\u0026#34;\u0026#34;This is line1 ...: This is line2 ...: This is line3\u0026#34;\u0026#34;\u0026#34; In [2]: lines.splitlines() Out[2]: [\u0026#39;This is line1\u0026#39;, \u0026#39;This is line2\u0026#39;, \u0026#39;This is line3\u0026#39;] #括号内如果给True参数会保留每个字符串末尾的换行符，默认为False 字符串测试方法 1 2 3 4 5 In [1]: \u0026#39;-27\u0026#39;.isdigit() #isdigit方法检测字符串是否只包含数字字符0~9 Out[1]: False In [2]: \u0026#39;A9876\u0026#39;.isalnum() #isalnum方法检测字符串是否只包含数字和字母 Out[2]: True 字符串测试方法 描述 isalnum() 仅包含数字和字母 isalpha() 仅包含字母 isdecimal() 仅包含十进制整数且不包含正负号 isdigit() 仅包含数字 isidentifier() 表示有效标识符 islower() 字母均为小写 isnumeric() 表示不带正负号和小数点的数值 isspace() 仅包含空白字符 istitle() 每个单词只有首字母大写 isupper() 字母均为大写 原始字符串 字符串的反斜杠字符会引入转义序列，要在字符串中包含反斜杠必须使用两个反斜杠字符\\\\，使得一些字符串难以阅读。\n字符r开头的原始字符串将每个反斜杠视为普通的字符而不是转义序列的开头。\n1 2 3 4 5 In [1]: file_path = r\u0026#39;C:\\MyFolder\\MySubFolder\\MyFile.txt\u0026#39; In [2]: file_path Out[2]: \u0026#39;C:\\\\MyFolder\\\\MySubFolder\\\\MyFile.txt\u0026#39; #Python仍以常规字符串的形式将反斜杠字符表示为两个反斜杠 正则表达式 正则表达式用于描述匹配其他字符串中字符的搜索模式。\n正则表达式的作用：\n验证文本数据 从文本中提取数据 数据清理 将数据转换为其他格式 re模块与fullmatch函数 1 In [1]: import re #使用正则表达式需要导入re模块 fullmatch是最简单的正则表达式函数之一，用于检查第二个参数传入的字符串是否与第一个参数传入的模式匹配。\n1 2 3 4 5 6 7 8 #匹配完全相同的字符串 In [2]: pattern = \u0026#39;02215\u0026#39; In [3]: \u0026#39;Match\u0026#39; if re.fullmatch(pattern, \u0026#39;02215\u0026#39;) else \u0026#39;No match\u0026#39; Out[3]: \u0026#39;Match\u0026#39; In [4]: \u0026#39;Match\u0026#39; if re.fullmatch(pattern, \u0026#39;51220\u0026#39;) else \u0026#39;No match\u0026#39; Out[4]: \u0026#39;Match\u0026#39; 元字符、字符类和量词 正则表达式通常包含称为元字符的特殊符号：[ ] { } ( ) \\ * + ^ $ ? . |\n元字符\\作为预定义字符类的开始，每个字符类都能匹配一组特定的字符。\n1 2 3 4 5 6 7 #验证一个有五位数字的美国邮政编码 In [5]: \u0026#39;Valid\u0026#39; if re.fullmatch(r\u0026#39;\\d{5}\u0026#39;, \u0026#39;02215\u0026#39;) else \u0026#39;Invalid\u0026#39; #元字符中反斜杠用原始字符串 Out[5]: \u0026#39;Valid\u0026#39; In [5]: \u0026#39;Valid\u0026#39; if re.fullmatch(r\u0026#39;\\d{5}\u0026#39;, \u0026#39;9876\u0026#39;) else \u0026#39;Invalid\u0026#39; Out[5]: \u0026#39;Invalid\u0026#39; #正则表达式\\d{5}中，\\d是表示一位数字0~9的字符类，字符类后加上一个量词{5}表示重复\\d五次 字符类 匹配字符 \\d 任意数字0~9 \\D 任意非数字字符 \\s 任意空白字符（空格、制表符、换行符） \\S 任意非空白字符 \\w 任意单词字符（也称为字母数字字符），包括任何大小写字母、数字或下划线 \\W 任意非单词字符 自定义字符集 使用方括号[ ]来定义与单个字符匹配的自定义字符类，例如[aeiou]匹配小写元音字母，[A-Z]匹配大写字母，[a-z]匹配小写字母，[a-zA-Z]匹配任何大小写字母。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #验证一个单词以大写字母开头跟随任意数量的小写字母 In [6]: \u0026#39;Valid\u0026#39; if re.fullmatch(\u0026#39;[A-Z][a-z]*\u0026#39;, \u0026#39;Wally\u0026#39;) else \u0026#39;Invalid\u0026#39; Out[6]: \u0026#39;Valid\u0026#39; In [7]: \u0026#39;Valid\u0026#39; if re.fullmatch(\u0026#39;[A-Z][a-z]*\u0026#39;, \u0026#39;eva\u0026#39;) else \u0026#39;Invalid\u0026#39; Out[7]: \u0026#39;Invalid\u0026#39; #量词*匹配其左侧子表达式任意次，包括零次 #如果希望至少匹配一次则用量词+ #量词*和+都会匹配到下一个字符不匹配为止 #验证一个字符不是小写字母 In [8]: \u0026#39;Valid\u0026#39; if re.fullmatch(\u0026#39;^[a-z]\u0026#39;, \u0026#39;A\u0026#39;) else \u0026#39;Invalid\u0026#39; #^开头的自定义字符类将匹配指定范围以外的任何字符 Out[8]: \u0026#39;Valid\u0026#39; #自定义字符类中的元字符被视为文字字符 In [9]: \u0026#39;Valid\u0026#39; if re.fullmatch(\u0026#39;[*+$]\u0026#39;, \u0026#39;+\u0026#39;) else \u0026#39;Invalid\u0026#39; Out[9]: \u0026#39;Valid\u0026#39; 其他量词 1 2 3 4 5 6 7 8 9 10 11 12 #?量词匹配子表达式零次或一次 #匹配label过去分词的拼写，本例?子表达式为字符\u0026#39;l\u0026#39;，匹配labeled和labelled，但不匹配labellled In [10]: \u0026#39;Match\u0026#39; if re.fullmatch(\u0026#39;labll?ed\u0026#39;, \u0026#39;labeled\u0026#39;) else \u0026#39;No match\u0026#39; Out[10]: \u0026#39;Match\u0026#39; #{n, m}量词匹配子表达式n到m次，省略参数m则至少匹配n次 #匹配包含3~6位数字的字符串 In [11]: \u0026#39;Match\u0026#39; if re.fullmatch(\u0026#39;\\d{3, 6}\u0026#39;, \u0026#39;123\u0026#39;) else \u0026#39;No match\u0026#39; Out[11]: \u0026#39;Match\u0026#39; In [12]: \u0026#39;Match\u0026#39; if re.fullmatch(\u0026#39;\\d{3, 6}\u0026#39;, \u0026#39;1234567\u0026#39;) else \u0026#39;No match\u0026#39; Out[12]: \u0026#39;No match\u0026#39; 替换子字符串和拆分字符串 sub函数 sub函数在字符串中使用指定的替换文本替换模式匹配的文本。\nsub函数接收三个必需参数：要匹配的模式、替换文本、要搜索的字符串，可用第四个关键字参数count指定最多替换次数。\n1 2 3 4 In [1]: import re In [2]: re.sub(r\u0026#39;\\t\u0026#39;, \u0026#39;, \u0026#39;, \u0026#39;1\\t2\\t3\\t4\u0026#39;, count = 2) #用\u0026#39;, \u0026#39;替换\u0026#39;1\\t2\\t3\\t4\u0026#39;中的制表符\u0026#39;\\t\u0026#39;两次 Out[2]: \u0026#39;1, 2, 3\\t4\u0026#39; split函数 split函数用正则表达式指定定界符来标记字符串并返回字符串列表。\n1 2 3 #定界符为逗号跟随任意数量空白字符，关键字参数maxsplit指定最多拆分数 In [3]: re.split(r\u0026#39;,\\s*\u0026#39;, \u0026#39;1, 2, 3,4, 5,6,7,8\u0026#39;, maxsplit = 3) Out[3]: [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4, 5,6,7,8\u0026#39;] 其他搜索功能、访问匹配 函数search和match search函数在字符串中查找与正则表达式匹配的第一个字符串并返回包含子字符串的匹配对象（类型为SRE_Match），无法匹配则返回None。匹配对象的group方法会返回该子字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 In [1]: import re In [2]: result = re.search(\u0026#39;fun\u0026#39;, \u0026#39;Python is fun\u0026#39;) In [3]: result.group() if result else \u0026#39;not found\u0026#39; Out[3]: \u0026#39;fun\u0026#39; #match函数只在起始位置匹配字符串，而search函数在整个字符串中匹配 #可选flags关键字参数在匹配中忽略大小写 In [5]: result3 = re.search(\u0026#39;Sam\u0026#39;, \u0026#39;SAM WHITE\u0026#39;, flags = re.IGNORECASE) In [6]: result3.group() if result else \u0026#39;not found\u0026#39; Out[6]: \u0026#39;SAM\u0026#39; #正则表达式开头^元字符表示该表达式仅匹配字符串开头 #正则表达式末尾$元字符表示该表达式仅匹配字符串末尾 In [7]: result = re.search(\u0026#39;^Python\u0026#39;, \u0026#39;Python is fun\u0026#39;) In [8]: result.group() if result else \u0026#39;not found\u0026#39; Out[8]: \u0026#39;Python\u0026#39; In [7]: result = re.search(\u0026#39;Python$\u0026#39;, \u0026#39;Python is fun\u0026#39;) In [8]: result.group() if result else \u0026#39;not found\u0026#39; Out[8]: \u0026#39;Not found\u0026#39; 函数findall和finditer 函数findall查找字符串中所有的匹配子字符串并返回匹配子字符串的列表。\n1 2 3 4 5 #提取所有美国电话号码 In [9]: contact = \u0026#39;Wally White, Home: 555-555-1234, Work: 555-555-4321\u0026#39; In [10]: re.findall(r\u0026#39;\\d{3}-\\d{3}-\\d{4}\u0026#39;, contact) Out[10]: [\u0026#39;555-555-1234\u0026#39;, \u0026#39;555-555-4321\u0026#39;] 函数finditer功能与findall类似，但返回一个匹配对象的惰性迭代，一次只返回一个匹配项，可以节省内存。\n1 2 3 4 In [11]: for phone in re.finditer(r\u0026#39;\\d{3}-\\d{3}-\\d{4}\u0026#39;, contact) ...: print(phone.group()) 555-555-1234 555-555-4321 捕获匹配中的子字符串 使用括号元字符捕获匹配项中的子字符串。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #抓取字符串文本中的姓名和电子邮件地址 In [12]: text = \u0026#39;Charlie Cyan, e-mail: demo1@deitel.com\u0026#39; In [13]: pattern = r\u0026#39;([A-Z][a-z]+ [A-Z][a-z]+), e-mail: (\\w+@\\w+\\.\\w{3})\u0026#39; In [14]: result = re.research(pattern, text) In [15]: result.groups() #匹配对象的groups方法返回抓取到的子字符串的元组 Out[15]: (\u0026#39;Charlie Cyan\u0026#39;, \u0026#39;demo1@deitel.com\u0026#39;) In [16]: result.group() #匹配对象的group方法以单个字符串形式返回整个匹配结果 Out[16]: \u0026#39;Charlie Cyan, e-mail: demo1@deitel.com\u0026#39; In [17]: result.group(2) #向group方法传递一个整数来访问每个抓取到的子字符串，抓取到的子字符串从1开始编号 Out[17]: \u0026#39;demo1@deitel.com\u0026#39; 文件和异常 文件 Python将文本文件视作一个字符序列，将二进制文件（图像、视频等）视作一个字节序列。\n文本文件的第一个字符和二进制文件的第一个字节编号为0。\n文本文件处理 写入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 In [1]: with open(\u0026#39;accounts.txt\u0026#39;, mode = \u0026#39;w\u0026#39;) as accounts: ...: accounts.write(\u0026#39;100 Jones 24.98\\n\u0026#39;) #也可使用print(\u0026#39;100 Jones 24.98\u0026#39;, file = accounts) ...: accounts.write(\u0026#39;200 Doe 345.67\\n\u0026#39;) ...: accounts.write(\u0026#39;300 White 0.00\\n\u0026#39;) ...: accounts.write(\u0026#39;400 Stone -42.16\\n\u0026#39;) ...: accounts.write(\u0026#39;500 Rich 224.62\\n\u0026#39;) ------ #文件内容 100 Jones 24.98 200 Doe 345.67 300 White 0.00 400 Stone -42.16 500 Rich 224.62 with语句获取一个资源（accounts.txt）并将对应的对象赋给一个变量（accounts）。执行到with语句序列结尾自动调用资源对象的close方法释放资源\nopen函数打开文件（accounts.txt）并将该文件与一个文件对象相关联。mode参数指定文件打开方式，本例使用\u0026rsquo;w\u0026rsquo;方式打开文件以进行写文件操作，文件不存在则自动创建，未指定文件路径则在当前文件夹创建，文件已存在则自动清空内容。\n文件对象的write方法向文件写入字符串。\n读取数据 1 2 3 4 5 6 7 8 9 10 11 In [2]: with open(\u0026#39;accounts.txt\u0026#39;, mode = \u0026#39;r\u0026#39;) as accounts: #文件打开方式\u0026#39;r\u0026#39;以只读方式打开 ...: print(f\u0026#39;{\u0026#34;Account\u0026#34;:\u0026lt;10}{\u0026#34;Name\u0026#34;:\u0026lt;10}{\u0026#34;Balance\u0026#34;:\u0026gt;10}\u0026#39;) ...: for record in accounts: #每次读取文件中的一行数据并以字符串形式返回 ...: account, name, balance = record.split() #字符串的split方法分离各字段数据并以列表形式返回 ...: print(f\u0026#39;{account:\u0026lt;10}{name:\u0026lt;10}{balance:\u0026gt;10}\u0026#39;) Account Name Balance 100 Jones 24.98 200 Doe 345.67 300 White 0.00 400 Stone -42.96 500 Rich 224.62 readlines方法一次性读取整个文本文件并返回字符串列表，每个字符串对应一行数据，适用于小规模文件的数据读取。\n读取文件时系统会维护一个文件位置指针指向要读取的下一个字符的位置。如果想在每次处理前将文件位置指针重新定位到文件开始位置，一种方式是关闭并重新打开文件，另一种更高效的方式是调用文件对象的seek方法：$\\mathit{file\\_object}\\texttt{.seek(0)}$\n文本文件的打开模式\n模式 描述 \u0026lsquo;r\u0026rsquo; 打开文本文件进行读操作，为默认打开模式 \u0026lsquo;w\u0026rsquo; 打开文本文件进行写操作，若文件已存在则内容会被自动清空 \u0026lsquo;a\u0026rsquo; 打开文本文件进行追加操作，若文件不存在则创建该文件，新数据会被写到文件已有数据的后面 \u0026lsquo;r+\u0026rsquo; 打开文本文件进行读/写操作 \u0026lsquo;w+\u0026rsquo; 打开文本文件进行读/写操作，若文件已存在则内容会被自动清空 \u0026lsquo;a+\u0026rsquo; 打开文本文件进行读/追加操作，若文件不存在则创建该文件，新数据会被写到文件已有数据的后面 文件对象的常用方法\n方法 描述 read 返回一个字符串，包含字符/字节数量由整数参数指定，没有传入参数则返回文件全部内容 write 向文件写入一个字符串 readline 以字符串形式返回一行文本，若有换行符则返回字符串末尾包含换行符，若已到达文件结束位置则返回空字符串 writelines 接收一个字符串列表并将每个字符串按行写入文件中 更新文本文件 由于格式化的输入输出方式中记录字段数据的长度可能有所不同，在修改一个文本文件的格式化数据时可能会破坏其他数据。例如将accounts.txt中的名字White修改为Williams，如果简单地用新名字覆盖原来的名字，原记录为：\n$\\texttt{300 White 0.00}$\n新记录为：\n$\\texttt{300 Williams00}$\n为了使修改操作正常进行，需按以下步骤：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 In [1]: accounts = open(\u0026#39;accounts.txt\u0026#39;, \u0026#39;r\u0026#39;) #以只读方式打开原始文件 In [2]: temp_file = open(\u0026#39;temp_file.txt\u0026#39;, \u0026#39;w\u0026#39;) #以只写方式创建临时文件 In [3]: with accounts, temp_file: ...: for record in accounts: ...: account, name, balance = record.split() #读取并解包原始文件所有数据 ...: if account != \u0026#39;300\u0026#39;: #筛选非目标数据行 ...: temp_file.write(record) #照抄进临时文件 ...: else: #筛选目标数据行 ...: new_record = \u0026#39; \u0026#39;.join([account, \u0026#39;Williams\u0026#39;, balance]) #将名字替换后重组写入临时文件 ...: temp_file.writ(new_record + \u0026#39;\\n\u0026#39;) In [4]: import os #导入os模块以使用文件处理函数 In [5]: os.remove(\u0026#39;accounts.txt\u0026#39;) #删除原始文件 In [6]: os.rename(\u0026#39;temp_file.txt\u0026#39;, \u0026#39;accounts.txt\u0026#39;) #以原始文件名命名临时文件 使用JSON进行序列化 JSON数据格式 JSON对象类似于Python中的字典，每一个JSON对象对应一个用花括号括起来的由逗号分隔的属性名-属性值列表。但JSON键只能是双引号字符串，且有序、可重复。\nJSON数组类似于Python中的列表，是用方括号括起来的由逗号分隔的值。\nJSON对象和数组中的值可以是：\n双引号字符串 数值 JSON布尔值（true和false） null 数组 其他JSON对象 将对象序列化为JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 14 In [1]: import json #导入json模块 In [2]: accounts_dict = {\u0026#39;accounts\u0026#39;: [ ...: {\u0026#39;account\u0026#39;: 100, \u0026#39;name\u0026#39;: \u0026#39;Jones\u0026#39;, \u0026#39;balance\u0026#39;: 24.98}, ...: {\u0026#39;account\u0026#39;: 200, \u0026#39;name\u0026#39;: \u0026#39;Doe\u0026#39;, \u0026#39;balance\u0026#39;: 345.67}]} #字典accounts_dict包含1个键-值对，键为accounts，值为表示两个账户信息的字典列表，每个账户的字典包含3个键-值对 In [3]: with open(\u0026#39;accounts.json\u0026#39;, \u0026#39;w\u0026#39;) as accounts: ...: json.dump(accounts_dict, accounts) ------ #accounts.json文件内容（经格式化处理）： {\u0026#34;accounts\u0026#34;: [{\u0026#34;account\u0026#34;: 100, \u0026#34;name\u0026#34;: \u0026#34;Jones\u0026#34;, \u0026#34;balance\u0026#34;: 24.98}, {\u0026#34;account\u0026#34;: 200, \u0026#34;name\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;balance\u0026#34;: 345.67}]} 反序列化JSON文本 json模块的load函数可以读取其文件对象参数所对应的全部JSON文本并转换为一个Python对象，即反序列化数据。\n1 2 3 4 5 6 In [4]: with open(\u0026#39;accounts.json\u0026#39;, \u0026#39;r\u0026#39;) as accounts: ...: accounts_json = json.load(accounts) In [5]: accounts_json Out[5]: {\u0026#39;accounts\u0026#39;: [{\u0026#39;account\u0026#39;: 100, \u0026#39;name\u0026#39;: \u0026#39;Jones\u0026#39;, \u0026#39;balance\u0026#39;: 24.98}, {\u0026#39;account\u0026#39;: 200, \u0026#39;name\u0026#39;: \u0026#39;Doe\u0026#39;, \u0026#39;balance\u0026#39;: 345.67}]} 显示JSON文本 json模块的dumps函数将一个JSON对象以Python字符串形式返回。\ndumps函数指定indent关键字参数，返回的字符串会包含换行符和良好的缩进。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 In [6]: with open(\u0026#39;accounts.json\u0026#39;, \u0026#39;r\u0026#39;) as accounts: ...: print(json.dumps(json.load(accounts), indent = 4)) { \u0026#34;accounts\u0026#34;: [ { \u0026#34;account\u0026#34;: 100, \u0026#34;name\u0026#34;: \u0026#34;Jones\u0026#34;, \u0026#34;balance\u0026#34;: 24.98 }, { \u0026#34;account\u0026#34;: 200, \u0026#34;name\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;balance\u0026#34;: 345.67 } ] } 处理异常 被零除和无效输入 试图被零除会导致ZeroDivisionError异常。\n函数收到不满足要求的参数会导致ValueError异常\ntry语句 Python使用try语句进行异常处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #除法运算程序 while True: #try子句跟随一组可能引发异常的语句 try: number1 = int(input(\u0026#39;Enter numerator: \u0026#39;)) #输入被除数 number2 = int(input(\u0026#39;Enter denominator: \u0026#39;)) #输入除数 result = number1 / number2 #计算结果 #except子句指定处理的异常类型 except ValueError: #对ValueError的处理（输入了非数字的值） print(\u0026#39;You must enter two integers\\n\u0026#39;) except ZeroDivisionError: #对ZeroDivisionError的处理（除数输入了0） print(\u0026#39;Attempted to divide by zero\\n\u0026#39;) #当except子句成功处理异常后程序会执行finally子句（如果有），然后再执行try语句后的代码（本例进入下一次循环） #可选else子句在没有任何异常的情况下执行 else: print(f\u0026#39;{number1:.3f} / {number2:.3f} = {result:.3f}\u0026#39;) break ------ #运行结果 Enter numerator: 100 Enter denominator: 0 Attempted to divide by zero Enter numerator: 100 Enter denominator: hello You must enter two integers Enter numerator: 100 Enter denominator: 7 100.000 / 7.000 = 14.286 当一些异常类型具有相同处理代码时，以元组形式指定：\n$\\texttt{except (}type1\\texttt{, }type2\\texttt{, ...) as }variable\\_name\\texttt{:}$\n在所有except子句和else子句（如果有）之后写一个finally子句，则finally子句必然在最后被执行到（除非程序提前终止）。\n显式地引发一个异常 有时候我们可能需要写一个函数通过引发异常以通知调用者发生的错误，raise语句可以显式地引发一个异常，其最简单的形式是：\n$\\texttt{raise }ExceptionClassName$\n本章完\n","date":"2024-11-20T00:00:00Z","permalink":"https://INKEM.github.io/p/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%80%9F%E8%A7%88%E4%B8%8B/","title":"【Python】基础语法速览（下）"},{"content":"程序实验2~4.蜂鸣器-静态数码管-动态数码管 蜂鸣器实验 蜂鸣器介绍 蜂鸣器是一种一体化结构的电子讯响器，采用直流电压供电，广泛应用于电子产品中作为发声器件。\n蜂鸣器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型。\n与LED相比，由于51单片机的I/O口的驱动电流不足，蜂鸣器无法直接使用其来驱动，而是通过放大电路实现驱动。\n我们通过周期性地改变电流的大小和方向，使振动膜片产生稳定的振动，进而使蜂鸣器发声，因此蜂鸣器的控制需要脉冲信号而不是单一信号，且脉冲信号频率一般要求在1.5-5KHz。\n实验2 蜂鸣器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026#34;reg52.h\u0026#34; typedef unsigned char u8; typedef unsigned int u16; sbit BEEP = P2^5; //定义蜂鸣器控制管脚为BEEP，博主使用的单片机对应管脚为P2.5 void delay_10us(u16 time) //延时函数延用实验1程序 { while(time --); } void main() { u16 i = 2000; //控制蜂鸣器发声时间的变量 while(1) { while(i--) { BEEP = !BEEP; //使蜂鸣器控制管脚输出在高电平和低电平之间切换 delay_10us(100); //控制输出信号脉冲周期2*100*10微秒 } i = 0; BEEP = 0; } } 蜂鸣器的音高取决于脉冲信号的周期（频率），周期越短（频率越高）音高越高。\n蜂鸣器的音量取决于脉冲信号中高电平的占空比（即高电平输出时间在一个周期的占比），占空比越大音量越大。\n以下是一个便于控制蜂鸣器的音量的内部循环。\n1 2 3 4 5 6 7 while(i--) { BEEP = 0; delay_10us(150); //低电平输出时间占75% BEEP = 1; delay_10us(50); //高电平输出时间占25%，相较于上一个程序蜂鸣器音量更小 } 静态数码管实验 数码管介绍 数码管简介 共阳数码管是指将所有发光二极管的阳极接到一起形成公共阳极（COM）的数码管，共阳数码管在应用时应将公共极COM接到+5V，控制阴极低电平为亮，高电平为暗。\n共阴数码管是指将所有发光二极管的阴极接到一起形成公共阴极（COM）的数码管，共阴数码管在应用时应将公共极COM接到地线GND，控制阳极高电平为亮，低电平为暗。\n同时，数码管也根据显示数字位数的不同分类，博主使用的单片机数码管为两块四位共阴数码管。\n数码管显示编码介绍 数码管上的每个笔画与发光二极管为相同字母一一对应的关系，发光二极管a到DP对应P0.0到P0.7八位。\n对数字进行编码时，先确定显示的笔画和与之对应的发光二极管，比如数字0显示的笔画为abcdef；再根据数码管是共阴还是共阳确定每一位的电平写成二进制数，以共阴为例，数字0的二进制编码为00111111，共阳取反即可；最后到程序中转化为十六进制表示，数字0的十六进制编码即为0x3f。\n数码管静态显示原理 数码管的控制分为段选和位选：段选即选择发光二极管a到DP这些段，上文0x3f也被称为段码值；位选通过三八译码器利用三个管脚的输入控制八个共阴（阳）数码管的阴（阳）极，即用三位二进制来选择显示八个数位中的哪一个。\n静态显示的特点是每个数码管的段选必须接一个八位数据线来保持显示的字形码，即每个数码管都需要八个I/O口，当送入一次字形码后，显示字形可一直保持到送入新字形码为止。优点是CPU占用少，显示亮度亮；缺点是硬件电路复杂，成本较高。\n博主使用的单片机数码管为动态数码管，但由于下拉电阻作用，控制位选的管脚P22到P24默认输出高电平，对应数码管0到7中的第7位，因此可以在不进行位选时将该数码管当做静态数码管使用，关于位选将在动态数码管中进一步讲到。\n实验3 静态数码管 实现功能：控制静态数码管显示数字0，即让P0端口输出数字0的段码0x3f（共阴）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026#34;reg52.h\u0026#34; typedef unsigned char u8; typedef unsigned int u16; #define SEG_A_DP_PORT P0 //宏定义P0端口，SEG为数码管LED Segment Displays简写，A_DP为A到DP段，PORT为端口 u8 gseg_code[16] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71}; //用一个数组存储十六进制0到F的段码值，便于调用 void main() { SEG_A_DP_PORT = gseg_code[0]; //P0端口输出0的段码值 } 效果图\n由于是动态数码管，其显示会在0和8.之间频闪，但视觉上0更明显。\n动态数码管实验 数码管介绍 数码管动态显示原理 动态显示是利用减少段选线，分开位选线，利用位选线不同时刻选择通断，改变段选数据来实现的。\n动态数码管通过高频闪烁利用人眼的视觉暂留效应造成静态显示的效果。\n74HC245芯片介绍 段选电路部分和74HC245芯片\n74HC245芯片是一种三态输出八路双向收发器，主要应用于一些大屏显示和其他消费类电子产品中作为驱动芯片使用。\n在51单片机中，数码管无法直接由管脚驱动，需要使用该驱动芯片。\n74HC138芯片介绍 位选电路部分和74HC138芯片\n74HC138芯片是一种三通道输入八通道输出译码器，也称为三八译码器，主要应用于消费类电子产品。\n上图为将芯片输入与输出对应起来的真值表，本实验中只涉及红框内部分，可知该芯片将三位二进制输入转化为0到7的值并选择对应序号的管脚输出。\n实验4 动态数码管 实现功能：控制八位动态数码管从左到右显示01234567。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026#34;reg52.h\u0026#34; typedef unsigned char u8; typedef unsigned int u16; #define SEG_A_DP_PORT P0 sbit LSA = P2^2; sbit LSB = P2^3; sbit LSC = P2^4; //定义位选管脚 u8 gseg_code[16] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x6f, 0x77, 0x7c, 0x39, 0x5e, 0x79, 0x71}; void delay_10us(u16 time) //延时函数 { while(time --); } void seg_display(void) //动态数码管显示函数 { u8 i = 0; //循环控制变量 for(i = 0;i \u0026lt; 8;i++) //八位数码管依次显示 { switch(i) //将i转化为三个位选管脚的二进制输出 { case 0: LSC = 1;LSB = 1;LSA = 1;break; case 1: LSC = 1;LSB = 1;LSA = 0;break; case 2: LSC = 1;LSB = 0;LSA = 1;break; case 3: LSC = 1;LSB = 0;LSA = 0;break; case 4: LSC = 0;LSB = 1;LSA = 1;break; case 5: LSC = 0;LSB = 1;LSA = 0;break; case 6: LSC = 0;LSB = 0;LSA = 1;break; case 7: LSC = 0;LSB = 0;LSA = 0;break; //本程序为阴极数码管，阳极需要取反 } SEG_A_DP_PORT = gseg_code[i]; //显示对应的数字 delay_10us(100); SEG_A_DP_PORT = 0x00; //消影 } } void main() { while(1) { seg_display(); } } 因为数码管数位和要显示的数字的排列顺序不一样，从左到右是7到0位，但要输出0到7，有两种方法：\n一种是该程序，在switch函数中注意i与位选输出信号的对应关系，0到7分别对应二进制的7到0；\n另一种是不调换i与位选输出信号的对应关系，将i的循环迭代顺序反过来，同时调整第i位显示的数字为7-i。\n下面是第二种方法的动态数码管显示函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void seg_display(void) { u8 i = 0; for(i = 7;i \u0026gt;= 0;i--) { switch(i) { case 0: LSC = 0;LSB = 0;LSA = 0;break; case 1: LSC = 0;LSB = 0;LSA = 1;break; case 2: LSC = 0;LSB = 1;LSA = 0;break; case 3: LSC = 0;LSB = 1;LSA = 1;break; case 4: LSC = 1;LSB = 0;LSA = 0;break; case 5: LSC = 1;LSB = 0;LSA = 1;break; case 6: LSC = 1;LSB = 1;LSA = 0;break; case 7: LSC = 1;LSB = 1;LSA = 1;break; } SEG_A_DP_PORT = gseg_code[7-i]; delay_10us(100); SEG_A_DP_PORT = 0x00; } } 在程序中还有一个消影的操作。如果没有该操作，会发现后一个数字有前一个数字微弱的重影。这是因为动态数码管所有数位的段选线路是并在一起的，数码管在切换位选到切换段选的程序执行期间有一个极小的间隔，在切换位选后下一个数位会短暂地继承上一个数位的段码，因此在切换位选前将当前数位的显示擦除，擦除的空隙很短所以不会被人眼察觉到，而这也是动态数码管显示亮度低于静态数码管的原因。\n效果图\n本篇完\n","date":"2024-11-19T00:00:00Z","permalink":"https://INKEM.github.io/p/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%AE%9E%E9%AA%8C2~4.%E8%9C%82%E9%B8%A3%E5%99%A8-%E9%9D%99%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1-%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1/","title":"【51单片机】程序实验2~4.蜂鸣器-静态数码管-动态数码管"},{"content":"雅可比：速度和静力 时变位置和姿态的符号表示 速度矢量 速度矢量是位置矢量的导数\n$^BV_Q=\\frac{\\mathrm{d}}{\\mathrm{d}t}^BP_Q=\\lim_{\\Delta t\\rightarrow0}\\frac{^BP_Q(t+\\Delta t)-^BP_Q(t)}{\\Delta t}$\n像其他矢量一样，速度矢量能在任意坐标系中描述，其参考坐标系用左上标注明，如果将$^BV_Q$在$\\{A\\}$下表示，可以写为：\n$^A(^BV_Q)=^A(\\frac{\\mathrm{d}}{\\mathrm{d}t}^BP_Q)=^A_BR^BV_Q$\n我们经常讨论一个坐标系原点相对于某个世界参考坐标系的速度，而不考虑相对于任意坐标系中一般的点的速度，对此定义一个缩写符号：\n$\\upsilon_C=^UV_{CORG}$\n式中的点为$\\{C\\}$的原点，参考坐标系为$\\{U\\}$\n角速度矢量 角速度矢量$^A\\Omega_B$描述了$\\{B\\}$相对于$\\{A\\}$的旋转，$^A\\Omega_B$的方向为$\\{B\\}$相对于$\\{A\\}$的瞬时旋转轴，大小表示旋转速率，即$^A\\Omega_B=\\dot{\\theta}\\hat{K}$\n像其他矢量一样，角速度矢量能在任意坐标系中描述，其参考坐标系用左上标注明，$^C(^A\\Omega_B)$就是$\\{B\\}$相对于$\\{A\\}$的角速度在$\\{C\\}$中的描述\n对于参考坐标系已知的简单情况，我们也定义一个缩写符号：\n$\\omega_C=^U\\Omega_C$\n刚体的线速度和角速度 线速度 把$\\{B\\}$固连在一刚体上，要求描述$^BQ$相对于固定坐标系$\\{A\\}$的运动\n根据绝对速度等于相对速度加牵连速度，我们得到：\n$^AV_Q=^AV_{BORG}+^A(^BV_Q)=^AV_{BORG}+^A_BR^BV_Q$\n上式只适用于$\\{A\\}$和$\\{B\\}$姿态保持不变的情况\n角速度 现在讨论$\\{B\\}$相对于$\\{A\\}$以$^A\\Omega_B$旋转，且原点始终保持重合、相对线速度为零的情况\n先假设$^BV_Q=0$，根据线速度矢量等于角速度矢量叉乘位置矢量，有：\n$^AV_Q=^A\\Omega_B\\times^AQ$\n再考虑$^BV_Q\\neq0$，加上此速度分量，得：\n$^AV_Q=^A(^BV_Q)+^A\\Omega_B\\times^AQ=^A_BR^BV_Q+^A\\Omega_B\\times^A_BR^BQ$\n联立线速度和角速度 将上式扩展到$\\{B\\}$原点运动的情况，将牵连速度加上得：\n$^AV_Q=^AV_{BORG}+^A_BR^BV_Q+^A\\Omega_B\\times^A_BR^BQ$\n这就是相对于$\\{A\\}$的$\\{B\\}$中的固定矢量的速度普遍公式\n机器人连杆的运动 在考虑机器人连杆运动时，一般以$\\{0\\}$为参考坐标系，因此连杆坐标系$\\{i\\}$的线速度为$v_i$，角速度为$\\omega_i$\n我们先研究一对相邻连杆的线速度与角速度在各自坐标系的表达之间的关系（注意与相对速度的概念区分开来，此处是绝对速度矢量在不同坐标系下的描述），即$^iv_i$、$^i\\omega_i$与$^{i+1}v_{i+1}$、$^{i+1}\\omega_{i+1}$之间的关系\n当两个角速度矢量都是相对于相同的坐标系时，那么这些角速度能够相加，所以连杆$i+1$的角速度等于连杆$i$的角速度加上一个由于关节$i+1$的角速度引起的分量\n$^i\\omega_{i+1}=^i\\omega_i+^i_{i+1}R\\dot{\\theta}_{i+1}\\hat{Z}_{i+1}$\n其中$\\dot{\\theta}_{i+1}\\hat{Z}_{i+1}=^{i+1}\\begin{bmatrix}0\\\\0\\\\\\hat{\\theta}_{i+1}\\end{bmatrix}$，旋转矩阵将其转换为在$\\{i\\}$下的表达\n上式两边同乘$^{i+1}_{i}R$，可以得到连杆$i+1$的角速度相对于$\\{i+1\\}$的表达式：\n$^{i+1}\\omega_{i+1}=^{i+1}_iR^i\\omega_i+\\dot{\\theta}_{i+1}\\hat{Z}_{i+1}$①\n$\\{i+1\\}$原点的线速度等于$\\{i\\}$原点的线速度加上一个由于连杆$i+1$的角速度引起的新的分量：\n$^iv_{i+1}=^iv_i+^i\\omega_i\\times^iP_{i+1}$\n上式两边同乘$^{i+1}_{i}R$，得：\n$^{i+1}v_{i+1}=^{i+1}_{i}R(^iv_i+^i\\omega_i\\times^iP_{i+1})$②\n式①②是关节$i+1$为旋转关节的情况，对于移动关节，相应的关系为：\n$^{i+1}\\omega_{i+1}=^{i+1}_iR^i\\omega_i$\n$^{i+1}v_{i+1}=^{i+1}_iR(^iv_i+^i\\omega_i\\times^iP_{i+1})+\\dot{d}_{i+1}{}^{i+1}\\hat{Z}_{i+1}$\n从一个连杆到下一个连杆依次应用这些公式，可以计算出最后一个连杆在自身坐标系$\\{N\\}$中表达的角速度$^N\\omega_N$和线速度$^Nv_N$，用$^0_NR$去左乘这些速度即可向基坐标进行旋转变换\n雅可比 雅可比矩阵是多维形式的导数，例如，假设有6个函数，每个函数都有6个独立的变量：\n$y_1=f_1(x_1,x_2,x_3,x_4,x_5,x_6)$\n$y_2=f_1(x_1,x_2,x_3,x_4,x_5,x_6)$\n$\\vdots$\n$y_6=f_1(x_1,x_2,x_3,x_4,x_5,x_6)$\n用矢量简记为：\n$Y=F(X)$\n现在如果想要计算出$y_i$的微分关于$x_j$的微分的函数，可应用多元函数求导法则计算得到：\n$\\delta y_1=\\frac{\\partial f_1}{\\partial x_1}\\delta x_1+\\frac{\\partial f_1}{\\partial x_2}\\delta x_2+\\cdots+\\frac{\\partial f_1}{\\partial x_6}\\delta x_6$\n$\\delta y_2=\\frac{\\partial f_1}{\\partial x_1}\\delta x_1+\\frac{\\partial f_1}{\\partial x_2}\\delta x_2+\\cdots+\\frac{\\partial f_1}{\\partial x_6}\\delta x_6$\n$\\vdots$\n$\\delta y_6=\\frac{\\partial f_1}{\\partial x_1}\\delta x_1+\\frac{\\partial f_1}{\\partial x_2}\\delta x_2+\\cdots+\\frac{\\partial f_1}{\\partial x_6}\\delta x_6$\n用矢量简记为：\n$\\delta Y=\\frac{\\partial F}{\\partial X}\\delta X$\n上式中的$6\\times6$的偏微分矩阵为我们所说的雅可比矩阵\n如果$f_i(X)$都是非线性函数，那么这些偏微分都是$x_j$的函数，因此可采用如下表示：\n$\\delta Y=J(X)\\delta X$\n将上式两端同时除以时间的微分，可以将雅可比矩阵看成$X$中的速度向$Y$中速度的映射：\n$\\dot{Y}=J(X)\\dot{X}$\n在机器人学中，操作臂末端的位姿与一系列关节角也是上式中$Y$与$X$的关系，求导后我们可以使用雅可比将关节速度与操作臂末端的笛卡尔速度联系起来，得到：\n$^0\\boldsymbol{v}=^0J(\\Theta)\\dot{\\Theta}$\n式中$\\Theta$是操作臂关节角矢量，$\\boldsymbol{v}$是笛卡尔速度矢量，左上标表示笛卡尔速度所参考的坐标系，当参考坐标系很明显而不用说明时可以省去\n对于通常的六关节机器人，雅可比矩阵是$6\\times6$维的，$\\dot{\\Theta}$是$6\\times1$维的，$^0\\boldsymbol{v}$也是$6\\times1$维的，由一个$3\\times1$的线速度矢量和$3\\times1$的角速度矢量排列起来的：\n$^0\\boldsymbol{v}=\\begin{bmatrix}^0\\boldsymbol{\\upsilon}\\\\^0\\boldsymbol{\\omega}\\end{bmatrix}$\n可以定义任何维数的雅可比矩阵，雅可比矩阵的行数等于操作臂在笛卡尔空间中的自由度数量，列数等于操作臂的关节数量\n雅可比矩阵参考坐标系的变换 已知$\\{B\\}$中的雅可比矩阵：\n$\\begin{bmatrix}^B\\boldsymbol{\\upsilon}\\\\^B\\boldsymbol{\\omega}\\end{bmatrix}=^B\\boldsymbol{v}=^BJ(\\Theta)\\dot{\\Theta}$\n对于如何给出雅可比矩阵在$\\{A\\}$中的表达式，首先注意到$\\{B\\}$中的笛卡尔速度矢量可通过如下变换得到相对于$\\{A\\}$的表达式：\n$\\begin{bmatrix}^A\\boldsymbol{\\upsilon}\\\\^A\\boldsymbol{\\omega}\\end{bmatrix}=\\begin{bmatrix}^A_BR\u00260\\\\0\u0026^A_BR\\end{bmatrix}\\begin{bmatrix}^B\\boldsymbol{\\upsilon}\\\\^B\\boldsymbol{\\omega}\\end{bmatrix}$\n因此可以得到：\n$\\begin{bmatrix}^A\\boldsymbol{\\upsilon}\\\\^A\\boldsymbol{\\omega}\\end{bmatrix}=\\begin{bmatrix}^A_BR\u00260\\\\0\u0026^A_BR\\end{bmatrix}{}^BJ(\\Theta)\\dot{\\Theta}$\n于是雅可比矩阵参考坐标系的变换为：\n$^AJ(\\Theta)=\\begin{bmatrix}^A_BR\u00260\\\\0\u0026^A_BR\\end{bmatrix}{}^BJ(\\Theta)$\n奇异性 如果雅可比矩阵可逆（也就是非奇异的），那么已知笛卡尔速度就可以对该矩阵求逆计算出关节的速度：\n$\\dot{\\Theta}=J^{-1}(\\Theta)\\boldsymbol{v}$\n但是雅可比矩阵不是对于所有的$\\Theta$值都可逆，大多数操作臂都有使得雅可比矩阵奇异的$\\Theta$值，这些位置就称为机构的奇异位形或简称奇异性\n奇异位形的分类有一些深入研究，但目前我们先将它们大致分为两类：\n$1)$工作空间边界的奇异位形出现在操作臂完全展开或者收回使得末端执行器处于非常接近工作空间边界的情况\n$2)$工作空间内部的奇异位形总是远离工作空间的边界，通常是由于两个或两个以上的关节轴线共线引起的\n当操作臂处于奇异位形时会失去一个或多个自由度，即在笛卡尔空间的某个方向上无论选择什么样的关节速度都不能使机器人手臂运动\n操作臂的静力 操作臂的链式结构特性让我们想到力和力矩是如何从一个连杆向下一个连杆传递的，考虑操作臂的自由末端在工作空间推动某个物体或用手部抓举某个负载的典型情况，我们希望求出保持系统静态平衡的关节力矩\n对于操作臂的静力，首先锁定所有关节使得操作臂成为一个结构，再进行理论力学的静力分析方法\n我们为相邻杆件所施加的力和力矩定义以下特殊的符号：\n$f_i=$连杆$i-1$施加在连杆$i$上的力\n$n_i=$连杆$i-1$施加在连杆$i$上的力矩\n对于单个连杆的静力-力矩平衡，有：\n$\\Sigma f=^if_i-^if_{i+1}=0$\n$\\Sigma n=^in_i-^in_{i+1}-^iP_{i+1}\\times^if_{i+1}=0$\n这样我们就可以从施加于机器人末端执行器的力和力矩的描述开始可以计算出作用于每一个连杆的力和力矩，对上式进行整理以便从高序号连杆向低序号连杆进行迭代求解得到：\n$^if_i=^if_{i+1}$\n$^in_i=^in_{i+1}+^iP_{i+1}\\times^if_{i+1}$\n再按照定义在连杆自身坐标系中的力和力矩写出这些表达式得：\n$^if_i=^i_{i+1}R^{i+1}f_{i+1}$\n$^in_i=^i_{i+1}R^{i+1}n_{i+1}+^iP_{i+1}\\times^if_{i+1}$\n对于一个关节，除了绕关节轴的力矩靠关节驱动提供之外，力和力矩矢量的其他分量都可以由操作臂机构本身来平衡，因此保持系统静平衡的关节力矩等于关节轴矢量与施加在连杆上的力矩矢量的点乘：\n$\\tau_i=^in_i^T{}^i\\hat{Z}_i$\n对于关节$i$是移动关节的情况，可以算出关节驱动力为：\n$\\tau_i=^if_i^T{}^i\\hat{Z}_i$\n力域中的雅可比 当力作用在机构上时，如果机构经过一个位移，就做了功，令位移趋向于无穷小就可以用虚功原理描述静止的情况\n功是具有能量的单位，所以在任何广义坐标系下的测量值都相同，即笛卡尔空间做的功（力与位移）等于关节空间做的功（力矩与角位移）。在多维空间中，功是一个力或力矩矢量与位移矢量的点积，由此我们得到：\n$\\mathcal{F}\\cdot\\delta\\chi=\\tau\\cdot\\delta\\Theta$\n式中$\\mathcal{F}$是作用在末端执行器上的$6\\times1$维笛卡尔力-力矩矢量，$\\delta\\chi$是末端执行器的$6\\times1$维无穷小笛卡尔位移矢量，$\\tau$是$6\\times1$维关节力矩矢量，$\\delta\\Theta$是$6\\times1$维无穷小关节位移矢量\n上式也可写成：\n$\\mathcal{F}^T\\delta\\chi=\\tau^T\\delta\\Theta$\n雅可比矩阵的定义为：\n$\\delta\\chi=J\\delta\\Theta$\n因此可写出：\n$\\mathcal{F}^TJ\\delta\\Theta=\\tau^T\\delta\\Theta$\n$\\mathcal{F}^TJ=\\tau^T$\n对两边转置得：\n$\\tau=J^T\\mathcal{F}$\n由此雅可比矩阵的转置将作用在手臂上的笛卡尔力映射成了等效关节力矩\n当雅可比矩阵奇异时，存在某些特定的方向，末端执行器在这些方向上不能施加期望的静态力，意味着在力域中和位置域中奇异都是存在的\n速度和静力的笛卡尔变换 根据前文的讨论我们有：\n$\\boldsymbol{v}=\\begin{bmatrix}\\upsilon\\\\\\omega\\end{bmatrix}$\n$\\mathcal{F}=\\begin{bmatrix}F\\\\N\\end{bmatrix}$\n我们现在给出将这些量从一个坐标系映射到另一个坐标系的变换矩阵\n在机器人连杆的运动一节已经得到下面的变换公式：\n$^{i+1}\\omega_{i+1}=^{i+1}_iR^i\\omega_i+\\dot{\\theta}_{i+1}\\hat{Z}_{i+1}$\n$^{i+1}v_{i+1}=^{i+1}_{i}R(^iv_i+^i\\omega_i\\times^iP_{i+1})$\n将$\\{i\\}$换成$\\{A\\}$，$\\{i+1\\}$换成$\\{B\\}$，以及在刚性坐标系下令$\\dot{\\theta}=0$，再写为矩阵的形式得到：\n$\\begin{bmatrix}^B\\upsilon_B\\\\^B\\omega_B\\end{bmatrix}=\\begin{bmatrix}^B_AR\u0026-^B_AR^AP_{BORG}\\times\\\\0\u0026^B_AR\\end{bmatrix}\\begin{bmatrix}^A\\upsilon_A\\\\^A\\omega_A\\end{bmatrix}$\n原式中$P$乘在右边，为了转换为左乘的形式表达在矩阵中，我们将其写成反对称矩阵：\n$P\\times=\\begin{bmatrix}0\u0026-p_z\u0026p_y\\\\p_z\u00260\u0026-p_x\\\\-p_y\u0026p_x\u00260\\end{bmatrix}$\n由此新得到的变换矩阵被称为速度变换矩阵，用符号$T_\\upsilon$表示，它是一个把$\\{A\\}$中的速度映射到$\\{B\\}$中的速度的速度变换，简记为：\n$^B\\boldsymbol{v}_B=^B_AT_\\upsilon^A\\boldsymbol{v}_A$\n将这个变换过程反过来对$^B_AT_\\upsilon$求逆即可：\n$^A_BT_\\upsilon=^B_AT_\\upsilon^{-1}=\\begin{bmatrix}^A_BR\u0026^AP_{BORG}\\times^A_BR\\\\0\u0026^A_BR\\end{bmatrix}$\n同样的，对操作臂的力学一节中得到的公式：\n$^if_i=^i_{i+1}R^{i+1}f_{i+1}$\n$^in_i=^i_{i+1}R^{i+1}n_{i+1}+^iP_{i+1}\\times^if_{i+1}$\n我们推出力矢量由$\\{A\\}$到$\\{B\\}$的映射关系为：\n$\\begin{bmatrix}^AF_A\\\\^AN_A\\end{bmatrix}=\\begin{bmatrix}^A_BR\u00260\\\\^AP_{BORG}\u0026^A_BR\\end{bmatrix}\\begin{bmatrix}^BF_B\\\\^BN_B\\end{bmatrix}$\n简记为：\n$^A\\mathcal{F}_A=^A_BT_f^B\\mathcal{F}_B$\n式中$T_f$表示力-力矩变换矩阵\n本章完\n","date":"2024-11-18T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep5.%E9%9B%85%E5%8F%AF%E6%AF%94%E9%80%9F%E5%BA%A6%E5%92%8C%E9%9D%99%E5%8A%9B/","title":"【机器人学导论】Ep5.雅可比：速度和静力"},{"content":"Python基础语法速览（上） 变量、输入输出与运算符 变量和赋值语句 1 In [1]: x = 7 #创建变量x并为x赋值为7 变量名是一个标识符，由字母、数字和下划线组成，但不能以数字开头，区分大小写\n1 2 In [2]: type(x) #查看x的数据类型 Out[2]: int 运算符 算术运算符 Python运算 算术运算符 加法 + 减法 - 乘法 * 幂 ** 除法（结果为浮点数） / 整除 // 取余 % 运算符优先级规则\n1.从最内层计算括号中的表达式\n2.幂运算，多个幂运算按照从右到左的顺序计算\n3.乘法、除法、整除和模，多个乘法、除法、整除和模按照从左到右的顺序计算\n4.加法、减法，多个加法、减法按照从左到右的顺序计算\n比较运算符 条件是一个值为True或False的布尔表达式\n比较运算符 含义 \u0026gt; 大于 \u0026lt; 小于 \u0026gt;= 大于等于 \u0026lt;= 小于等于 == 等于 != 不等于 1 2 3 4 5 6 7 8 9 10 In [1]: 114 \u0026gt; 514 Out[1]: False In [2]: 114 \u0026lt; 514 Out[2]: True In [3]: x = 191 In [4]: 114 \u0026lt;= x \u0026lt;= 514 #链式比较检测一个值是否在某个范围内 Out[4]: True 对其他表达式，非零值为True，零为False，非空字符串为True，空字符串为False\n布尔运算符 条件运算符可用于组成简单条件，要将简单条件进行组合构成更复杂的条件可以使用布尔运算符and、or和not将两个表达式连接起来\n布尔运算符and\n表达式1 表达式2 表达式1 and 表达式2 False False False False True False True False False True True True 布尔运算符or\n表达式1 表达式2 表达式1 and 表达式2 False False False False True True True False True True True True 布尔运算符not\n表达式 not 表达式 False True True False 运算符优先级和结合性汇总\n运算符 结合性 () 从左到右 ** 从右到左 * / // % 从左到右 + = 从左到右 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 从左到右 == != 从左到右 not 从左到右 and 从左到右 or 从左到右 增强赋值 当相同的变量名同时出现在赋值运算符的左右两端，可以使用增强赋值对赋值表达式进行缩写\n增强赋值表达式 解释 a += 2 a = a + 2 a -= 2 a = a - 2 a *= 2 a = a * 2 a **= 2 a = a ** 2 a /= 2 a = a / 2 a //= 2 a = a // 2 a %= 2 a = a % 2 print函数、单双引号、转义字符 1 2 In [1]: print(\u0026#39;Welcome to Python!\u0026#39;) #将括号中的参数显示为一行文本 Welcome to Python! 除了单引号，双引号也可以括起一个字符串，但一般习惯用单引号\n1 2 In [2]: print(\u0026#39;Welcome\u0026#39;, \u0026#39;to\u0026#39;, \u0026#39;Python!\u0026#39;) #逗号分隔参数，输出自动加空格 Welcome to Python! 反斜杠（\\）称为转义字符，反斜杠和紧随其后的字符形成一个转义序列，例如转义序列“\\n”表示换行符\n1 2 3 4 5 In [3]: print(\u0026#39;Welcome\\nto\\n\\nPython!\u0026#39;) Welcome to Python! 转义序列 说明 \\n 换行符 \\t 制表符 \\\\ 插入反斜杠 \\\u0026quot; 插入双引号 \\' 插入单引号 在一行的结尾用续行符“\\”将一个长字符串写成多行\n1 2 3 In [4]: print(\u0026#39;this is a longer string, so we\\ ...: split it over two lines\u0026#39;) this is a longer string, so we split it over two lines 可以在print语句中执行计算\n1 2 In [5]: print(\u0026#39;Sum is\u0026#39;, 7 + 3) Sum is 10 三引号字符串 字符串中包含引号\n单引号字符串中可以包含双引号，双引号字符串中可以包含单引号，但单引号包含单引号和双引号包含双引号需要用转义字符\n三引号字符串可以将单引号和双引号都包含在内\n多行字符串\n1 2 3 4 5 6 7 8 9 In [1]: triple_quoted_string = \u0026#34;\u0026#34;\u0026#34;This is a triple-quoted ...: string that spans two lines\u0026#34;\u0026#34;\u0026#34; #用引号将字符串赋给变量，三引号中可直接用回车键代替换行符 In [2]: print(triple_quoted_string) This is a triple-quoted string that spans two lines In [3]: triple_quoted_string Out[3]: \u0026#39;This is a triple-quoted\\nstring that spans two lines\u0026#39; #变量嵌入换行符存储多行字符串 格式化字符串 字符串引号前加字母f可以将变量用花括号括起来插入字符串来格式化输出结果\n1 2 3 4 In [1]: a = 1.14514 In [2]: print(f\u0026#39;The number a is {a}\u0026#39;) Out[2]: The number a is 1.14514 更多格式化字符串内容在字符串章节讨论\n获取输入 1 2 3 4 5 6 7 8 In [1]: name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) #input函数显示字符串参数作为提示后等待并返回用户输入，随后赋值给变量 What\u0026#39;s your name? Paul In [2]: value = int(input(\u0026#39;Enter an integer: \u0026#39;)) #input函数只会将输入转换为字符串，需要用int函数将字符串转换为整数，同理float函数可以将字符串转换为浮点数 Enter an integer: 114514 In [3]: int(114.514) #int函数还可以将小数向下取整 Out[3]: 114 控制语句 if语句 if语句根据条件来决定是否执行一条语句\n1 2 3 4 5 6 if 114 \u0026gt; 514: print(\u0026#34;Not homo\u0026#34;) if 114 \u0026lt; 514: print(\u0026#34;Homo\u0026#34;) ------ Homo （分割线以下为程序执行后部分）\nif\u0026hellip;else语句包含满足条件执行的语句和不满足条件执行的雨具\n1 2 3 4 5 6 7 8 #成绩合格判断程序 grade = 57 if grade \u0026gt;= 60: print(\u0026#39;Passed\u0026#39;) else: print(\u0026#39;Failed\u0026#39;) ------ Failed if\u0026hellip;elif\u0026hellip;else语句在多种条件中选择要执行的语句\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #成绩等级判断程序 grade = 77 if grade \u0026gt;= 90: print(\u0026#39;A\u0026#39;) elif grade \u0026gt;= 80: print(\u0026#39;B\u0026#39;) elif grade \u0026gt;= 70: print(\u0026#39;C\u0026#39;) elif grade \u0026gt;= 60: print(\u0026#39;D\u0026#39;) else: print(\u0026#39;F\u0026#39;) ------ C else非必需，即不满足任何一种条件时不执行任何语句\nwhile语句 while语句在循环条件为True时重复执行内部语句\n1 2 3 4 5 6 7 #寻找第一个大于114的2的幂 a = 2 while a \u0026lt;= 114: a = a * 2 print(a) ------ 128 for语句 for语句为一个序列中的每一项重复执行内部语句\n1 2 3 4 5 #输出\u0026#39;Programming\u0026#39;中的每个字母并用空格隔开 for character in \u0026#39;Programming\u0026#39;: print(character, end = \u0026#39; \u0026#39;) ------ P r o g r a m m i n g 执行步骤：\n1.进入循环语句，将\u0026quot;Programming\u0026quot;中的第一个字母P赋值给character\n2.执行循环体中的语句\n3.将下一个字母赋值给character并执行循环体中的语句，直到所有字母都被处理过\n除了字符串，还有其他可迭代的对象序列类型\n列表是用方括号括起来并用逗号分隔的项的合集\n1 2 3 4 5 6 7 #求列表内所有项的和 total = 0 for number in [1, 1, 4, 5, 1, 4]: total = total + number print(total) ------ 16 列表也可以赋值给一个变量，用变量名替代\n内置函数range 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #单参数：创建一个从0开始一直到（但不包括）参数值的整数序列 for counter in range(10): print(counter, end = \u0026#39; \u0026#39;) ------ 0 1 2 3 4 5 6 7 8 9 ------ #双参数：创建一个从第一个参数开始一直到（但不包括）第二个参数的整数序列 for counter in range(5, 10): print(counter, end = \u0026#39; \u0026#39;) ------ 5 6 7 8 9 ------ #三参数：创建一个从第一个参数开始一直到（但不包括）第二个参数，并以第三个参数值（步长）递增的整数序列 for counter in range(1, 14, 3): print(counter, end = \u0026#39; \u0026#39;) ------ 1 4 7 10 13 ------ # 如果第三个参数为负则递减 break和continue语句 break和continue语句用在循环体内改变循环的控制流，执行break语句则立即退出该循环，在while语句中执行continue语句会转回循环条件以确定循环是否该继续执行，在for语句中执行continue语句会直接处理序列中的下一项（如果有）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #break语句 for number in range(100): if number == 10: break print(number, end = \u0026#39; \u0026#39;) ------ 0 1 2 3 4 5 6 7 8 9 ------ #continue语句 for number in range(10): if number == 5: continue print(number, end = \u0026#39; \u0026#39;) ------ 0 1 2 3 4 6 7 8 9 函数 函数定义 函数执行一项明确定义的任务，定义了一个函数后，可以在整个程序中多次调用这个函数\n1 2 3 4 5 6 #定义一个求平方的函数 def square(number): #def 函数名(参数1, 参数2, ...): return number ** 2 #将结果返回给调用者 printf(square(7)) #函数名(参数1, 参数2, ...)，参数数量与定义的数量一致 ------ 49 如果函数不需要参数，则定义和调用时括号内为空\n如果return语句不带表达式将返回None（空值），在条件语句中被判断为False\n如果没有return语句函数将在执行到语句块内最后一条语句后返回None\n在函数的语句块中定义的参数和变量为局部变量，只能在函数体内部使用，在外部需要另外定义\n默认参数值 1 2 3 4 5 6 7 8 In [1]: def rectangle_area(length = 2, width = 3): #指定参数具有默认值 ...: return length * width In [2]: rectangle_area() #调用函数时没有参数，函数使用默认值 Out[2]: 6 In [3]: rectangle_area(10) #调用函数时有一部分参数，函数从左往右给参数赋值，其余保留默认值 Out[3]: 30 关键字参数 1 2 3 4 5 In [1]: def rectangle_area(length, width): ...: return length * width In [2]: rectangle_area(width = 5, length = 10) #调用函数使用关键字参数能以任何顺序传递参数 Out[2]: 50 不定长参数列表 1 2 3 4 5 6 def average(*args): #*将参数打包成元组传递给参数args return sum(args)/len(args) #sum为内置求和函数，len为内置序列长度函数 grades = [88, 75, 96, 55, 83] print(average(*grades)) #*将参数解包，此处调用等同于average(88, 75, 96, 55, 83) ------ 79.4 内置函数max和min是不定长参数函数，可分别用于求出各自参数中的最大值和最小值\n1 2 3 4 5 In [1]: max(11, 45, 14) Out[1]: 45 In [2]: min(11, 45, 14) Out[2]: 11 作用域 在函数体内定义的变量为局部变量，作用域为函数内部\n在函数体外定义的变量为全局变量，作用域在整个程序\n函数体可以直接访问全局变量的值，但无法修改，如果在函数体为全局变量赋值会创建一个同名的新局部变量\n使用global语句在函数体中修改全局变量\n1 2 3 4 5 6 7 8 x = \u0026#39;goodbye\u0026#39; def modify_global(): global x x = \u0026#39;hello\u0026#39; print(\u0026#39;x printed from modify_global:\u0026#39;, x) modify_global() ------ x printed from modify_global: hello lambda函数 对于功能简单只返回一个单一表达式值的函数，可以在调用函数的位置使用一个lambda表达式临时定义一个函数\n1 2 3 4 5 def is_odd(x): return x % 2 != 0 #用lambda定义 lambda x: x % 2 != 0 Python标准库 在编写程序时经常会用到Python标准库或其他库中的函数和类，模块是Python标准库中对相互关联的函数、数据和类进行分组的文件\n一些常用的Python标准库模块\ncollections：列表、元组、字典和集合之外的数据结构\nCryptography：加密数据以实现安全传输\ncsv：处理用逗号分隔值的文件（如Excel）\ndatetime：日期和实践操作\ndecimal：定点和浮点算术运算，包括货币计算\ndoctest：在简单单元测试的文档字符串中嵌入验证测试和预期结果\ngettext和locale：国际化和本地化模块\njson：与Web服务和NoSQL文档数据库一起使用的JSON处理\nmath：常见的数学常数和操作\nos：与操作系统交互\nprofile、pstats、timeit：性能分析\nrandom：伪随机数\nre：用于模式匹配的正则表达式\nsqlite3：SQLite关系数据库访问\nstatistics：数学统计函数\nstring：字符串处理\nsys：命令行参数处理：标准输入、标准输出和标准错误流\ntkinter：图形用户界面和基于画布的图形\nturtle：海龟图\nwebbrowser：用于在Python应用程序中方便地显示网页\n随机数生成 Python标准库的random模块可以模拟偶然因素\n1 2 3 4 5 6 import random #导入random模块 random.seed(32) #设置随机数生成器的种子 for roll in range(10): print(random.randrange(1, 7), end = \u0026#39; \u0026#39;) #randrange函数随机生成一个从第一个参数到（但不包括）第二个参数之间的整数值 ------ 1 2 2 3 6 2 4 1 6 1 函数randrange生成的是基于以一个称为seed的数值开头的内部计算生成的伪随机数，每次新的会话或执行含随机函数的脚本Python会使用不同的seed，可以用seed函数为随机数生成器设置种子，相同种子的伪随机数序列相同，便于程序调试\nmath模块中的函数 函数 说明 ceil(x) 将x向上取整 floor(x) 将x向下取整 sin(x)\ncos(x)\ntan(x) 求x的正弦\n求x的余弦\n求x的正切（以上均为弧度制） exp(x)\nlog(x)\nlog10(x) 指数函数e^x^\n求x的自然对数（底为e）\n求x的对数（底为10） pow(x, y)\nsqrt(x) 求x的y次幂\n求x的平方根 fabs(x) 求x的绝对值，返回浮点数。Python内置abs绝对值函数根据参数返回整数或浮点数 fmod(x, y) x除以y的余数，返回浮点数 import语句 1 2 3 4 5 6 7 8 9 10 11 12 #用import 模块名导入，需要通过模块名称和一个点（.）访问包含在模块内的函数 In [1]: import math In [2]: math.ceil(10.3) Out[2]: 11 #用from 模块名 import 函数1, 函数2, ...导入，可以直接使用函数名 In [3]: from math import ceil, floor In [4]: ceil(10.3) Out[4]: 11 #“from 模块名 import *”使用通配符*导入模块中的所有函数，但可能触发不容易察觉的错误，如变量名和函数名歧义 #“import 模块名 as 自定义模块名”可以用自定义缩写来表示导入的模块来简化代码 序列 列表 列表通常存储同构数据（数据类型相同），也可以存储异构数据（数据类型不同），元素和长度可以修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 In [1]: c = [-45, 6, 0, 72, 114] #创建列表 In [2]: c[0] #访问列表中第n+1个元素，因为列表中元素编号从0开始 Out[2]:-45 In [3]: len(c) #获取列表的长度 Out[3]: 5 In [4]: c[-1] #用负数访问列表，列表负数编号最后一个元素为-1，从后往前递减 Out[4]: 114 In [5]: c[2] = 514 #修改列表中的元素，此时c为[-45, 6, 514, 72, 114]，而字符串和元组序列无法修改元素 In [6]: c += [1919] #创建一个单元素列表并添加到列表c末尾，此时c为[-45, 6, 514, 72, 114, 1919] In [7]: ho = [1, 1, 4] In [8]: mo = [5, 1, 4] In [9]: homo = ho + mo #运算符+拼接两个列表，此时homo为[1, 1, 4, 5, 1, 4] In [10]: homo *= 2 #成倍地扩充序列，此时homo为[1, 1, 4, 5, 1, 4, 1, 1, 4, 5, 1, 4] 比较运算符逐一比较列表中的每个元素\n1 2 3 4 5 6 7 8 9 10 11 In [10]: a = [1, 2, 3] In [11]: b = [1, 2, 3] In [12]: c = [1, 2, 3, 4] In [13]: a == b Out[13]: True #a和b每个元素都相等 In [15]: a \u0026lt; c Out[14]: True #a的元素数量比c少 列表处理方法 sort方法（排序） 1 2 3 4 5 6 7 8 9 In [1]: numbers = [10, 3, 7, 1, 9, 4, 2, 8, 5, 6] In [2]: numbers.sort() #按升序排列列表元素[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] In [3]: numbers.sort(reverse = True) #按降序排列列表元素（默认值为False） In [4]: numbers = [10, 3, 7, 1, 9, 4, 2, 8, 5, 6] In [5]: ascending_numbers = sorted(numbers) #内置函数sorted返回按升序排列好的列表给新列表，不改变原列表 字符和字符串元素将按ASCII表顺序排列\ninsert方法（插入） 1 2 3 4 In [1]: color_names = [\u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;] In [2]: color_names.insert[0, red] #在索引0处插入\u0026#39;red\u0026#39;：[\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;] append方法（末尾添加） 1 2 In [3]: color_names.append(\u0026#39;blue\u0026#39;) #在列表末尾添加\u0026#39;blue\u0026#39;：[\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] extend方法（末尾扩充） 1 2 3 In [4]: color_names.extend([\u0026#39;indigo\u0026#39;, \u0026#39;violet\u0026#39;]) #将另一个序列的所有元素添加到列表的末尾：[\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;indigo\u0026#39;, \u0026#39;violet\u0026#39;] #等效于+= remove方法（移除） 1 2 In [5]: color_names.remove(\u0026#39;green\u0026#39;) #移除列表中某个值的第一个匹配项：[\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;indigo\u0026#39;, \u0026#39;violet\u0026#39;] clear方法（清空） 1 In [6]: color_names.clear() #清空列表中的所有元素 count方法（计数） 1 2 3 4 In [7]: responses = [1, 2, 5, 4, 3, 5, 2, 1, 3, 3, 1, 4, 3, 3, 3, 2, 3, 3, 2, 2] In [8]: responses.count(3) #返回某个元素在列表中出现的次数 Out[8]: 8 reverse方法（反转） 1 2 3 4 In [9]: color_names = [\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] In [10]: color_names.reverse() #反转列表中的元素：[\u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;red\u0026#39;] copy方法（拷贝） 1 2 3 4 In [11]: copied_list = color_names.copy() #返回一个包含原始对象浅拷贝的新列表 In [12]: copied_list Out[12]: [\u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;red\u0026#39;] 列表推导式 列表推导式是将一个列表转换成另一个列表的工具，在转换过程中可以指定元素必须符合一定的条件才能添加到新的列表中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 In [1]: list1 = [item for item in range(1, 6)] #创建整数列表：[1, 2, 3, 4, 5] In [2]: list2 = [item ** 3 for item in range(1, 6)] #将每个值的立方映射到新列表：[1, 8, 27, 64, 125] In [3]: list3 = [item for item in range(1, 11) if item % 2 == 0] #过滤出偶数到新列表：[2, 4, 6, 8, 10] In [4]: colors = [\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] In [5]: colors2 = [item.upper() for item in colors] #将所有元素大写映射到新列表：[\u0026#39;RED\u0026#39;, \u0026#39;ORANGE\u0026#39;, \u0026#39;YELLOW\u0026#39;, \u0026#39;GREEN\u0026#39;, \u0026#39;BLUE\u0026#39;] #总结：for前映射操作，if后过滤条件 生成器表达式 列表推导式使用贪婪计算，每次都会创建一个包含了所有值的列表，用[]括起来\n生成器表达式使用惰性计算，只返回符合要求的值，用()括起来\n1 2 3 4 5 numbers = [10, 3, 7, 1, 9, 4, 2, 8, 5, 6] for value in (x ** 2 for x in numbers if x % 2 != 0): print(value, end = \u0026#39; \u0026#39;) ------ 9 49 1 81 25 二维列表 用两个索引来表示元素的列表称为二维列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 In [1]: a = [[77, 68, 86, 73], [96, 87, 89, 81], [70, 90, 86, 81]] #创建一个三行四列的二维列表，每个二级方括号为一行 In [2]: a[0][2] #访问行索引为0，列索引为2的元素 Out[2]: 86 In [3]: for row in a: ...: for item in row: ...: print(item, end = \u0026#39; \u0026#39;) print() 77 68 86 73 96 87 89 81 70 90 86 81 #用嵌套for语句按行输出二维列表，可见二维列表先按行提取再按列提取 元组 元组通常存储异构数据，也可以存储同构数据，元素和长度不能随意更改，只能给整个元组重新赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 In [1]: student_tuple = () #创建一个空元组 In [2]: student_tuple = \u0026#39;John\u0026#39;, \u0026#39;Green\u0026#39;, 3.3 #用逗号分隔构造元组，括号可选 In [3]: student_tuple = (\u0026#39;red\u0026#39;,) #用逗号和括号构造单元素元组 In [4]: time_tuple = (1919, 8, 10) In [5]: time_tuple[0] #访问元组元素与列表同理 Out[5]: 1919 In [6]: time_tuple += (1, 2) #将元组time_tuple拼接上元组(1, 2)再重新赋值给time_tuple In [7]: numbers = [1, 2, 3] In [8]: numbers += (4, 5) #将元组附加到列表中，此时numbers为[1, 2, 3, 4, 5] In [9]: tuple = (\u0026#39;ho\u0026#39;, \u0026#39;mo\u0026#39;, [11, 45, 14]) In [10]: tuple[2][1] = 54 #元组不可变，但元组中列表的元素可变，此时tuple玩(\u0026#39;ho\u0026#39;, \u0026#39;mo\u0026#39;, [11, 54, 14]) 序列解包 1 2 3 4 5 6 7 8 9 In [1]: student_tuple = (\u0026#39;Amanda\u0026#39;, 114) In [2]: name, grades = student_tuple #序列可以分配给用逗号分隔的变量列表，此时name为\u0026#39;Aman\u0026#39;，grades为114 In [3]: number1 = 114 In [4]: number2 = 514 In [5]: number1, number2 = (number2, number1) #用打包和解包来交换两个变量的值 内置函数enumerate对列表中每个元素返回一个索引和值的元组\n1 2 3 4 5 6 7 In [6]: colors = [\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;] In [7]: list(enumerate(colors)) #内置函数list创建一个列表包含enumerate的输出 Out[7]: [(0, \u0026#39;red\u0026#39;), (1, \u0026#39;orange\u0026#39;), (2, \u0026#39;yellow\u0026#39;)] In [8]: tuple(enumerate(colors)) #同理内置函数tuple从序列创建一个元组 Out[8]: ((0, \u0026#39;red\u0026#39;), (1, \u0026#39;orange\u0026#39;), (2, \u0026#39;yellow\u0026#39;)) 序列切片 1 2 3 4 5 6 7 8 9 10 11 12 13 In [1]: numbers = [2, 3, 5, 7, 11, 13, 17, 19] In [2]: numbers[2:6] #从第一个想要的对象开始到第一个不想要的对象结束的切片 Out[2]: [5, 7, 11, 13] In [3]: numbers[:6] #省略起始索引默认从0开始 Out[3]: [2, 3, 5, 7, 11, 13] In [4]: numbers[6:] #省略结束索引默认到序列末尾结束 Out[4]: [17, 19] In [5]: numbers[:] #省略开始索引和结束索引会复制整个序列 Out[5]: [2, 3, 5, 7, 11, 13, 17, 19] 切片的步长 1 2 3 4 5 In [6]: numbers[::2] #以2为步长构造间隔1个元素的切片 Out[6]: [2, 5, 11, 17] In [7]: numbers[::-1] #负数步长以倒序构造切片，该行代码等价于numbers[-1:-9:-1] Out[7]: [19, 17, 13, 11, 7, 5, 3, 2] 切片修改列表 1 2 3 4 5 6 7 8 9 10 In [8]: numbers[0:3] = [\u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;five\u0026#39;] #将numbers前三个元素替换 In [9]: numbers[0:3] = [] #将numbers前三个元素删除 In [10]: numbers = [2, 3, 5, 7, 11, 13, 17, 19] In [11]: numbers[::2] = [100, 100, 100, 100] #间隔1个元素赋值列表元素 In [12]: numbers Out[12]: [100, 3, 100, 7, 100, 13, 100, 19] del声明 1 2 3 4 5 6 7 8 9 10 11 In [1]: numbers = list(range(0, 10)) #创建列表[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] In [2]: del numbers[-1] #删除列表最后一个元素[0, 1, 2, 3, 4, 5, 6, 7, 8] In [3]: del numbers[0:2] #删除列表前两个元素[2, 3, 4, 5, 6, 7, 8] In [4]: del numbers[::2] #每隔一个步长删除列表中的一个元素[3, 5, 7] In [5]: del numbers[:] #删除列表的所有元素 In [6]: del numbers #删除numbers这个变量 序列搜索 index方法 1 2 3 4 5 6 7 8 9 10 11 12 In [1]: numbers = [3, 7, 1, 4, 2, 8, 5, 6] In [2]: numbers.index(5) #从索引0开始搜索列表，返回与关键词匹配的第一个元素的索引 Out[2]: 6 In [3]: numbers *= 2 In [4]: numbers.index(5, 7) #从索引7到列表末尾的所有元素中搜索5 Out[4]: 14 In [5]: numbers.index(7, 0, 4) #在索引0到3范围内查找值等于7的元素 Out[5]: 1 in和not in 1 2 3 4 5 In [6]: 1000 in numbers #检测1000是否在序列里 Out[6]: False In [7]: 1000 not in numbers #检测1000是否不在序列里 Out[7]: True 序列处理函数 filter函数（过滤） 1 2 3 4 In [1]: numbers = [10, 3, 7, 1, 9, 4, 2, 8, 5, 6] In [2]: list(filter(lambda x: x % 2 != 0, numbers)) #过滤出序列numbers中使得is_odd为真的元素 Out[2]: [3, 7, 1, 9, 5] map函数（映射） 1 2 In [3]: list(map(lambda x: x ** 2, numbers)) #将序列中元素平方处理后映射到新列表 Out[3]: [100, 9, 49, 1, 81, 16, 4, 64, 25, 36] 归约 内置函数len（求长度）、sum（求和）、min（求最小值）和max（求最大值）将序列的元素处理为单个值，称为归约\nkey函数（查找最值） 归约函数min和max使用数字列表作为参数，在更复杂的对象比如字符串中找最值需要使用key函数\n1 2 3 4 5 In [1]: colors = [\u0026#39;Red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;Yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;Blue\u0026#39;] In [2]: min(colors, key = lambda s: s.lower()) Out[2]: \u0026#39;Blue\u0026#39; #key的参数调用一个返回值的单参数函数对序列中元素进行处理再在min函数中作比较，因为字符串比较用的ASCII值小写字母比大写字母大，所以按字母表顺序需要用lower方法将所有字符串统一处理为小写字母 reverse函数（反向迭代） 1 2 3 4 In [1]: numbers = [10, 3, 7, 1, 9, 4, 2, 8, 5, 6] In [2]: reversed_numbers = [item for item in reversed(numbers)] #反向迭代序列numbers的值，此时reversed_numbers为[6, 5, 8, 2, 4, 9, 1, 7, 3, 10] zip函数（合并） zip函数同时遍历多个可迭代对象的数据并把相同索引的元素提取出来打包成元组返回\n1 2 3 4 5 6 7 8 names = [\u0026#39;Bob\u0026#39;, \u0026#39;Sue\u0026#39;, \u0026#39;Amanda\u0026#39;] grade_point_averages = [3.5, 4.0, 3.75] for name, gpa in zip(names, grade_point_averages): printf(f\u0026#39;Name={name}; GPA={gpa}\u0026#39;) ------ Name=Bob; GPA=3.5 Name=Sue; GPA=4.0 Name=Amanda; GPA=3.75 未完待续\n","date":"2024-11-15T00:00:00Z","permalink":"https://INKEM.github.io/p/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%80%9F%E8%A7%88%E4%B8%8A/","title":"【Python】基础语法速览（上）"},{"content":"操作臂逆运动学 上一章我们讨论了已知关节角，计算工具坐标系相对于固定坐标系的位姿的问题。在本章中我们将研究已知工具坐标系相对于固定坐标系的期望位姿，如何计算一系列满足期望要求的关节角，即逆运动学问题\n逆运动学方程的解 解的存在性 研究解是否存在放在操作臂上即研究操作臂的工作空间\n可达工作空间（Reachable Workspace）：手臂可以用至少一种姿态到达的位置\n灵巧工作空间（Dexterous Workspace）：手臂可以用任何姿态到达的位置\n我们用R（旋转关节）和P（移动关节）的字母组合来简记一个操作臂的关节连接顺序\n在上图的处于二维平面的RR操作臂中，如果$l_1\u003el_2$，其可达工作空间为外径$l_1+l_2$、内径$l_1-l_2$的圆环，没有灵巧工作空间；如果$l_1=l_2$，其可达空间为半径$l_1+l_2$的圆，圆心为灵巧工作空间\n如果要让操作臂达到一个三维空间内一般的目标位置和姿态，至少需要六个自由度。当操作臂自由度$n\u003c6$时，其工作空间会被局限在仅能由$n$个独立变量描述的$n$自由度子空间（Subspace），又由于操作臂关节的活动范围受限，其工作空间是对应的$n$自由度子空间的子集\n对于上图的RRR操作臂，其工具坐标系的位置局限在由两个独立坐标变量$x$、$y$描述的一个平面内，而姿态局限在该平面中的一个独立旋转角度变量$\\phi$，由此我们用三个独立变量描述出它的三自由度子空间为：\n$^0_3T=\\begin{bmatrix}c_\\phi\u0026-s_\\phi\u00260\u0026x\\\\s_\\phi\u0026c_\\phi\u00260\u0026y\\\\0\u00260\u00261\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n而其工作空间则进一步局限在该子空间中满足$\\sqrt{x^2+y^2}\\leqslant l_1+l_2+l_3$的部分中\n对于上图的RP操作臂，其工具坐标系的位置局限在由两个独立坐标变量$x$、$y$描述的一个平面内，而姿态也同时由$x$、$y$所决定，$^0\\hat{Y}_2$始终向下，$^0\\hat{Z}_2$与原点的位置矢量同向，$^0\\hat{X}_2$由$^0\\hat{Y}_2$、$^0\\hat{Z}_2$叉乘得到，其二自由度工作空间为：\n$^0_2T=\\begin{bmatrix}\\frac{y}{\\sqrt{x^2+y^2}}\u00260\u0026\\frac{x}{\\sqrt{x^2+y^2}}\u0026x\\\\\\frac{-x}{\\sqrt{x^2+y^2}}\u00260\u0026\\frac{y}{\\sqrt{x^2+y^2}}\u0026y\\\\0\u0026-1\u00260\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n多解问题 由于逆运动学方程是非线性方程，求解过程中往往遇到多解问题\n通过上图我们来直观感受：对于同一个绿色末端连杆的目标位姿，根据肘部方向的不同，前两根连杆有深蓝和浅蓝所示的两种方式可以达到\n但我们只能选择一个解来执行，因此要有解的选择标准。常见的选择条件一个是要求到达目标位姿的过程中每个运动关节的运动量最小，即就近原则，另一个是考虑运动轨迹中的障碍物。下图直观展示了这两种情况：\n解的个数取决于操作臂的关节数量、连杆参数和关节运动范围\n对于关节数量，考虑一种极限状态，当一个操作臂在一定长度内有无穷多个关节，即可看做是一根柔性的曲线，对固定的末端姿态，中间段有无穷多个解\n对于连杆参数，通常当连杆的非零参数越多，到达某一特定目标的方式也越多。以一个6R操作臂为例，下表展示了解的最大数目与等于零的连杆长度参数的数目之间的关系，非零参数越多，解的最大数目就越大\n$a_i$ 解的个数 $a_1=a_3=a_5=0$ $\\leqslant4$ $a_3=a_5=0$ $\\leqslant8$ $a_3=0$ $\\leqslant16$ 所有$a_i\\neq0$ $\\leqslant16$ 而关节运动范围则限制了解的选择\n逆运动学方程的解法 与线性方程组不同，非线性方程组没有通用的求解算法，我们只能用两大类解法来求解：封闭解（解析解，Closed-form Solutions）和数值解（Numerical Solutions）\n封闭解是一个关于方程自变量的解析函数，代入自变量即可解得因变量；数值解通过数值迭代求解。前者的缺点在于不是所有的非线性方程组都有封闭解，后者的缺点在于求解速度慢且不适应多解问题\n为此，我们在逆运动学中尽量避免数值解，在设计操作臂的结构时保证其存在封闭解\n逆运动学方程封闭解的解法包括代数解法和几何解法，前者纯靠代数运算，后者结合问题的几何性质，以下内容以数学计算为主，与机器人理论联系较少，可适当略读\n我们先研究开头举例的RRR操作臂来给出这两种解法，对于给定的目标位姿独立变量$(x,y,\\phi)$，求出三个关节的关节角$(\\theta_1,\\theta_2,\\theta_3)$\n代数解法 由前文求解的子空间，用目标位姿参数给出的位姿矩阵为：\n$^0_3T=\\begin{bmatrix}c_\\phi\u0026-s_\\phi\u00260\u0026x\\\\s_\\phi\u0026c_\\phi\u00260\u0026y\\\\0\u00260\u00261\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n由正向运动学，用关节变量给出的位姿矩阵为：\n$^0_3T=\\begin{bmatrix}c_{123}\u0026-s_{123}\u00260\u0026l_1c_1+l_2c_{12}\\\\s_{123}\u0026c_{123}\u00260\u0026l_1s_1+l_2s_{12}\\\\0\u00260\u00261\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n其中下标数字组合代表对应关节角的和，如$c_{12}$表示$\\cos(\\theta_1+\\theta_2+\\theta_3)$\n两矩阵联立得到四个非线性方程：\n$c_\\phi=c_{123}$①\n$s_\\phi=s_{123}$②\n$x=l_1c_1+l_2c_{12}$③\n$y=l_1s_1+l_2s_{12}$④\n对③和④同时平方再求和得：\n$x^2+y^2=l^2_1+l^2_2+2l_1l_2c_2$\n这里利用了三角函数两角和公式\n由此求解出$c_2=\\frac{x^2+y^2-l^2_1-l^2_2}{2l_1l_2}$\n上式有解的条件为等式右侧的值必须在$[-1,1]$之间，否则说明在物理结构上目标点位置太远，操作臂不可达\n假定目标点在工作空间内，则$s_2=\\pm\\sqrt{1-c^2_2}$\n$\\theta_2=\\textup{Atan2}(s_2,c_2)$\n式中正负符号的选择对应“肘部朝上”还是“肘部朝下”的多解问题\n接下来求$\\theta_1$\n令：\n$k_1=l_1+l_2c_2$\n$k_2=l_2s_2$\n则③和④可写成：\n$x=k_1c_1-k_2s_1$\n$y=k_1s_1+k_2c_1$\n求解该类方程可用变量代换改变常数$k_1$和$k_2$的形式，如果：\n$r=\\sqrt{k^2_1+k^2_2}$\n$\\gamma=\\textup{Atan2}(k_2,k_1)$\n则：\n$k_1=r\\cos\\gamma$\n$k_2=r\\sin\\gamma$\n则③和④可进一步写成：\n$\\frac{x}{r}=\\cos\\gamma\\cos\\theta_1-\\sin\\gamma\\sin\\theta_1$\n$\\frac{y}{r}=\\cos\\gamma\\sin\\theta_1-\\sin\\gamma\\cos\\theta_1$\n因此：\n$\\cos(\\gamma+\\theta_1)=\\frac{x}{r}$\n$\\sin(\\gamma+\\theta_1)=\\frac{y}{r}$\n得：\n$\\gamma+\\theta_1=\\textup{Atan2}(\\frac{y}{r},\\frac{x}{r})=\\textup{Atan2}(y,x)$\n从而：\n$\\theta_1=\\textup{Atan2}(y,x)-\\textup{Atan2}(k_2,k_1)$\n最后$\\theta_3$由$\\theta_1+\\theta_2+\\theta_3=\\phi$解出\n几何解法 画出以三个关节为顶点的三角形，由余弦定理得：\n$x^2+y^2=l^2_1+l^2_2-2l_1l_2\\cos(\\theta_2+\\pi)$\n由此求解出$c_2=\\frac{x^2+y^2-l^2_1-l^2_2}{2l_1l_2}$\n为求解出$\\theta_1$，需求出图中$\\psi$和$\\beta$的表达式\n$\\beta$是位置矢量与$\\hat{X}_0$的夹角，可得：\n$\\beta=\\textup{Atan2}(y,x)$\n可在三角形再次利用余弦定理解出$\\cos\\psi=\\frac{x^2+y^2+l^2_1-l^2_2}{2l_1\\sqrt{x^2+y^2}}$\n为使几何关系成立，求反余弦需使$0\\leqslant\\psi\\leqslant\\pi$\n于是$\\theta_1=\\beta\\pm\\psi$，当$\\theta_2\u003c0$取正，当$\\theta_2\u003e0$取负\n最后$\\theta_3$由$\\theta_1+\\theta_2+\\theta_3=\\phi$解出\n万能公式 对于单变量的三角函数超越方程，可用万能公式代换化为多项式方程\n令$u=\\tan\\frac{\\theta}{2}$\n则$\\cos\\theta=\\frac{1-u^2}{1+u^2}$，$\\sin\\theta=\\frac{2u}{1+u^2}$\n三轴相交的Pieper解法 尽管一般的六自由度机器人没有封闭解，但在某些特殊情况下还是可解的。Pieper提出了一种求解最后三个连续轴相交于一点的六自由度操作臂的方法，核心思想为让$\\theta_1$、$\\theta_2$、$\\theta_3$层层分离\n当最后三个轴相交时，连杆坐标系$\\{4\\}$、$\\{5\\}$、$\\{6\\}$的原点均位于这个交点上，因此：\n$^0P_{6ORG}=^0P_{4ORG}=^0_1T^1_2T^2_3T^3P_{4ORG}=\\begin{bmatrix}x\\\\y\\\\z\\\\1\\end{bmatrix}$\n其中，$^3P_{4ORG}$即$^3_4T$的第四列，由第三章中相邻连杆变换矩阵公式代入得：\n$^0P_{4ORG}=^0_1T^1_2T^2_3T\\begin{bmatrix}a_3\\\\-d_4s\\alpha_3\\\\d_4c\\alpha_3\\\\1\\end{bmatrix}$\n将$^2_3T$乘进去得：\n$^0P_{4ORG}=^0_1T^1_2T\\begin{bmatrix}f_1(\\theta_3)\\\\f_2(\\theta_3)\\\\f_3(\\theta_3)\\\\1\\end{bmatrix}$\n式中：\n$f_1=a_3c_3+d_4s\\alpha_3s_3+a_2$\n$f_2=a_3c\\alpha_2s_3-d_4s\\alpha_3c\\alpha_2c_3-d_4s\\alpha_2c\\alpha_3-d_3s\\alpha_2$\n$f_3=a_3s\\alpha_2s_3-d_4s\\alpha_3s\\alpha_2c_3+d_4c\\alpha_2c\\alpha_3+d_3c\\alpha_2$\n继续将$^0_1T^1_2T$乘进去得：\n$^0P_{4ORG}=\\begin{bmatrix}c_1g_1-s_1g_2\\\\s_1g_1+c_1g_2\\\\g_3\\\\1\\end{bmatrix}$①\n式中：\n$g_1=c_2f_1-s_2f_2+a_1$\n$g_2=s_2c\\alpha_1f_1+c_2c\\alpha_1f_2-s\\alpha_1f_3-d_2s\\alpha_1$\n$g_3=s_2s\\alpha_1f_1+c_2s\\alpha_1f_2+c\\alpha_1f_3+d_2c\\alpha_1$\n现在写出$^0P_{4ORG}$模的平方的表达式：\n$r=x^2+y^2+z^2=g_1^2+g_2^2+g_3^2$\n$r=f_1^2+f_2^2+f_3^2+a_1^2+d_2^2+2d_2f_3+2a_1(c_2f_1-s_2f_2)$\n上式与$z=g_3$联立得到一个方程组：\n$\\left\\{\\begin{matrix}r=(k_1c_2+k_2s_2)2a_1+k_3\\\\z=(k_1s_2-k_2c_2)s\\alpha_1+k_4\\end{matrix}\\right.$②\n式中：\n$k_1=f_1$\n$k_2=-f_2$\n$k_3=f_1^2+f_2^2+f_3^2+a_1^2+d_2^2+2d_2f_3$\n$k_4=f_3c\\alpha_1+d_2c\\alpha_1$\n该方程组的求解分三种情况：\n$1)$若$a_1=0$，则$r=k_3$，$r$已知，$k_3$是关于$\\theta_3$的一元函数，由万能公式解出$\\theta_3$\n$2)$若$s\\alpha_1=0$，则$z=k_4$，$z$已知，$k_4$是关于$\\theta_3$的一元函数，由万能公式解出$\\theta_3$\n$3)$否则，消元法消去$c_2$和$s_2$，得到：\n$\\frac{(r-k_3)^2}{4a_1^2}+\\frac{(z-k_4)^2}{s^2\\alpha_1}=k_1^2+k_2^2$\n由万能公式得到一个四次方程解出$\\theta_3$\n解出$\\theta_3$后，可由②解出$\\theta_2$，由①解出$\\theta_1$\n为了完成求解工作，还需要求出$\\theta_4$、$\\theta_5$、$\\theta_6$，由于这些轴相交，原点已经确定，故这些关节角只影响末端连杆的姿态。先利用已经解出的$\\theta_1$、$\\theta_2$、$\\theta_3$算出连杆坐标系$\\{4\\}$的初始姿态$^4_0R|_{\\theta_4=0}$，再计算出以此为参考坐标系的末端连杆的姿态描述：\n$^4_6R|_{\\theta_4=0}=^0_4R^{-1}|_{\\theta_4=0}{}_6^0R$\n用欧拉角定义最后三个关节角得到一个旋转矩阵后与$^4_6R|_{\\theta_4=0}$联立即可完成求解\n关于用欧拉角定义关节角： 由于不同关节角对应的转轴是不同连杆坐标系的关节轴，而欧拉角从始至终都是绕一个坐标系的主轴旋转，因此用欧拉角来描述关节角的变换过程时，我们有时需要使欧拉角在关节角的基础上多转$180^\\circ$，让欧拉角坐标系中的一个主轴能跟下一个连杆坐标系的关节轴对齐，便于用下一次旋转的欧拉角描述下一次旋转的关节角，可结合下图理解，其中连杆坐标系每次从蓝色变换到红色，欧拉角坐标系每次从橙色变换到绿色\n本章完\n","date":"2024-11-12T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep4.%E6%93%8D%E4%BD%9C%E8%87%82%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6/","title":"【机器人学导论】Ep4.操作臂逆运动学"},{"content":"程序实验Ep1.点亮LED 单片机介绍 单片机（Micro Controller Unit），简称MCU\n内部集成了CPU、RAM、ROM、定时器、中断系统、通讯接口等一系列电脑常用硬件功能\n单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如电机、LED等）的控制\n跟计算机相比，单片机是一个袖珍版计算机，一个芯片就能构成完整的计算机系统，但在性能上与计算机相差甚远，但单片机成本低、体积小、结构简单，在生活和工业控制领域大有所用的同时，学习使用单片机也是了解计算机原理与结构的最佳选择\n51单片机是对所有兼容Intel 8051指令系统的单片机的统称\nSTC89C52系列内部结构框图\nSTC89C52系列PDIP封装管脚图\n51单片机最小系统 能使51单片机工作的最简单最基础的电路统称为51单片机最小系统，由晶振电路、复位电路、电源电路构成，而要为单片机烧录程序还需要下载电路\n晶振电路 晶振电路为单片机正常工作提供一个时钟\n51单片机的时钟频率在0~40MHz运行，通常选用12MHz（便于计算时间）或11.059MHz（串行通信波特率为零）的晶振接在管脚18、19\n旁路电容作用：消除晶振接入电路一瞬间产生的电感干扰，一端接地，电容大小取决于晶振大小\n复位电路 复位电路提供系统复位的操作，当系统工作不正常或死机时可以重启系统\n复位的两种方式：手动按键复位（上图）和接通电源自动复位（下图）\nSTC89C51单片机为高电平复位，只要让引脚保持一段时间的高电平即可复位\n电源电路 单片机电压过大会烧毁电路，电压过小系统会运行不起来，因此需要挑选合适的电源电路\n下载电路 下载电路将编译文件下载到单片机\nC语言C51扩充内容 C51扩充数据类型 类型 长度 值域 说明 bit 位 0或1 位变量声明 sbit 位 0或1 特殊功能位声明 sfr 8位=1字节 0~255 特殊功能寄存器声明 sfr16 16位=2字节 0~65535 sfr的16位数据声明 * 1~3字节 对象的地址 例：\n1 2 3 4 sfr SCON = 0x98; //使用SCON控制单片机上地址为0x98的寄存器 sbit TI = SCON^1; //使用TI控制八位寄存器SCON位0~7中的位1 reg52头文件 reg52头文件定义了51单片机特殊功能寄存器和特殊功能位的名字以便我们访问\n1 2 3 #include \u0026lt;reg52.h\u0026gt;//直接在安装目录下寻找头文件 #include \u0026#34;reg52.h\u0026#34;//先在工程目录下寻找头文件，再到安装目录 //右键头文件可打开头文件内容 头文件内容（了解如何定义即可）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 /*-------------------------------------------------------------------------- REG52.H Header file for generic 80C52 and 80C32 microcontroller. Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc. All rights reserved. --------------------------------------------------------------------------*/ #ifndef __REG52_H__ #define __REG52_H__ /* BYTE Registers */ sfr P0 = 0x80; sfr P1 = 0x90; sfr P2 = 0xA0; sfr P3 = 0xB0; sfr PSW = 0xD0; sfr ACC = 0xE0; sfr B = 0xF0; sfr SP = 0x81; sfr DPL = 0x82; sfr DPH = 0x83; sfr PCON = 0x87; sfr TCON = 0x88; sfr TMOD = 0x89; sfr TL0 = 0x8A; sfr TL1 = 0x8B; sfr TH0 = 0x8C; sfr TH1 = 0x8D; sfr IE = 0xA8; sfr IP = 0xB8; sfr SCON = 0x98; sfr SBUF = 0x99; /* 8052 Extensions */ sfr T2CON = 0xC8; sfr RCAP2L = 0xCA; sfr RCAP2H = 0xCB; sfr TL2 = 0xCC; sfr TH2 = 0xCD; /* BIT Registers */ /* PSW */ sbit CY = PSW^7; sbit AC = PSW^6; sbit F0 = PSW^5; sbit RS1 = PSW^4; sbit RS0 = PSW^3; sbit OV = PSW^2; sbit P = PSW^0; //8052 only /* TCON */ sbit TF1 = TCON^7; sbit TR1 = TCON^6; sbit TF0 = TCON^5; sbit TR0 = TCON^4; sbit IE1 = TCON^3; sbit IT1 = TCON^2; sbit IE0 = TCON^1; sbit IT0 = TCON^0; /* IE */ sbit EA = IE^7; sbit ET2 = IE^5; //8052 only sbit ES = IE^4; sbit ET1 = IE^3; sbit EX1 = IE^2; sbit ET0 = IE^1; sbit EX0 = IE^0; /* IP */ sbit PT2 = IP^5; sbit PS = IP^4; sbit PT1 = IP^3; sbit PX1 = IP^2; sbit PT0 = IP^1; sbit PX0 = IP^0; /* P3 */ sbit RD = P3^7; sbit WR = P3^6; sbit T1 = P3^5; sbit T0 = P3^4; sbit INT1 = P3^3; sbit INT0 = P3^2; sbit TXD = P3^1; sbit RXD = P3^0; /* SCON */ sbit SM0 = SCON^7; sbit SM1 = SCON^6; sbit SM2 = SCON^5; sbit REN = SCON^4; sbit TB8 = SCON^3; sbit RB8 = SCON^2; sbit TI = SCON^1; sbit RI = SCON^0; /* P1 */ sbit T2EX = P1^1; // 8052 only sbit T2 = P1^0; // 8052 only /* T2CON */ sbit TF2 = T2CON^7; sbit EXF2 = T2CON^6; sbit RCLK = T2CON^5; sbit TCLK = T2CON^4; sbit EXEN2 = T2CON^3; sbit TR2 = T2CON^2; sbit C_T2 = T2CON^1; sbit CP_RL2 = T2CON^0; #endif 点亮第一个LED C51单片机GPIO介绍及LED线路 **GPIO（General Purpose Input Output）**是通用输入输出端口的简称，可以通过软件来控制其输入和输出\n51单片机引脚分类：\n电源引脚（Vcc/Vdd/Gnd/Vss） 晶振引脚（XTAL） 复位引脚（RST/Reset） 下载引脚（P3.0/P3.1） GPIO引脚（P0~P3） 详细管脚功能可在单片机手册中查询\nLED线路图\n程序1：点亮D1指示灯 1 2 3 4 5 6 7 #include \u0026#34;reg52.h\u0026#34; sbit LED1 = P2^0;//将控制D1灯的P2管脚第0位命名为LED1 void main() { LED1 = 0;//设置LED1为低电平，LED低电平0点亮，高电平1熄灭 } 效果图\n程序2：控制D1指示灯闪烁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026#34;reg52.h\u0026#34; typedef unsigned int u16; sbit LED1 = P2^0; void delay_10us(u16 time)//定义延时函数 { while(time --); //单次while循环时间约为10微秒，后续讲到定时器可以准确计时 } void main() { while(1) { LED1 = 0;//点亮D1灯 delay_10us(50000);//延时约488毫秒 LED1 = 1;//熄灭D1灯 delay_10us(50000); } } 程序3：LED流水灯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026#34;reg52.h\u0026#34; #define LED_PORT P2//使用宏定义将P2端口定义 typedef unsigned char u8; typedef unsigned int u16; void delay_10us(u16 time) { while(time --); } void main() { u8 i = 0;//循环控制变量 while(1) { for(i = 0;i \u0026lt; 8;i++) { LED_PORT = ~(0x01 \u0026lt;\u0026lt; i);//见下文解读 delay_10us(50000); } } } LED_PORT用八位二进制数上的每一位分别控制八个LED灯的电平，要实现流水灯，其值应当这样变化：11111110→11111101→11111011→……\n不难想到可以通过左移运算符让二进制数的数位整体左移，但是二进制数左移后最右侧会补零而不是补一，因此采用对00000001左移再按位取反的方法\n代码中0x01采用十六进制是为了简洁\n额外介绍一个使用intrins头文件中左移右移的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026#34;reg52.h\u0026#34; #include \u0026#34;intrins.h\u0026#34; #define LED_PORT P2 typedef unsigned char u8; typedef unsigned int u16; void delay_10us(u16 time) { while(time --); } void main() { u8 i = 0; LED_PORT =~ 0x01; while(1) { for(i = 0;i \u0026lt; 7;i++) { LED_PORT = _crol_(LED_PORT,1); //对LED_PORT左移1位，并将左侧移出去的数位补到右侧，即11111110→11111101 delay_10us(50000); } for(i = 0;i \u0026lt; 7;i++) { LED_PORT = _cror_(LED_PORT,1);//右移同理 delay_10us(50000); } } } 该程序进一步实现流水灯从左到右再从右到左来回闪烁的效果\n本章完\n","date":"2024-11-09T00:00:00Z","permalink":"https://INKEM.github.io/p/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%AE%9E%E9%AA%8Cep1.%E7%82%B9%E4%BA%AEled/","title":"【51单片机】程序实验Ep1.点亮LED"},{"content":"修复了LaTex内联公式中下划线引起Markdown语法歧义导致公式无法正常显示的bug\n新增樱花背景和动态效果，默认模式为深色\n更改字体为初夏明朝体\nbug解决方法：\nhugo.yaml文件中第227行开始\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 markup: goldmark: extensions: passthrough: enable: true delimiters: block: - - \\[ - \\] - - $$ - $$ inline: - - \\( - \\) 在inline后新增行内分隔符\n1 2 - - $ - $ ","date":"2024-11-08T00:00:00Z","permalink":"https://INKEM.github.io/p/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%96%B0%E5%85%AC%E5%91%8A1/","title":"博客配置更新公告1"},{"content":" 主要参考学习资料及插图来源：\n《机器人学导论（第4版）》John J.Craig著\n台大机器人学之运动学——林沛群\n本章数理基础：矩阵的四则运算\n操作臂（正向）运动学 运动学讨论运动状态本身，不涉及产生运动的力\n连杆的描述 连杆参数 关节（Joint）分为移动关节和旋转关节，每个关节有一个自由度，对一个特定的轴移动或转动\n连杆（Link）为连接关节的杆件，视作刚体\n连杆的编号从固定基座开始，称固定基座为连杆0，第一个可动连杆为连杆1，以此类推，操作臂最末端的连杆为连杆n\n单个连杆：连杆长度和连杆扭转角\n连杆$i-1$连接了关节轴$i-1$和关节轴$i$，关节轴$i-1$和关节轴$i$之间公垂线长度$a_{i-1}$为连杆长度\n作一平面与两关节轴公垂线垂直，关节轴$i-1$和关节轴$i$在该平面上投影的夹角$\\alpha_{i-1}$为连杆扭转角（即空间中两直线夹角的定义） 平面图像表达空间关系可能存在视错觉，需结合文字描述来分析\n多杆串连：连杆偏距和关节角\n关节轴$i$上的两个相邻连杆沿公共轴线方向的距离$d_i$为连杆偏距\n两个相邻连杆绕公共轴线旋转的夹角$\\theta_i$为关节角\n对于首端连杆（固定基座）和末端连杆（末端执行器），习惯设定$a_0=a_n=0$，$\\alpha_0=\\alpha_n=0$\n对于关节$1$，若为转动关节，$\\theta_1$任取，$d_1=0$；若为移动关节，$d_1$任取，$\\theta_1=0$。关节$n$同理 连杆参数\n由此，机器人的每个连杆都可以用上述四个运动学参数来描述\n对于转动关节，$\\theta_i$为关节变量，其他三个连杆参数固定不变；对于移动关节，$d_i$为关节变量，其他三个连杆参数固定不变。这种用连杆参数描述机构运动关系的规则称为Denavit-Hartenberg方法（简称D-H表示法）\n连杆坐标系 中间连杆坐标系\n按以下方法确定连杆上的固连坐标系$\\{i\\}$：\n原点位于公垂线$a_i$与关节轴$i$的交点处\n$\\hat{Z}_i$轴与关节轴$i$重合\n$\\hat{X}_i$轴：当$a_i\\ne0$，沿$a_i$方向由关节$i$指向关节$i+1$；当$a_i=0$，垂直于$\\hat{Z}_i$和$\\hat{Z}_{i+1}$所在的平面\n$\\hat{Y}_i$轴由右手定则确定\n由于$\\hat{Z}_i$轴可选取两个方向，且当关节轴$i$与$i+1$相交时$\\hat{X}_i$轴可选取两个方向，建立的坐标系并不唯一 首末端连杆坐标系\n首端连杆坐标系$\\{0\\}$与关节$1$初始姿态时（关节变量为$0$）的坐标系$\\{1\\}$重合\n末端连杆坐标系$\\{N\\}$原点位于公垂线$a_{N-1}$与关节轴$\\{N\\}$交点处，$\\hat{X}_N$轴与$\\hat{X}_{N-1}$轴同向\n连杆坐标系中的D-H表示法\n$a_i=$沿$\\hat{X}_i$轴从${\\hat{Z}_i}$移动到$\\hat{Z}_{i+1}$的距离\n$\\alpha_i=$绕$\\hat{X}_i$轴从$\\hat{Z}_i$旋转到$\\hat{Z}_{i+1}$的角度\n$d_i=$沿$\\hat{Z}_i$轴从$\\hat{X}_{i-1}$移动到$\\hat{X}_i$的距离\n$\\theta_i=$绕$\\hat{Z}_i$轴从$\\hat{X}_{i-1}$旋转到$\\hat{X}_i$的角度\n$a_i\u003e0$，$\\alpha_i$、$d_i$和$\\theta_i$的值相对于坐标系主轴方向有正负\n建立连杆坐标系的步骤\n1.画出各关节轴的延长线\n2.找出相邻关节轴$i$和$i+1$的公垂线或交点，以关节轴$i$和$i+1$的交点或公垂线与关节轴$i$的交点作为连杆坐标系$\\{i\\}$的原点\n3.规定$\\hat{Z}_i$轴沿关节轴$i$的指向\n4.规定$\\hat{X}_i$轴沿公垂线的指向，若关节轴$i$与$i+1$相交则垂直于关节轴$i$与$i+1$所在的平面\n5.按右手定则确定$\\hat{Y}_i$轴\n6.补充首末端连杆坐标系\n坐标系的标准命名\n基（Base）坐标系$\\{B\\}$位于操作臂的基座上\n固定（Settle）坐标系$\\{S\\}$位置与任务相关，比如工作台的一个角上\n腕部（Wrist）坐标系$\\{W\\}$位于操作臂的末端连杆\n工具（Tool）坐标系$\\{T\\}$位于机器人所夹持工具的末端\n目标（Goal）坐标系$\\{G\\}$是对机器人移动工具到达的位置描述 操作臂运动学 连杆变换（Link Transformation） 我们希望用四个连杆参数建立起相邻连杆坐标系$\\{i\\}$和$\\{i-1\\}$之间的变换关系，即$^{i-1}P=^{i-1}_{i}T^iP$ 我们考虑借由图中标出的四个连杆参数将$\\{i-1\\}$一步步变换为$\\{i\\}$\n将$\\{i-1\\}$绕$\\hat{X}_{i-1}$旋转$\\alpha_{i-1}$得到$\\{R\\}$\n将$\\{R\\}$沿$\\hat{X}_R$平移$a_{i-1}$得到$\\{Q\\}$\n将$\\{Q\\}$绕$\\hat{Z}_Q$旋转$\\theta_i$得到$\\{P\\}$\n将$\\{P\\}$沿$\\hat{Z}_P$平移$d_i$得到$\\{i\\}$\n于是变换矩阵可写成：\n$^{i-1}P=^{i-1}_{i}T^iP=^{i-1}_RT^R_QT^Q_PT^P_iT^iP$\n$^{i-1}_{i}T=^{i-1}_RT^R_QT^Q_PT^P_iT=R_X(\\alpha_{i-1})D_X(a_{i-1})R_Z(\\theta_i)D_Z(d_i)$\n最终计算得到：\n$^{i-1}_{i}T=\\begin{bmatrix}c\\theta_i\u0026-s\\theta_i\u00260\u0026a_{i-1}\\\\s\\theta_ic\\alpha_{i-1}\u0026c\\theta_ic\\alpha_{i-1}\u0026-s\\alpha_{i-1}\u0026-s\\alpha_{i-1}d_i\\\\s\\theta_is\\alpha_{i-1}\u0026c\\theta_is\\alpha_{i-1}\u0026c\\alpha_{i-1}\u0026c\\alpha_{i-1}d_i\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n左上角$3\\times3$为旋转矩阵，最右列为$\\{i\\}$的原点相对于$\\{i-1\\}$的原点的位置矢量\n计算出各个连杆变换矩阵，将其连乘就能得到$\\{N\\}$相对于$\\{0\\}$的变换矩阵：\n$^0_NT=^0_1T^1_2T^2_3T…^{N-1}_NT$\n驱动器空间、关节空间和笛卡尔空间 对一个具有$n$个自由度的操作臂来说，它的所有连杆位置可由一组$n$个关节变量确定，这样的一组变量被称为$n\\times1$的关节向量，所有关节向量组成的空间称为关节空间（Joint Space）\n至此，我们研究的是如何将已知的关节空间描述转化为在笛卡尔空间（Cartesian Space）中的描述，称为正向运动学（Forward Kinematics），反之则为逆运动学（Inverse Kinematics）\n我们一直假设每个运动关节都是直接由某种驱动器驱动，但许多机器人有时用两个驱动器以差动的方式驱动一个关节，有时用直线驱动器通过四连杆机构来驱动旋转关节，而测量操作臂位置的传感器常常安装在驱动器上，因此进行控制器运算时必须把关节向量表示成一组驱动器变量方程，即驱动向量，组成的空间称为驱动器空间（Actuator Space） 本章完\n","date":"2024-11-06T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep3.%E6%93%8D%E4%BD%9C%E8%87%82%E6%AD%A3%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6/","title":"【机器人学导论】Ep3.操作臂（正向）运动学"},{"content":" 主要参考学习资料及插图来源：\n《机器人学导论（第4版）》John J.Craig著\n台大机器人学之运动学——林沛群\n本章前置知识：矢量和矩阵的四则运算-单位矩阵-转置矩阵-逆矩阵-分块矩阵\n空间描述和变换2 复杂姿态描述 上一节我们用旋转矩阵来描述姿态，但仅限于绕其中一个主轴的单自由度旋转，且我们得知姿态描述中包含三个独立变量，接下来我们讨论如何用三个参数描述空间中的任意姿态\n任何三自由度的旋转都可以拆解成三个单自由度的旋转，由于旋转不满足交换律，所以多次旋转的先后顺序需要明确定义。而旋转转轴也需要明确定义，围绕方向固定不动的参考坐标系主轴旋转的拆解方式称为固定角（Fixed Angles），围绕转动坐标系当下的主轴旋转的拆解方式称为欧拉角（Euler Angles）\nX-Y-Z固定角 给定参考坐标系$\\{A\\}$和我们要描述姿态的坐标系$\\{B\\}$，从固定角的视角来看，任意姿态的$\\{B\\}$都可以由以下过程表示：将$\\{B\\}$与$\\{A\\}$重合，先绕$\\hat{X}_A$旋转$\\gamma$角，再绕$\\hat{Y}_A$旋转$\\beta$角，最后绕$\\hat{Z}_A$旋转$\\alpha$角得到最终的$\\{B\\}$，因而可以推导$\\{B\\}$到$\\{A\\}$的等价旋转矩阵：$^A_BR_{XYZ}(\\gamma,\\beta,\\alpha)=R_Z(\\alpha)R_Y(\\beta)R_X(\\gamma)=\\begin{bmatrix}c\\alpha\u0026-s\\alpha\u00260\\\\s\\alpha\u0026c\\alpha\u00260\\\\0\u00260\u00261\\end{bmatrix}\\begin{bmatrix}c\\beta\u00260\u0026s\\beta\\\\0\u00261\u00260\\\\-s\\beta\u00260\u0026c\\beta\\end{bmatrix}\\begin{bmatrix}1\u00260\u00260\\\\0\u0026c\\gamma\u0026-s\\gamma\\\\0\u0026s\\gamma\u0026c\\gamma\\end{bmatrix}$\n（矩阵书写顺序与实际旋转操作顺序相反，从旋转一个矢量的角度来看，是因为旋转矩阵乘在矢量的左边，所以右侧的矩阵会先与矢量相乘）\n(等价旋转矩阵下标表示绕主轴旋转的操作顺序，可以根据实际情况调换)\n最终得到：\n$^A_BR_{XYZ}(\\gamma,\\beta,\\alpha)=\\begin{bmatrix}c\\alpha c\\beta\u0026c\\alpha c\\beta s\\gamma-s\\alpha c\\gamma\u0026c\\alpha s\\beta c\\gamma+s\\alpha s\\gamma\\\\s\\alpha c\\beta\u0026s\\alpha s\\beta s\\gamma+c\\alpha c\\gamma\u0026s\\alpha s\\beta c\\gamma-c\\alpha s\\gamma\\\\-s\\beta\u0026c\\beta s\\gamma\u0026c\\beta c\\gamma\\end{bmatrix}$①\n反过来，如果已知旋转矩阵各个元素的数值，逆求三个固定角，令\n$^A_BR_{XYZ}(\\gamma,\\beta,\\alpha)=\\begin{bmatrix}r_{11}\u0026r_{12}\u0026r_{13}\\\\r_{21}\u0026r_{22}\u0026r_{23}\\\\r_{31}\u0026r_{32}\u0026r_{33}\\end{bmatrix}$\n则\n$\\left\\{\\begin{matrix}\\beta=\\mathrm{Atan2}(-r_{31},\\sqrt{r_{11}^2+r_{21}^2})\\\\ \\alpha=\\mathrm{Atan2}(\\frac{r_{21}}{c\\beta},\\frac{r_{11}}{c\\beta})\\\\ \\gamma=\\mathrm{Atan2}(\\frac{r_{31}}{c\\beta},\\frac{r_{33}}{c\\beta})\\end{matrix}\\right.$\n$(\\beta\\neq 90^{\\circ})$\n（式中$\\mathrm{Atan2}(y,x)=arctan\\frac{y}{x}$，即反正切函数的双参量表示法，可以根据$x$和$y$的符号判别角的象限，而单输入值的反正切函数无法区分）\n上式中$\\cos\\beta$只考虑正根以得到单解来建立各种姿态表示法之间一一对应的映射函数，但在某些情况下有必要求出所有的解，会在第四章说明\n如果$\\beta=90^{\\circ}$，则只能求出$\\alpha$和$\\gamma$的和或差，在这种情况下一般取$\\alpha=0$，$\\gamma=\\left\\{\\begin{matrix}\\mathrm{Atan2}(r_{12},r_{22})(\\beta=90^{\\circ})\\\\-\\mathrm{Atan2}(r_{12},r_{22})(\\beta=-90^{\\circ})\\end{matrix}\\right.$\n结合式①即可理解求解公式的推导\nZ-Y-X欧拉角 给定参考坐标系$\\{A\\}$和我们要描述姿态的坐标系$\\{B\\}$，从欧拉角的视角来看，任意姿态的$\\{B\\}$都可以由以下过程表示：将$\\{B\\}$与$\\{A\\}$重合，先绕$\\hat{Z}_B$转$\\alpha$角得到$\\{B'\\}$，再绕$\\hat{Y}_{B'}$转$\\beta$角得到$\\{B''\\}$，最后绕$\\hat{X}_{B''}$转$\\gamma$角得到最终的$\\{B\\}$（欧拉角选取转轴的顺序与固定角相反，原因会在下面解释）\n借由$\\{B\\}$的中间状态$\\{B'\\}$和$\\{B''\\}$和欧拉角的定义表达$^A_BR$，我们可以写出：\n$^A_BR=^A_{B'}R^{B'}_{B''}R^{B''}_{B}R$\n即：\n$^A_BR_{X'Y'Z'}(\\gamma,\\beta,\\alpha)=R_{Z'}(\\alpha)R_{Y'}(\\beta)R_{X'}(\\gamma)=\\begin{bmatrix}c\\alpha\u0026-s\\alpha\u00260\\\\s\\alpha\u0026c\\alpha\u00260\\\\0\u00260\u00261\\end{bmatrix}\\begin{bmatrix}c\\beta\u00260\u0026s\\beta\\\\0\u00261\u00260\\\\-s\\beta\u00260\u0026c\\beta\\end{bmatrix}\\begin{bmatrix}1\u00260\u00260\\\\0\u0026c\\gamma\u0026-s\\gamma\\\\0\u0026s\\gamma\u0026c\\gamma\\end{bmatrix}$\n相乘后得：\n$^A_BR_{X'Y'Z'}(\\gamma,\\beta,\\alpha)=\\begin{bmatrix}c\\alpha c\\beta\u0026c\\alpha c\\beta s\\gamma-s\\alpha c\\gamma\u0026c\\alpha s\\beta c\\gamma+s\\alpha s\\gamma\\\\s\\alpha c\\beta\u0026s\\alpha s\\beta s\\gamma+c\\alpha c\\gamma\u0026s\\alpha s\\beta c\\gamma-c\\alpha s\\gamma\\\\-s\\beta\u0026c\\beta s\\gamma\u0026c\\beta c\\gamma\\end{bmatrix}$\n我们发现，这个结果与以相反顺序绕固定轴旋转三次得到的结果完全相同，因而逆求解公式也相同\n可以这样更深地理解固定角与欧拉角之间的关系：两种姿态描述方法不同的解释在于运用了旋转矩阵两种不同的作用，一是在同一个坐标系下旋转矢量，二是将矢量的坐标在不同坐标系之间变换。固定角是用前者描述$\\{A\\}$的三个主轴矢量旋转到$\\{B\\}$的过程，而欧拉角是用后者将在$\\{B\\}$下的主轴矢量坐标一步步借由中间坐标系变换到$\\{A\\}$\n其他转角组合 在实际情况我们会遇到更多按不同顺序进行绕主轴的三个旋转，所有排列总共24种，固定角12种，欧拉角12种，都被称为转交排列设定法（需要注意第一次转动和最后一次转动绕同一个主轴也是一种排列，只要保证相邻两次切换围绕的主轴即可）\n除此之外，姿态描述还有轴角表示法和四元数表示法，完全解释篇幅较长，若有余力我会写拓展专题\n映射（Mapping） 映射是将矢量从一个坐标系投影到另一个坐标系的变换\n坐标平移 我们用矢量$^AP_{BORG}$表示$\\{B\\}$的原点相对于$\\{A\\}$的位置\n当$\\{A\\}$与$\\{B\\}$姿态相同，位置不同时，由矢量加法的几何意义：\n$^AP=^BP+^AP_{BORG}$\n坐标旋转 当$\\{A\\}$与$\\{B\\}$位置相同，姿态不同时，由上一篇所介绍的旋转矩阵转换矢量坐标的作用：\n$^AP=^A_BR^BP$\n一般变换 当$\\{A\\}$与$\\{B\\}$位置和姿态都不同时，可以先将$\\{B\\}$旋转到和$\\{A\\}$相同的姿态得到$\\{B'\\}$，以$\\{B'\\}$为中间坐标系对$^BP$进行旋转变换，再作$\\{B'\\}$到$\\{A\\}$的平移变换：\n$^AP=^A_BR^BP+^AP_{BORG}$②\n为了简化算式，我们将平移和旋转整合起来，定义齐次变换矩阵：\n$^A_BT=\\begin{bmatrix}^A_BR\u0026^AP_{BORG}\\\\\\mathbf{0}^T\u00261\\end{bmatrix}$\n其中$\\mathbf{0}^T$表示三维零向量的转置\n这样式②可写为：\n$\\begin{bmatrix}^AP\\\\1\\end{bmatrix}=\\begin{bmatrix}^A_BR\u0026^AP_{BORG}\\\\\\mathbf{0}^T\u00261\\end{bmatrix}\\begin{bmatrix}^BP\\\\1\\end{bmatrix}$\n这样我们就以一个简单的矩阵形式表示了一般变换的旋转和平移\n复合变换 复合变换借用中间坐标系求解两坐标系的相对关系\n例如已知$\\{C\\}$相对于$\\{B\\}$，并且已知$\\{B\\}$相对于$\\{A\\}$，已知$^CP$求$^AP$，可先将$^CP$变换成$^BP$再变换成$^AP$：\n$^BP=^B_CT^CP$\n$^AP=^A_BT^BP=^A_BT^B_CT^CP$\n由此定义$^A_CP=^A_BT^B_CT$\n逆变换 已知$^A_BT$求$^B_AT$可以直接对$^A_BT$求逆矩阵，但还可以利用变换的性质\n关于$^B_AT$的旋转变换，由旋转矩阵的性质可知$^B_AR=^A_BR^T$\n关于$^B_AT$的平移变换，将$^AP_{BORG}$变换成$\\{B\\}$中的描述：$^B(^AP_{BORG})=^B_AT^AP_{BORG}=^B_AR^AP_{BORG}+^BP_{AORG}$\n上式左侧为零，可得：$^BP_{AORG}=-^B_AR^AP_{BORG}=-^A_BR^T{}^AP_{BORG}$\n由此$^B_AT=\\begin{bmatrix}^B_AR^T\u0026-^A_BR^T{}^AP_{BORG}\\\\\\mathbf{0}^T\u00261\\end{bmatrix}=^A_BT^{-1}$\n变换方程 图中$\\{D\\}$可以用两种不同的方式表达成变换相乘的方式：\n$^U_DT=^U_AT^A_DT$\n$^U_DT=^U_BT^B_CT^C_DT$\n两个表达式构造成一个变换方程：\n$^U_AT^A_DT=^U_BT^B_CT^C_DT$\n如有$n$个未知变换和$n$个变换方程，变换可由变换方程解出。设上式中所有变换除了$^B_CT$外均已知，可解出：\n$^B_CT=^U_BT^{-1}{}^U_AT^A_DT^C_DT^{-1}$\n算子（Operator） 算子是对矢量进行平移和旋转操作的变换\n$^A_BT$除了变换以外，也可以充当算子对矢量或点进行平移或转动\n平移算子 将$^AP_1$指向的点沿$^AQ$进行平移得到一个新的矢量$^AP_2$，计算如下：\n$^AP_2=^AP_1+^AQ$\n用矩阵算子写出平移变换，有：\n$^AP_2=D(Q)^AP_1$\n算子$D_Q$可以被看成是一个特殊形式的齐次变换：\n$D(Q)=\\begin{bmatrix}I\u0026^AQ\\\\\\mathbf{0}^T\u00261\\end{bmatrix}$\n旋转算子 由上一篇所介绍的旋转矩阵描述刚体转动状态的作用，可以得到旋转算子的定义：将矢量$^AP_1$用旋转$R$变换成一个新的矢量$^AP_2$\n当一个旋转矩阵作为算子时无需写出上下标，因为不涉及两个坐标系，但我们将用另一个符号说明是绕哪个轴旋转的，写成：\n$^AP_2=R_K(\\theta)^AP_1$\n符号$R_K(\\theta)$是一个旋转算子，表示绕$\\hat{K}$轴旋转$\\theta$角度，例如绕$\\hat{Z}$轴旋转$\\theta$的算子：\n$R_z(\\theta)=\\begin{bmatrix}c\\theta\u0026-s\\theta\u00260\u00260\\\\s\\theta\u0026c\\theta\u00260\u00260\\\\0\u00260\u00261\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n变换算子 与一般变换一样，将平移和旋转整合起来我们得到通用的变换算子。因为只涉及一个坐标系，所以没有上下标。算子$T$将矢量$^AP_1$平移并旋转得到一个新矢量：$^AP_2=T^AP_1$\n齐次变换矩阵 源于旋转矩阵在上一篇所讲的三个作用，在这一篇我们也探索出了齐次变换矩阵的三个作用：\n1.描述位姿：$^A_BT$表示$\\{B\\}$相对于$\\{A\\}$，其中$^A_BR$的各列是定义$\\{B\\}$主轴方向的单位矢量，$^AP_{BORG}$确定了$\\{B\\}$的原点\n2.变换映射：$^A_BT$是映射$^BP\\rightarrow^AP$\n3.变换算子：$^A_BT$将$^AP_1$变换为$^AP_2$\n本章我们只考虑了位置矢量的变换，而速度矢量和力矢量由于类型不同，它们的变换形式也不同，将在第五章讨论\n本章完\n","date":"2024-11-03T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep2.2.%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%8F%98%E6%8D%A2-2/","title":"【机器人学导论】Ep2.2.空间描述和变换-2"},{"content":" 主要参考学习资料：\n《机器人学导论（第4版）》John J.Craig著\n台大机器人学之运动学——林沛群（本文插图来自该课程课件）\n本章前置知识：矢量和矩阵的四则运算-单位矩阵-转置矩阵-逆矩阵-正交矩阵\n空间描述和变换 描述 我们用$\\{A\\}$来表示一个坐标系(Frame)\n讨论问题之前，我们需要建立一个世界坐标系(World Frame)，之后定义的位置和姿态都是参照世界坐标系定义的笛卡尔坐标系\n一个平面中的物体拥有沿$x$轴、$y$轴两个方向移动的自由度和绕垂直于平面的轴转动的自由度（Degree Of Freedom，可简记为DOF），即两个移动自由度和一个转动自由度，共三个自由度\n同理，一个空间中的物体拥有沿$x$轴、$y$轴、$z$轴三个方向移动的自由度和绕这三个轴转动的自由度，即三个移动自由度和三个转动自由度，共六个自由度\n位置描述 位置描述涵盖刚体在三个方向上的移动自由度\n一旦建立了坐标系，我们可以用一个$3\\times 1$的位置矢量给世界坐标系中的任何点定位\n矢量用一个左上标来表明其定义在哪个坐标系，例如$^AP$的元素数值是沿坐标系$\\{A\\}$三个主轴方向上的投影，矢量的各个元素用下标$x$、$y$和$z$来标明：\n$^AP=^A\\begin{bmatrix}p_x\\\\p_y\\\\p_z\\end{bmatrix}$\n（其中矩阵左上标表示矩阵中坐标都是相对于该坐标系而言，由于格式输入限制位置偏下）\n姿态描述 姿态描述涵盖刚体三个方向上的转动自由度\n我们可以在刚体上固定一个坐标系$\\{B\\}$，用$\\{B\\}$相对于$\\{A\\}$的描述来表示物体的姿态，而$\\{B\\}$可以用该坐标系三个主轴方向的单位矢量来确定\n我们用$\\hat{X}_B$、$\\hat{Y}_B$和$\\hat{Z}_B$来表示$\\{B\\}$主轴方向的单位矢量，当$\\{A\\}$作为参考坐标系时，它们被写为$^A\\hat{X}_B$、$^A\\hat{Y}_B$和$^A\\hat{Z}_B$\n将这三个单位矢量按照$^A\\hat{X}_B$、$^A\\hat{Y}_B$和$^A\\hat{Z}_B$的顺序排列组成一个$3\\times3$的矩阵，称为旋转矩阵(Rotation Matrix)。表达$\\{B\\}$相对于$\\{A\\}$的旋转矩阵记为$_B^AR$\n$_B^AR$=$\\begin{pmatrix}^A\\hat{X}_B\u0026^A\\hat{Y}_B\u0026^A\\hat{Z}_B\\end{pmatrix}$\n又$^A\\hat{X}_B$、$^A\\hat{Y}_B$和$^A\\hat{Z}_B$是以$\\{A\\}$为参考，所以矢量中各个元素的数值为$\\hat{X}_B$、$\\hat{Y}_B$和$\\hat{Z}_B$分别在$\\{A\\}$三个主轴方向上的投影长度，因而上式可以进一步写为\n$_B^AR=\\begin{pmatrix}^A\\hat{X}_B\u0026^A\\hat{Y}_B\u0026^A\\hat{Z}_B\\end{pmatrix}=\\begin{bmatrix}\\hat{X}_B\\cdot\\hat{X}_A\u0026\\hat{Y}_B\\cdot\\hat{X}_A\u0026\\hat{Z}_B\\cdot\\hat{X}_A\\\\\\hat{X}_B\\cdot\\hat{Y}_A\u0026\\hat{Y}_B\\cdot\\hat{Y}_A\u0026\\hat{Z}_B\\cdot\\hat{Y}_A\\\\\\hat{X}_B\\cdot\\hat{Z}_A\u0026\\hat{Y}_B\\cdot\\hat{Z}_A\u0026\\hat{Z}_B\\cdot\\hat{Z}_A\\end{bmatrix}$\n又矩阵中各个矢量均为单位矢量，点积之值也是$\\hat{X}_B$、$\\hat{Y}_B$和$\\hat{Z}_B$对于$\\{A\\}$的方向余弦，该矩阵又称为方向余弦矩阵(Direction Cosine Matrix)\n综上，我们用旋转矩阵描述了刚体的姿态\n旋转矩阵 接下来重点介绍旋转矩阵的性质与作用\n性质 将旋转矩阵中各个点积前后矢量互换，我们有如下推导（其中右上标T为转置符号）：\n$_B^AR=\\begin{pmatrix}^A\\hat{X}_B\u0026^A\\hat{Y}_B\u0026^A\\hat{Z}_B\\end{pmatrix}=\\begin{bmatrix}\\hat{X}_B\\cdot\\hat{X}_A\u0026\\hat{Y}_B\\cdot\\hat{X}_A\u0026\\hat{Z}_B\\cdot\\hat{X}_A\\\\\\hat{X}_B\\cdot\\hat{Y}_A\u0026\\hat{Y}_B\\cdot\\hat{Y}_A\u0026\\hat{Z}_B\\cdot\\hat{Y}_A\\\\\\hat{X}_B\\cdot\\hat{Z}_A\u0026\\hat{Y}_B\\cdot\\hat{Z}_A\u0026\\hat{Z}_B\\cdot\\hat{Z}_A\\end{bmatrix}$ $=\\begin{bmatrix}\\hat{X}_A\\cdot\\hat{X}_B\u0026\\hat{X}_A\\cdot\\hat{Y}_B\u0026\\hat{X}_A\\cdot\\hat{Z}_B\\\\\\hat{Y}_A\\cdot\\hat{X}_B\u0026\\hat{Y}_A\\cdot\\hat{Y}_B\u0026\\hat{Y}_A\\cdot\\hat{Z}_B\\\\\\hat{Z}_A\\cdot\\hat{X}_B\u0026\\hat{Z}_A\\cdot\\hat{Y}_B\u0026\\hat{Z}_A\\cdot\\hat{Z}_B\\end{bmatrix}=\\begin{bmatrix}\\hat{X}_A{^T}\\\\\\hat{Y}_A{^T}\\\\\\hat{Z}_A{^T}\\end{bmatrix}$$=\\begin{pmatrix}^A\\hat{X}_B\u0026^A\\hat{Y}_B\u0026^A\\hat{Z}_B\\end{pmatrix}^T=^B_AR^T$\n由此$^A_BR=^B_AR^T$\n又由：\n$^A_BR{^T}^A_BR=\\begin{bmatrix}\\hat{X}_A{^T}\\\\\\hat{Y}_A{^T}\\\\\\hat{Z}_A{^T}\\end{bmatrix}\\begin{pmatrix}^A\\hat{X}_B\u0026^A\\hat{Y}_B\u0026^A\\hat{Z}_B\\end{pmatrix}=I_3$\n其中$I_3$是$3\\times3$的单位矩阵，因此：\n$^A_BR=^B_AR^{-1}=^B_AR{^T}$\n即$^B_AR$的转置矩阵等于它的逆矩阵，又同时等于$^A_BR$。由线性代数可知，前者是正交矩阵的性质\n旋转矩阵有九个数字，但只有三个矢量两两垂直、均为单位矢量总共六个条件约束，因此只有三个数字是独立变量，与空间中转动具有三个自由度相符\n作用 除了前文所讲的描述一个刚体的姿态外，旋转矩阵还有两个作用\n1.转换矢量的坐标\n矢量$P$相对于$\\{B\\}$的坐标表示：$^BP=^Bp_x\\hat{X}_B+^Bp_y\\hat{Y}_B+^Bp_z\\hat{Z}_B$\n矢量$P$相对于$\\{A\\}$的坐标表示：$^AP=^Ap_x\\hat{X}_A+^Ap_y\\hat{Y}_A+^Ap_z\\hat{Z}_A$\n$^BP$和$^AP$只是坐标表示不同，本质上是同一个矢量，由此矢量$P$相对于$\\{A\\}$的坐标也可以用$^BP$在$\\{A\\}$三个主轴上的投影计算：\n$^Ap_x=^BP\\hat{X}_A=^Bp_x\\hat{X}_B\\hat{X}_A+^Bp_y\\hat{Y}_B\\hat{X}_A+^Bp_z\\hat{Z}_B\\hat{X}_A$\n$^Ap_y=^BP\\hat{Y}_A=^Bp_x\\hat{X}_B\\hat{Y}_A+^Bp_y\\hat{Y}_B\\hat{Y}_A+^Bp_z\\hat{Z}_B\\hat{Y}_A$\n$^Ap_z=^BP\\hat{X}_A=^Bp_x\\hat{X}_B\\hat{Z}_A+^Bp_y\\hat{Y}_B\\hat{Z}_A+^Bp_z\\hat{Z}_B\\hat{Z}_A$\n用矩阵表示则为：\n$^AP=^A\\begin{bmatrix}p_x\\\\p_y\\\\p_z\\end{bmatrix}=\\begin{bmatrix}\\hat{X}_B\\cdot\\hat{X}_A\u0026\\hat{Y}_B\\cdot\\hat{X}_A\u0026\\hat{Z}_B\\cdot\\hat{X}_A\\\\\\hat{X}_B\\cdot\\hat{Y}_A\u0026\\hat{Y}_B\\cdot\\hat{Y}_A\u0026\\hat{Z}_B\\cdot\\hat{Y}_A\\\\\\hat{X}_B\\cdot\\hat{Z}_A\u0026\\hat{Y}_B\\cdot\\hat{Z}_A\u0026\\hat{Z}_B\\cdot\\hat{Z}_A\\end{bmatrix}^B\\begin{bmatrix}p_x\\\\p_y\\\\p_z\\end{bmatrix}=^A_BR^BP$\n由此得到$\\{B\\}$相对于$\\{A\\}$的旋转矩阵可以将$P$的表示由相对于$\\{B\\}$转换为相对于$\\{A\\}$\n2.描述刚体转动的状态\n分别研究坐标系绕三个主轴旋转的状态\n以$\\{A\\}$绕$\\hat{Z}_A$逆时针旋转$\\theta$（以后不标明旋转方向默认为逆时针旋转）得到$\\{B\\}$为例，计算此时$\\{B\\}$相对于$\\{A\\}$的旋转矩阵得：\n$^A_BR=\\begin{bmatrix}\\cos\\theta\u0026-\\sin\\theta\u00260\\\\\\sin\\theta\u0026\\cos\\theta\u00260\\\\0\u00260\u00261\\end{bmatrix}=\\begin{bmatrix}c\\theta\u0026-s\\theta\u00260\\\\s\\theta\u0026c\\theta\u00260\\\\0\u00260\u00261\\end{bmatrix}$\n（由于我们将在计算中用到许多三角函数，因此三角函数用对应首字母简记）\n由此，我们将绕$\\hat{Z}_A$旋转$\\theta$以这种方式计算出来的旋转矩阵记为$R_{\\hat{Z}_A}(\\theta)$，则：\n$R_{\\hat{Z}_A}(\\theta)=\\begin{bmatrix}c\\theta\u0026-s\\theta\u00260\\\\s\\theta\u0026c\\theta\u00260\\\\0\u00260\u00261\\end{bmatrix}$\n同理得到：\n$R_{\\hat{X}_A}(\\theta)=\\begin{bmatrix}1\u00260\u00260\\\\0\u0026c\\theta\u0026-s\\theta\\\\0\u0026s\\theta\u0026c\\theta\\end{bmatrix}$\n$R_{\\hat{Y}_A}(\\theta)=\\begin{bmatrix}c\\theta\u00260\u0026s\\theta\\\\0\u00261\u00260\\\\-s\\theta\u00260\u0026c\\theta\\end{bmatrix}$\n通过接下来的例子我们来理解这类旋转矩阵如何描述刚体转动的状态\n$^AP=^A(p_x\\;p_y\\;p_z)^T$对$\\hat{X}_A$旋转$\\theta$得到$^AP'$，$^AP'=?$\n不妨让$\\{A\\}$跟着$^AP$同步旋转，得到$\\{A'\\}$，那么$^AP'$相对于$\\{A'\\}$的坐标跟$^AP$相对于$\\{A\\}$的坐标相等，而后者已知\n又通过题目条件和前文定义我们知道$^A_{A'}R=R_{\\hat{X}_A}(\\theta)=\\begin{bmatrix}1\u00260\u00260\\\\0\u0026c\\theta\u0026-s\\theta\\\\0\u0026s\\theta\u0026c\\theta\\end{bmatrix}$\n利用旋转矩阵转换矢量坐标的作用，我们可以把$^AP'$相对于$\\{A'\\}$的坐标转换为相对于原坐标系$\\{A\\}$的坐标，即：\n$^AP'=^A_{A'}R^AP=R_{\\hat{X}_A}(\\theta)^AP$\n所以旋转矩阵$R(\\theta)$可以计算矢量在同一坐标系下旋转后的坐标\n位姿描述 位置和姿态的组合称为位姿\n我们同样用$\\{A\\}$来表示一个位姿\n以$\\{A\\}$为参考描述位姿$\\{B\\}$，结合前文的位置描述和姿态描述，我们用$^A_BR$表示$\\{B\\}$的姿态，用$^AP_{BORG}$表示$\\{B\\}$的原点的位置矢量（下标ORG意为原点origin），于是位姿描述记为：\n$\\{B\\}=\\{^A_BR,{\\,}^AP_{BORG}\\}$\n下一篇文章将讲述本章后半部分空间中的变换内容\n","date":"2024-11-01T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep2.1.%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%8F%98%E6%8D%A2-1/","title":"【机器人学导论】Ep2.1.空间描述和变换-1"},{"content":" 主要参考学习资料：\n《机器人学导论（第4版）》John J.Craig著\n台大机器人学之运动学——林沛群\n前置课程：博主目前只对线性代数和理论力学方面有一定基础，学习过程中遇到额外必要的前置知识我会做补充或者开辟新的知识笔记专栏\n概述 本章简要介绍机器人学导论中的基础名词和学习内容，具体内容将在后续展开\n知识体系 本知识笔记以《机器人学导论》一书为主，书中内容结构如下：\n第1章 概述\n第2章 空间描述和变换\n第3章 操作臂运动学\n第4章 操作臂逆运动学\n第5章 雅可比：速度和静力\n第6章 操作臂动力学\n第7章 轨迹生成\n第8章 操作臂的机构设计\n第9章 操作臂的线性控制\n第10章 操作臂的非线性控制\n第11章 操作臂的力控制\n第12章 机器人编程语言及编程系统\n第13章 离线编程系统\n操作臂的力学与控制 在机器人领域，机械臂（操作臂）是起步最早、现今最成熟的技术，而机器人学知识也跟随此路线发展而来，因此对机器人知识的学习从机械臂开始\n以下内容将按顺序在书中后面12个章节一一讨论\n位置和姿态的描述 研究机器人学需要考虑三维空间中物体的空间状态，可以用两个重要特性描述：位置和姿态\n为了用数学方法表示和计算这些参量，我们一般在物体上设置一个坐标系（位姿），然后在某个参考坐标系中描述该位姿的位置和姿态\n任意位姿都能用作参考坐标系，因此我们经常将物体空间属性的描述从一个位姿变换到另一个位姿 操作臂正运动学 运动学研究物体的运动而不考虑引起这种运动的力，操作臂运动学的研究对象为运动的全部几何和时间特性（位置、速度、加速度和位置变量对于其他变量的高阶微分）\n大部分操作臂由刚性连杆组成，相邻连杆由关节连接，允许相对转动\n如果是转动关节，两个相邻连杆的相对位移被称为关节角；如果是滑（移）动关节，位移被称为关节偏移量\n操作臂自由度的个数是使操作臂具有确定运动时必须给出的独立运动的数目，或操作臂独立驱动的关节数\n组成操作臂运动链的自由端称为末端执行器，通常采用末端执行器上的工具坐标系相对于操作臂固定底座的基坐标系来描述操作臂的位置\n正运动学根据已知的各个关节的关节角计算末端执行器的位置和姿态，这个过程被称为从关节空间描述到笛卡尔空间描述的操作臂位置表示\n笛卡尔空间：用三个变量描述空间一点的位置，用另外三个变量描述物体的姿态\n操作臂逆运动学 逆运动学根据给定的末端执行器的位置和姿态计算所有关节可达到给定位置和姿态的关节角\n逆运动学计算涉及的运动学方程的解的存在性定义了操作臂的工作空间 （末端执行器活动范围） 速度，静力，奇异点 除了静态定位问题，对于运动中的操作臂，我们定义雅可比矩阵来方便地进行机构的速度分析\n雅可比矩阵定义了从关节空间速度向笛卡尔空间速度的映射\n在奇异点，这种映射不可逆（给定的末端执行器的运动状态超出了关节运动能力的限制），同时某些关节的运动可能无法引起末端执行器的有效运动，称为局部退化\n当操作臂接触工件或工作面，并施加一个静力，需要解决如何设定关节力矩来产生要求的接触力和力矩\n动力学 动力学研究产生运动所需要的力\n控制操作臂末端执行器的运动速度需要关节驱动器产生一组复杂的扭矩函数来实现，取决于末端执行器的运动路径和速度、连杆的质量特性和负载、关节摩擦等，扭矩函数通过操作臂动力学方程来求解，用于操作臂的控制和仿真\n轨迹生成 计算每个关节运动的连续函数来平稳控制操作臂从一点运动到另外一点的过程为轨迹生成\n操作臂从起点到目标点需要确定一些中间路径点，通过一系列路径点的连续函数被称为样条函数\n笛卡尔轨迹生成将末端执行器的期望运动转化为一系列等效的关节运动 操作臂设计与传感器 为特定任务设计的机器人为专用机器人，能够完成各种任务的为通用机器人。从经济角度考虑，操作臂的机械设计由期望执行的任务决定，设计者需考虑几何尺寸、速度、承载能力、关节的数量与几何布局等因素，这些因素影响了操作臂工作空间的大小和性质、操作臂结构的刚度以及其他属性\n完整的操作臂设计还包括：驱动器的选择和位置、传动系统以及内部位置传感器（有时是力传感器）\n线性位置控制 位置控制系统不仅包括理想状态下产生期望运动的力矩的计算，更要考虑自动补偿由于系统参数引起的误差以及抑制引起系统偏离期望轨迹的扰动。为此，通过控制算法对位置和速度传感器进行检测，计算出驱动器的扭矩指令。第9章讨论基于操作臂动力学的线性近似得出的控制算法\n非线性位置控制 考虑操作臂完整的非线性动力学的非线性控制算法，比简单的线性控制方法性能更好\n力控制 当操作臂在自由空间中运动时，只有位置控制有意义\n当接触零件、工具或工作表面时，操作臂控制力的能力极其重要\n当操作臂在部分方向受到作用表面约束时，需要采用混合控制方式，在某些方向用位置控制规律来控制，而其余方向用力控制规律来控制\n机器人编程 机器人编程语言是用户和工业机器人交互的接口\n操作者指定操作臂末端执行器的一个特殊点为操作点，也叫TCP（工具中心点）\n通过一系列路径点确定路径，同时确定不同路径段上TCP的速度，依据这些输入，轨迹生成算法规划处机器人运动的所有细节。轨迹生成的输入问题由机器人编程语言的指令来给出\n离线编程与仿真 离线编程系统是一种机器人编程环境，可以在不需要机器人停机的状态下对机器人进行编程，也可以在没有做出机器人实物的情况下对机器人设计进行仿真\n本章完\n","date":"2024-10-30T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep1.%E6%A6%82%E8%BF%B0/","title":"【机器人学导论】Ep1.概述"}]