[{"content":"雅可比：速度和静力 时变位置和姿态的符号表示 速度矢量 速度矢量是位置矢量的导数\n$^BV_Q=\\frac{\\mathrm{d}}{\\mathrm{d}t}^BP_Q=\\lim_{\\Delta t\\rightarrow0}\\frac{^BP_Q(t+\\Delta t)-^BP_Q(t)}{\\Delta t}$\n像其他矢量一样，速度矢量能在任意坐标系中描述，其参考坐标系用左上标注明，如果将$^BV_Q$在$\\{A\\}$下表示，可以写为：\n$^A(^BV_Q)=^A(\\frac{\\mathrm{d}}{\\mathrm{d}t}^BP_Q)=^A_BR^BV_Q$\n我们经常讨论一个坐标系原点相对于某个世界参考坐标系的速度，而不考虑相对于任意坐标系中一般的点的速度，对此定义一个缩写符号：\n$\\upsilon_C=^UV_{CORG}$\n式中的点为$\\{C\\}$的原点，参考坐标系为$\\{U\\}$\n角速度矢量 角速度矢量$^A\\Omega_B$描述了$\\{B\\}$相对于$\\{A\\}$的旋转，$^A\\Omega_B$的方向为$\\{B\\}$相对于$\\{A\\}$的瞬时旋转轴，大小表示旋转速率，即$^A\\Omega_B=\\dot{\\theta}\\hat{K}$\n像其他矢量一样，角速度矢量能在任意坐标系中描述，其参考坐标系用左上标注明，$^C(^A\\Omega_B)$就是$\\{B\\}$相对于$\\{A\\}$的角速度在$\\{C\\}$中的描述\n对于参考坐标系已知的简单情况，我们也定义一个缩写符号：\n$\\omega_C=^U\\Omega_C$\n刚体的线速度和角速度 线速度 把$\\{B\\}$固连在一刚体上，要求描述$^BQ$相对于固定坐标系$\\{A\\}$的运动\n根据绝对速度等于相对速度加牵连速度，我们得到：\n$^AV_Q=^AV_{BORG}+^A(^BV_Q)=^AV_{BORG}+^A_BR^BV_Q$\n上式只适用于$\\{A\\}$和$\\{B\\}$姿态保持不变的情况\n角速度 现在讨论$\\{B\\}$相对于$\\{A\\}$以$^A\\Omega_B$旋转，且原点始终保持重合、相对线速度为零的情况\n先假设$^BV_Q=0$，根据线速度矢量等于角速度矢量叉乘位置矢量，有：\n$^AV_Q=^A\\Omega_B\\times^AQ$\n再考虑$^BV_Q\\neq0$，加上此速度分量，得：\n$^AV_Q=^A(^BV_Q)+^A\\Omega_B\\times^AQ=^A_BR^BV_Q+^A\\Omega_B\\times^A_BR^BQ$\n联立线速度和角速度 将上式扩展到$\\{B\\}$原点运动的情况，将牵连速度加上得：\n$^AV_Q=^AV_{BORG}+^A_BR^BV_Q+^A\\Omega_B\\times^A_BR^BQ$\n这就是相对于$\\{A\\}$的$\\{B\\}$中的固定矢量的速度普遍公式\n机器人连杆的运动 在考虑机器人连杆运动时，一般以$\\{0\\}$为参考坐标系，因此连杆坐标系$\\{i\\}$的线速度为$v_i$，角速度为$\\omega_i$\n我们先研究一对相邻连杆的线速度与角速度在各自坐标系的表达之间的关系（注意与相对速度的概念区分开来，此处是绝对速度矢量在不同坐标系下的描述），即$^iv_i$、$^i\\omega_i$与$^{i+1}v_{i+1}$、$^{i+1}\\omega_{i+1}$之间的关系\n当两个角速度矢量都是相对于相同的坐标系时，那么这些角速度能够相加，所以连杆$i+1$的角速度等于连杆$i$的角速度加上一个由于关节$i+1$的角速度引起的分量\n$^i\\omega_{i+1}=^i\\omega_i+^i_{i+1}R\\dot{\\theta}_{i+1}\\hat{Z}_{i+1}$\n其中$\\dot{\\theta}_{i+1}\\hat{Z}_{i+1}=^{i+1}\\begin{bmatrix}0\\\\0\\\\\\hat{\\theta}_{i+1}\\end{bmatrix}$，旋转矩阵将其转换为在$\\{i\\}$下的表达\n上式两边同乘$^{i+1}_{i}R$，可以得到连杆$i+1$的角速度相对于$\\{i+1\\}$的表达式：\n$^{i+1}\\omega_{i+1}=^{i+1}_iR^i\\omega_i+\\dot{\\theta}_{i+1}\\hat{Z}_{i+1}$①\n$\\{i+1\\}$原点的线速度等于$\\{i\\}$原点的线速度加上一个由于连杆$i+1$的角速度引起的新的分量：\n$^iv_{i+1}=^iv_i+^i\\omega_i\\times^iP_{i+1}$\n上式两边同乘$^{i+1}_{i}R$，得：\n$^{i+1}v_{i+1}=^{i+1}_{i}R(^iv_i+^i\\omega_i\\times^iP_{i+1})$②\n式①②是关节$i+1$为旋转关节的情况，对于移动关节，相应的关系为：\n$^{i+1}\\omega_{i+1}=^{i+1}_iR^i\\omega_i$\n$^{i+1}v_{i+1}=^{i+1}_iR(^iv_i+^i\\omega_i\\times^iP_{i+1})+\\dot{d}_{i+1}{}^{i+1}\\hat{Z}_{i+1}$\n从一个连杆到下一个连杆依次应用这些公式，可以计算出最后一个连杆在自身坐标系$\\{N\\}$中表达的角速度$^N\\omega_N$和线速度$^Nv_N$，用$^0_NR$去左乘这些速度即可向基坐标进行旋转变换\n雅可比 雅可比矩阵是多维形式的导数，例如，假设有6个函数，每个函数都有6个独立的变量：\n$y_1=f_1(x_1,x_2,x_3,x_4,x_5,x_6)$\n$y_2=f_1(x_1,x_2,x_3,x_4,x_5,x_6)$\n$\\vdots$\n$y_6=f_1(x_1,x_2,x_3,x_4,x_5,x_6)$\n用矢量简记为：\n$Y=F(X)$\n现在如果想要计算出$y_i$的微分关于$x_j$的微分的函数，可应用多元函数求导法则计算得到：\n$\\delta y_1=\\frac{\\partial f_1}{\\partial x_1}\\delta x_1+\\frac{\\partial f_1}{\\partial x_2}\\delta x_2+\\cdots+\\frac{\\partial f_1}{\\partial x_6}\\delta x_6$\n$\\delta y_2=\\frac{\\partial f_1}{\\partial x_1}\\delta x_1+\\frac{\\partial f_1}{\\partial x_2}\\delta x_2+\\cdots+\\frac{\\partial f_1}{\\partial x_6}\\delta x_6$\n$\\vdots$\n$\\delta y_6=\\frac{\\partial f_1}{\\partial x_1}\\delta x_1+\\frac{\\partial f_1}{\\partial x_2}\\delta x_2+\\cdots+\\frac{\\partial f_1}{\\partial x_6}\\delta x_6$\n用矢量简记为：\n$\\delta Y=\\frac{\\partial F}{\\partial X}\\delta X$\n上式中的$6\\times6$的偏微分矩阵为我们所说的雅可比矩阵\n如果$f_i(X)$都是非线性函数，那么这些偏微分都是$x_j$的函数，因此可采用如下表示：\n$\\delta Y=J(X)\\delta X$\n将上式两端同时除以时间的微分，可以将雅可比矩阵看成$X$中的速度向$Y$中速度的映射：\n$\\dot{Y}=J(X)\\dot{X}$\n在机器人学中，操作臂末端的位姿与一系列关节角也是上式中$Y$与$X$的关系，求导后我们可以使用雅可比将关节速度与操作臂末端的笛卡尔速度联系起来，得到：\n$^0\\boldsymbol{v}=^0J(\\Theta)\\dot{\\Theta}$\n式中$\\Theta$是操作臂关节角矢量，$\\boldsymbol{v}$是笛卡尔速度矢量，左上标表示笛卡尔速度所参考的坐标系，当参考坐标系很明显而不用说明时可以省去\n对于通常的六关节机器人，雅可比矩阵是$6\\times6$维的，$\\dot{\\Theta}$是$6\\times1$维的，$^0\\boldsymbol{v}$也是$6\\times1$维的，由一个$3\\times1$的线速度矢量和$3\\times1$的角速度矢量排列起来的：\n$^0\\boldsymbol{v}=\\begin{bmatrix}^0\\boldsymbol{\\upsilon}\\\\^0\\boldsymbol{\\omega}\\end{bmatrix}$\n可以定义任何维数的雅可比矩阵，雅可比矩阵的行数等于操作臂在笛卡尔空间中的自由度数量，列数等于操作臂的关节数量\n雅可比矩阵参考坐标系的变换 已知$\\{B\\}$中的雅可比矩阵：\n$\\begin{bmatrix}^B\\boldsymbol{\\upsilon}\\\\^B\\boldsymbol{\\omega}\\end{bmatrix}=^B\\boldsymbol{v}=^BJ(\\Theta)\\dot{\\Theta}$\n对于如何给出雅可比矩阵在$\\{A\\}$中的表达式，首先注意到$\\{B\\}$中的笛卡尔速度矢量可通过如下变换得到相对于$\\{A\\}$的表达式：\n$\\begin{bmatrix}^A\\boldsymbol{\\upsilon}\\\\^A\\boldsymbol{\\omega}\\end{bmatrix}=\\begin{bmatrix}^A_BR\u00260\\\\0\u0026^A_BR\\end{bmatrix}\\begin{bmatrix}^B\\boldsymbol{\\upsilon}\\\\^B\\boldsymbol{\\omega}\\end{bmatrix}$\n因此可以得到：\n$\\begin{bmatrix}^A\\boldsymbol{\\upsilon}\\\\^A\\boldsymbol{\\omega}\\end{bmatrix}=\\begin{bmatrix}^A_BR\u00260\\\\0\u0026^A_BR\\end{bmatrix}{}^BJ(\\Theta)\\dot{\\Theta}$\n于是雅可比矩阵参考坐标系的变换为：\n$^AJ(\\Theta)=\\begin{bmatrix}^A_BR\u00260\\\\0\u0026^A_BR\\end{bmatrix}{}^BJ(\\Theta)$\n奇异性 如果雅可比矩阵可逆（也就是非奇异的），那么已知笛卡尔速度就可以对该矩阵求逆计算出关节的速度：\n$\\dot{\\Theta}=J^{-1}(\\Theta)\\boldsymbol{v}$\n但是雅可比矩阵不是对于所有的$\\Theta$值都可逆，大多数操作臂都有使得雅可比矩阵奇异的$\\Theta$值，这些位置就称为机构的奇异位形或简称奇异性\n奇异位形的分类有一些深入研究，但目前我们先将它们大致分为两类：\n$1)$工作空间边界的奇异位形出现在操作臂完全展开或者收回使得末端执行器处于非常接近工作空间边界的情况\n$2)$工作空间内部的奇异位形总是远离工作空间的边界，通常是由于两个或两个以上的关节轴线共线引起的\n当操作臂处于奇异位形时会失去一个或多个自由度，即在笛卡尔空间的某个方向上无论选择什么样的关节速度都不能使机器人手臂运动\n操作臂的静力 操作臂的链式结构特性让我们想到力和力矩是如何从一个连杆向下一个连杆传递的，考虑操作臂的自由末端在工作空间推动某个物体或用手部抓举某个负载的典型情况，我们希望求出保持系统静态平衡的关节力矩\n对于操作臂的静力，首先锁定所有关节使得操作臂成为一个结构，再进行理论力学的静力分析方法\n我们为相邻杆件所施加的力和力矩定义以下特殊的符号：\n$f_i=$连杆$i-1$施加在连杆$i$上的力\n$n_i=$连杆$i-1$施加在连杆$i$上的力矩\n对于单个连杆的静力-力矩平衡，有：\n$\\Sigma f=^if_i-^if_{i+1}=0$\n$\\Sigma n=^in_i-^in_{i+1}-^iP_{i+1}\\times^if_{i+1}=0$\n这样我们就可以从施加于机器人末端执行器的力和力矩的描述开始可以计算出作用于每一个连杆的力和力矩，对上式进行整理以便从高序号连杆向低序号连杆进行迭代求解得到：\n$^if_i=^if_{i+1}$\n$^in_i=^in_{i+1}+^iP_{i+1}\\times^if_{i+1}$\n再按照定义在连杆自身坐标系中的力和力矩写出这些表达式得：\n$^if_i=^i_{i+1}R^{i+1}f_{i+1}$\n$^in_i=^i_{i+1}R^{i+1}n_{i+1}+^iP_{i+1}\\times^if_{i+1}$\n对于一个关节，除了绕关节轴的力矩靠关节驱动提供之外，力和力矩矢量的其他分量都可以由操作臂机构本身来平衡，因此保持系统静平衡的关节力矩等于关节轴矢量与施加在连杆上的力矩矢量的点乘：\n$\\tau_i=^in_i^T{}^i\\hat{Z}_i$\n对于关节$i$是移动关节的情况，可以算出关节驱动力为：\n$\\tau_i=^if_i^T{}^i\\hat{Z}_i$\n力域中的雅可比 当力作用在机构上时，如果机构经过一个位移，就做了功，令位移趋向于无穷小就可以用虚功原理描述静止的情况\n功是具有能量的单位，所以在任何广义坐标系下的测量值都相同，即笛卡尔空间做的功（力与位移）等于关节空间做的功（力矩与角位移）。在多维空间中，功是一个力或力矩矢量与位移矢量的点积，由此我们得到：\n$\\mathcal{F}\\cdot\\delta\\chi=\\tau\\cdot\\delta\\Theta$\n式中$\\mathcal{F}$是作用在末端执行器上的$6\\times1$维笛卡尔力-力矩矢量，$\\delta\\chi$是末端执行器的$6\\times1$维无穷小笛卡尔位移矢量，$\\tau$是$6\\times1$维关节力矩矢量，$\\delta\\Theta$是$6\\times1$维无穷小关节位移矢量\n上式也可写成：\n$\\mathcal{F}^T\\delta\\chi=\\tau^T\\delta\\Theta$\n雅可比矩阵的定义为：\n$\\delta\\chi=J\\delta\\Theta$\n因此可写出：\n$\\mathcal{F}^TJ\\delta\\Theta=\\tau^T\\delta\\Theta$\n$\\mathcal{F}^TJ=\\tau^T$\n对两边转置得：\n$\\tau=J^T\\mathcal{F}$\n由此雅可比矩阵的转置将作用在手臂上的笛卡尔力映射成了等效关节力矩\n当雅可比矩阵奇异时，存在某些特定的方向，末端执行器在这些方向上不能施加期望的静态力，意味着在力域中和位置域中奇异都是存在的\n速度和静力的笛卡尔变换 根据前文的讨论我们有：\n$\\boldsymbol{v}=\\begin{bmatrix}\\upsilon\\\\\\omega\\end{bmatrix}$\n$\\mathcal{F}=\\begin{bmatrix}F\\\\N\\end{bmatrix}$\n我们现在给出将这些量从一个坐标系映射到另一个坐标系的变换矩阵\n在机器人连杆的运动一节已经得到下面的变换公式：\n$^{i+1}\\omega_{i+1}=^{i+1}_iR^i\\omega_i+\\dot{\\theta}_{i+1}\\hat{Z}_{i+1}$\n$^{i+1}v_{i+1}=^{i+1}_{i}R(^iv_i+^i\\omega_i\\times^iP_{i+1})$\n将$\\{i\\}$换成$\\{A\\}$，$\\{i+1\\}$换成$\\{B\\}$，以及在刚性坐标系下令$\\dot{\\theta}=0$，再写为矩阵的形式得到：\n$\\begin{bmatrix}^B\\upsilon_B\\\\^B\\omega_B\\end{bmatrix}=\\begin{bmatrix}^B_AR\u0026-^B_AR^AP_{BORG}\\times\\\\0\u0026^B_AR\\end{bmatrix}\\begin{bmatrix}^A\\upsilon_A\\\\^A\\omega_A\\end{bmatrix}$\n原式中$P$乘在右边，为了转换为左乘的形式表达在矩阵中，我们将其写成反对称矩阵：\n$P\\times=\\begin{bmatrix}0\u0026-p_z\u0026p_y\\\\p_z\u00260\u0026-p_x\\\\-p_y\u0026p_x\u00260\\end{bmatrix}$\n由此新得到的变换矩阵被称为速度变换矩阵，用符号$T_\\upsilon$表示，它是一个把$\\{A\\}$中的速度映射到$\\{B\\}$中的速度的速度变换，简记为：\n$^B\\boldsymbol{v}_B=^B_AT_\\upsilon^A\\boldsymbol{v}_A$\n将这个变换过程反过来对$^B_AT_\\upsilon$求逆即可：\n$^A_BT_\\upsilon=^B_AT_\\upsilon^{-1}=\\begin{bmatrix}^A_BR\u0026^AP_{BORG}\\times^A_BR\\\\0\u0026^A_BR\\end{bmatrix}$\n同样的，对操作臂的力学一节中得到的公式：\n$^if_i=^i_{i+1}R^{i+1}f_{i+1}$\n$^in_i=^i_{i+1}R^{i+1}n_{i+1}+^iP_{i+1}\\times^if_{i+1}$\n我们推出力矢量由$\\{A\\}$到$\\{B\\}$的映射关系为：\n$\\begin{bmatrix}^AF_A\\\\^AN_A\\end{bmatrix}=\\begin{bmatrix}^A_BR\u00260\\\\^AP_{BORG}\u0026^A_BR\\end{bmatrix}\\begin{bmatrix}^BF_B\\\\^BN_B\\end{bmatrix}$\n简记为：\n$^A\\mathcal{F}_A=^A_BT_f^B\\mathcal{F}_B$\n式中$T_f$表示力-力矩变换矩阵\n本章完\n","date":"2024-11-18T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep5.%E9%9B%85%E5%8F%AF%E6%AF%94%E9%80%9F%E5%BA%A6%E5%92%8C%E9%9D%99%E5%8A%9B/","title":"【机器人学导论】Ep5.雅可比：速度和静力"},{"content":"Python基础语法速览（上） 变量、输入输出与运算符 变量和赋值语句 1 In [1]: x = 7 #创建变量x并为x赋值为7 变量名是一个标识符，由字母、数字和下划线组成，但不能以数字开头，区分大小写\n1 2 In [2]: type(x) #查看x的数据类型 Out[2]: int 运算符 算术运算符 Python运算 算术运算符 加法 + 减法 - 乘法 * 幂 ** 除法（结果为浮点数） / 整除 // 取余 % 运算符优先级规则\n1.从最内层计算括号中的表达式\n2.幂运算，多个幂运算按照从右到左的顺序计算\n3.乘法、除法、整除和模，多个乘法、除法、整除和模按照从左到右的顺序计算\n4.加法、减法，多个加法、减法按照从左到右的顺序计算\n比较运算符 条件是一个值为True或False的布尔表达式\n比较运算符 含义 \u0026gt; 大于 \u0026lt; 小于 \u0026gt;= 大于等于 \u0026lt;= 小于等于 == 等于 != 不等于 1 2 3 4 5 6 7 8 9 10 In [1]: 114 \u0026gt; 514 Out[1]: False In [2]: 114 \u0026lt; 514 Out[2]: True In [3]: x = 191 In [4]: 114 \u0026lt;= x \u0026lt;= 514 #链式比较检测一个值是否在某个范围内 Out[4]: True 对其他表达式，非零值为True，零为False，非空字符串为True，空字符串为False\n布尔运算符 条件运算符可用于组成简单条件，要将简单条件进行组合构成更复杂的条件可以使用布尔运算符and、or和not将两个表达式连接起来\n布尔运算符and\n表达式1 表达式2 表达式1 and 表达式2 False False False False True False True False False True True True 布尔运算符or\n表达式1 表达式2 表达式1 and 表达式2 False False False False True True True False True True True True 布尔运算符not\n表达式 not 表达式 False True True False 运算符优先级和结合性汇总\n运算符 结合性 () 从左到右 ** 从右到左 * / // % 从左到右 + = 从左到右 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= 从左到右 == != 从左到右 not 从左到右 and 从左到右 or 从左到右 增强赋值 当相同的变量名同时出现在赋值运算符的左右两端，可以使用增强赋值对赋值表达式进行缩写\n增强赋值表达式 解释 a += 2 a = a + 2 a -= 2 a = a - 2 a *= 2 a = a * 2 a **= 2 a = a ** 2 a /= 2 a = a / 2 a //= 2 a = a // 2 a %= 2 a = a % 2 print函数、单双引号、转义字符 1 2 In [1]: print(\u0026#39;Welcome to Python!\u0026#39;) #将括号中的参数显示为一行文本 Welcome to Python! 除了单引号，双引号也可以括起一个字符串，但一般习惯用单引号\n1 2 In [2]: print(\u0026#39;Welcome\u0026#39;, \u0026#39;to\u0026#39;, \u0026#39;Python!\u0026#39;) #逗号分隔参数，输出自动加空格 Welcome to Python! 反斜杠（\\）称为转义字符，反斜杠和紧随其后的字符形成一个转义序列，例如转义序列“\\n”表示换行符\n1 2 3 4 5 In [3]: print(\u0026#39;Welcome\\nto\\n\\nPython!\u0026#39;) Welcome to Python! 转义序列 说明 \\n 换行符 \\t 制表符 \\\\ 插入反斜杠 \\\u0026quot; 插入双引号 \\' 插入单引号 在一行的结尾用续行符“\\”将一个长字符串写成多行\n1 2 3 In [4]: print(\u0026#39;this is a longer string, so we\\ ...: split it over two lines\u0026#39;) this is a longer string, so we split it over two lines 可以在print语句中执行计算\n1 2 In [5]: print(\u0026#39;Sum is\u0026#39;, 7 + 3) Sum is 10 三引号字符串 字符串中包含引号\n单引号字符串中可以包含双引号，双引号字符串中可以包含单引号，但单引号包含单引号和双引号包含双引号需要用转义字符\n三引号字符串可以将单引号和双引号都包含在内\n多行字符串\n1 2 3 4 5 6 7 8 9 In [1]: triple_quoted_string = \u0026#34;\u0026#34;\u0026#34;This is a triple-quoted ...: string that spans two lines\u0026#34;\u0026#34;\u0026#34; #用引号将字符串赋给变量，三引号中可直接用回车键代替换行符 In [2]: print(triple_quoted_string) This is a triple-quoted string that spans two lines In [3]: triple_quoted_string Out[3]: \u0026#39;This is a triple-quoted\\nstring that spans two lines\u0026#39; #变量嵌入换行符存储多行字符串 格式化字符串 字符串引号前加字母f可以将变量用花括号括起来插入字符串来格式化输出结果\n1 2 3 4 In [1]: a = 1.14514 In [2]: print(f\u0026#39;The number a is {a}\u0026#39;) Out[2]: The number a is 1.14514 更多格式化字符串内容在字符串章节讨论\n获取输入 1 2 3 4 5 6 7 8 In [1]: name = input(\u0026#34;What\u0026#39;s your name? \u0026#34;) #input函数显示字符串参数作为提示后等待并返回用户输入，随后赋值给变量 What\u0026#39;s your name? Paul In [2]: value = int(input(\u0026#39;Enter an integer: \u0026#39;)) #input函数只会将输入转换为字符串，需要用int函数将字符串转换为整数，同理float函数可以将字符串转换为浮点数 Enter an integer: 114514 In [3]: int(114.514) #int函数还可以将小数向下取整 Out[3]: 114 控制语句 if语句 if语句根据条件来决定是否执行一条语句\n1 2 3 4 5 6 if 114 \u0026gt; 514: print(\u0026#34;Not homo\u0026#34;) if 114 \u0026lt; 514: print(\u0026#34;Homo\u0026#34;) ------ Homo （分割线以下为程序执行后部分）\nif\u0026hellip;else语句包含满足条件执行的语句和不满足条件执行的雨具\n1 2 3 4 5 6 7 8 #成绩合格判断程序 grade = 57 if grade \u0026gt;= 60: print(\u0026#39;Passed\u0026#39;) else: print(\u0026#39;Failed\u0026#39;) ------ Failed if\u0026hellip;elif\u0026hellip;else语句在多种条件中选择要执行的语句\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #成绩等级判断程序 grade = 77 if grade \u0026gt;= 90: print(\u0026#39;A\u0026#39;) elif grade \u0026gt;= 80: print(\u0026#39;B\u0026#39;) elif grade \u0026gt;= 70: print(\u0026#39;C\u0026#39;) elif grade \u0026gt;= 60: print(\u0026#39;D\u0026#39;) else: print(\u0026#39;F\u0026#39;) ------ C else非必需，即不满足任何一种条件时不执行任何语句\nwhile语句 while语句在循环条件为True时重复执行内部语句\n1 2 3 4 5 6 7 #寻找第一个大于114的2的幂 a = 2 while a \u0026lt;= 114: a = a * 2 print(a) ------ 128 for语句 for语句为一个序列中的每一项重复执行内部语句\n1 2 3 4 5 #输出\u0026#39;Programming\u0026#39;中的每个字母并用空格隔开 for character in \u0026#39;Programming\u0026#39;: print(character, end = \u0026#39; \u0026#39;) ------ P r o g r a m m i n g 执行步骤：\n1.进入循环语句，将\u0026quot;Programming\u0026quot;中的第一个字母P赋值给character\n2.执行循环体中的语句\n3.将下一个字母赋值给character并执行循环体中的语句，直到所有字母都被处理过\n除了字符串，还有其他可迭代的对象序列类型\n列表是用方括号括起来并用逗号分隔的项的合集\n1 2 3 4 5 6 7 #求列表内所有项的和 total = 0 for number in [1, 1, 4, 5, 1, 4]: total = total + number print(total) ------ 16 列表也可以赋值给一个变量，用变量名替代\n内置函数range 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #单参数：创建一个从0开始一直到（但不包括）参数值的整数序列 for counter in range(10): print(counter, end = \u0026#39; \u0026#39;) ------ 0 1 2 3 4 5 6 7 8 9 ------ #双参数：创建一个从第一个参数开始一直到（但不包括）第二个参数的整数序列 for counter in range(5, 10): print(counter, end = \u0026#39; \u0026#39;) ------ 5 6 7 8 9 ------ #三参数：创建一个从第一个参数开始一直到（但不包括）第二个参数，并以第三个参数值（步长）递增的整数序列 for counter in range(1, 14, 3): print(counter, end = \u0026#39; \u0026#39;) ------ 1 4 7 10 13 ------ # 如果第三个参数为负则递减 break和continue语句 break和continue语句用在循环体内改变循环的控制流，执行break语句则立即退出该循环，在while语句中执行continue语句会转回循环条件以确定循环是否该继续执行，在for语句中执行continue语句会直接处理序列中的下一项（如果有）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #break语句 for number in range(100): if number == 10: break print(number, end = \u0026#39; \u0026#39;) ------ 0 1 2 3 4 5 6 7 8 9 ------ #continue语句 for number in range(10): if number == 5: continue print(number, end = \u0026#39; \u0026#39;) ------ 0 1 2 3 4 6 7 8 9 函数 函数定义 函数执行一项明确定义的任务，定义了一个函数后，可以在整个程序中多次调用这个函数\n1 2 3 4 5 6 #定义一个求平方的函数 def square(number): #def 函数名(参数1, 参数2, ...): return number ** 2 #将结果返回给调用者 printf(square(7)) #函数名(参数1, 参数2, ...)，参数数量与定义的数量一致 ------ 49 如果函数不需要参数，则定义和调用时括号内为空\n如果return语句不带表达式将返回None（空值），在条件语句中被判断为False\n如果没有return语句函数将在执行到语句块内最后一条语句后返回None\n在函数的语句块中定义的参数和变量为局部变量，只能在函数体内部使用，在外部需要另外定义\n默认参数值 1 2 3 4 5 6 7 8 In [1]: def rectangle_area(length = 2, width = 3): #指定参数具有默认值 ...: return length * width In [2]: rectangle_area() #调用函数时没有参数，函数使用默认值 Out[2]: 6 In [3]: rectangle_area(10) #调用函数时有一部分参数，函数从左往右给参数赋值，其余保留默认值 Out[3]: 30 关键字参数 1 2 3 4 5 In [1]: def rectangle_area(length, width): ...: return length * width In [2]: rectangle_area(width = 5, length = 10) #调用函数使用关键字参数能以任何顺序传递参数 Out[2]: 50 不定长参数列表 1 2 3 4 5 6 def average(*args): #*将参数打包成元组传递给参数args return sum(args)/len(args) #sum为内置求和函数，len为内置序列长度函数 grades = [88, 75, 96, 55, 83] print(average(*grades)) #*将参数解包，此处调用等同于average(88, 75, 96, 55, 83) ------ 79.4 内置函数max和min是不定长参数函数，可分别用于求出各自参数中的最大值和最小值\n1 2 3 4 5 In [1]: max(11, 45, 14) Out[1]: 45 In [2]: min(11, 45, 14) Out[2]: 11 作用域 在函数体内定义的变量为局部变量，作用域为函数内部\n在函数体外定义的变量为全局变量，作用域在整个程序\n函数体可以直接访问全局变量的值，但无法修改，如果在函数体为全局变量赋值会创建一个同名的新局部变量\n使用global语句在函数体中修改全局变量\n1 2 3 4 5 6 7 8 x = \u0026#39;goodbye\u0026#39; def modify_global(): global x x = \u0026#39;hello\u0026#39; print(\u0026#39;x printed from modify_global:\u0026#39;, x) modify_global() ------ x printed from modify_global: hello lambda函数 对于功能简单只返回一个单一表达式值的函数，可以在调用函数的位置使用一个lambda表达式临时定义一个函数\n1 2 3 4 5 def is_odd(x): return x % 2 != 0 #用lambda定义 lambda x: x % 2 != 0 Python标准库 在编写程序时经常会用到Python标准库或其他库中的函数和类，模块是Python标准库中对相互关联的函数、数据和类进行分组的文件\n一些常用的Python标准库模块\ncollections：列表、元组、字典和集合之外的数据结构\nCryptography：加密数据以实现安全传输\ncsv：处理用逗号分隔值的文件（如Excel）\ndatetime：日期和实践操作\ndecimal：定点和浮点算术运算，包括货币计算\ndoctest：在简单单元测试的文档字符串中嵌入验证测试和预期结果\ngettext和locale：国际化和本地化模块\njson：与Web服务和NoSQL文档数据库一起使用的JSON处理\nmath：常见的数学常数和操作\nos：与操作系统交互\nprofile、pstats、timeit：性能分析\nrandom：伪随机数\nre：用于模式匹配的正则表达式\nsqlite3：SQLite关系数据库访问\nstatistics：数学统计函数\nstring：字符串处理\nsys：命令行参数处理：标准输入、标准输出和标准错误流\ntkinter：图形用户界面和基于画布的图形\nturtle：海龟图\nwebbrowser：用于在Python应用程序中方便地显示网页\n随机数生成 Python标准库的random模块可以模拟偶然因素\n1 2 3 4 5 6 import random #导入random模块 random.seed(32) #设置随机数生成器的种子 for roll in range(10): print(random.randrange(1, 7), end = \u0026#39; \u0026#39;) #randrange函数随机生成一个从第一个参数到（但不包括）第二个参数之间的整数值 ------ 1 2 2 3 6 2 4 1 6 1 函数randrange生成的是基于以一个称为seed的数值开头的内部计算生成的伪随机数，每次新的会话或执行含随机函数的脚本Python会使用不同的seed，可以用seed函数为随机数生成器设置种子，相同种子的伪随机数序列相同，便于程序调试\nmath模块中的函数 函数 说明 ceil(x) 将x向上取整 floor(x) 将x向下取整 sin(x)\ncos(x)\ntan(x) 求x的正弦\n求x的余弦\n求x的正切（以上均为弧度制） exp(x)\nlog(x)\nlog10(x) 指数函数e^x^\n求x的自然对数（底为e）\n求x的对数（底为10） pow(x, y)\nsqrt(x) 求x的y次幂\n求x的平方根 fabs(x) 求x的绝对值，返回浮点数。Python内置abs绝对值函数根据参数返回整数或浮点数 fmod(x, y) x除以y的余数，返回浮点数 import语句 1 2 3 4 5 6 7 8 9 10 11 12 #用import 模块名导入，需要通过模块名称和一个点（.）访问包含在模块内的函数 In [1]: import math In [2]: math.ceil(10.3) Out[2]: 11 #用from 模块名 import 函数1, 函数2, ...导入，可以直接使用函数名 In [3]: from math import ceil, floor In [4]: ceil(10.3) Out[4]: 11 #“from 模块名 import *”使用通配符*导入模块中的所有函数，但可能触发不容易察觉的错误，如变量名和函数名歧义 #“import 模块名 as 自定义模块名”可以用自定义缩写来表示导入的模块来简化代码 序列 列表 列表通常存储同构数据（数据类型相同），也可以存储异构数据（数据类型不同），元素和长度可以修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 In [1]: c = [-45, 6, 0, 72, 114] #创建列表 In [2]: c[0] #访问列表中第n+1个元素，因为列表中元素编号从0开始 Out[2]:-45 In [3]: len(c) #获取列表的长度 Out[3]: 5 In [4]: c[-1] #用负数访问列表，列表负数编号最后一个元素为-1，从后往前递减 Out[4]: 114 In [5]: c[2] = 514 #修改列表中的元素，此时c为[-45, 6, 514, 72, 114]，而字符串和元组序列无法修改元素 In [6]: c += [1919] #创建一个单元素列表并添加到列表c末尾，此时c为[-45, 6, 514, 72, 114, 1919] In [7]: ho = [1, 1, 4] In [8]: mo = [5, 1, 4] In [9]: homo = ho + mo #运算符+拼接两个列表，此时homo为[1, 1, 4, 5, 1, 4] In [10]: homo *= 2 #成倍地扩充序列，此时homo为[1, 1, 4, 5, 1, 4, 1, 1, 4, 5, 1, 4] 比较运算符逐一比较列表中的每个元素\n1 2 3 4 5 6 7 8 9 10 11 In [10]: a = [1, 2, 3] In [11]: b = [1, 2, 3] In [12]: c = [1, 2, 3, 4] In [13]: a == b Out[13]: True #a和b每个元素都相等 In [15]: a \u0026lt; c Out[14]: True #a的元素数量比c少 列表处理方法 sort方法（排序） 1 2 3 4 5 6 7 8 9 In [1]: numbers = [10, 3, 7, 1, 9, 4, 2, 8, 5, 6] In [2]: numbers.sort() #按升序排列列表元素[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] In [3]: numbers.sort(reverse = True) #按降序排列列表元素（默认值为False） In [4]: numbers = [10, 3, 7, 1, 9, 4, 2, 8, 5, 6] In [5]: ascending_numbers = sorted(numbers) #内置函数sorted返回按升序排列好的列表给新列表，不改变原列表 字符和字符串元素将按ASCII表顺序排列\ninsert方法（插入） 1 2 3 4 In [1]: color_names = [\u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;] In [2]: color_names.insert[0, red] #在索引0处插入\u0026#39;red\u0026#39;：[\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;] append方法（末尾添加） 1 2 In [3]: color_names.append(\u0026#39;blue\u0026#39;) #在列表末尾添加\u0026#39;blue\u0026#39;：[\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] extend方法（末尾扩充） 1 2 3 In [4]: color_names.extend([\u0026#39;indigo\u0026#39;, \u0026#39;violet\u0026#39;]) #将另一个序列的所有元素添加到列表的末尾：[\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;indigo\u0026#39;, \u0026#39;violet\u0026#39;] #等效于+= remove方法（移除） 1 2 In [5]: color_names.remove(\u0026#39;green\u0026#39;) #移除列表中某个值的第一个匹配项：[\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;indigo\u0026#39;, \u0026#39;violet\u0026#39;] clear方法（清空） 1 In [6]: color_names.clear() #清空列表中的所有元素 count方法（计数） 1 2 3 4 In [7]: responses = [1, 2, 5, 4, 3, 5, 2, 1, 3, 3, 1, 4, 3, 3, 3, 2, 3, 3, 2, 2] In [8]: responses.count(3) #返回某个元素在列表中出现的次数 Out[8]: 8 reverse方法（反转） 1 2 3 4 In [9]: color_names = [\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] In [10]: color_names.reverse() #反转列表中的元素：[\u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;red\u0026#39;] copy方法（拷贝） 1 2 3 4 In [11]: copied_list = color_names.copy() #返回一个包含原始对象浅拷贝的新列表 In [12]: copied_list Out[12]: [\u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;red\u0026#39;] 列表推导式 列表推导式是将一个列表转换成另一个列表的工具，在转换过程中可以指定元素必须符合一定的条件才能添加到新的列表中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 In [1]: list1 = [item for item in range(1, 6)] #创建整数列表：[1, 2, 3, 4, 5] In [2]: list2 = [item ** 3 for item in range(1, 6)] #将每个值的立方映射到新列表：[1, 8, 27, 64, 125] In [3]: list3 = [item for item in range(1, 11) if item % 2 == 0] #过滤出偶数到新列表：[2, 4, 6, 8, 10] In [4]: colors = [\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;] In [5]: colors2 = [item.upper() for item in colors] #将所有元素大写映射到新列表：[\u0026#39;RED\u0026#39;, \u0026#39;ORANGE\u0026#39;, \u0026#39;YELLOW\u0026#39;, \u0026#39;GREEN\u0026#39;, \u0026#39;BLUE\u0026#39;] #总结：for前映射操作，if后过滤条件 生成器表达式 列表推导式使用贪婪计算，每次都会创建一个包含了所有值的列表，用[]括起来\n生成器表达式使用惰性计算，只返回符合要求的值，用()括起来\n1 2 3 4 5 numbers = [10, 3, 7, 1, 9, 4, 2, 8, 5, 6] for value in (x ** 2 for x in numbers if x % 2 != 0): print(value, end = \u0026#39; \u0026#39;) ------ 9 49 1 81 25 二维列表 用两个索引来表示元素的列表称为二维列表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 In [1]: a = [[77, 68, 86, 73], [96, 87, 89, 81], [70, 90, 86, 81]] #创建一个三行四列的二维列表，每个二级方括号为一行 In [2]: a[0][2] #访问行索引为0，列索引为2的元素 Out[2]: 86 In [3]: for row in a: ...: for item in row: ...: print(item, end = \u0026#39; \u0026#39;) print() 77 68 86 73 96 87 89 81 70 90 86 81 #用嵌套for语句按行输出二维列表，可见二维列表先按行提取再按列提取 元组 元组通常存储异构数据，也可以存储同构数据，元素和长度不能随意更改，只能给整个元组重新赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 In [1]: student_tuple = () #创建一个空元组 In [2]: student_tuple = \u0026#39;John\u0026#39;, \u0026#39;Green\u0026#39;, 3.3 #用逗号分隔构造元组，括号可选 In [3]: student_tuple = (\u0026#39;red\u0026#39;,) #用逗号和括号构造单元素元组 In [4]: time_tuple = (1919, 8, 10) In [5]: time_tuple[0] #访问元组元素与列表同理 Out[5]: 1919 In [6]: time_tuple += (1, 2) #将元组time_tuple拼接上元组(1, 2)再重新赋值给time_tuple In [7]: numbers = [1, 2, 3] In [8]: numbers += (4, 5) #将元组附加到列表中，此时numbers为[1, 2, 3, 4, 5] In [9]: tuple = (\u0026#39;ho\u0026#39;, \u0026#39;mo\u0026#39;, [11, 45, 14]) In [10]: tuple[2][1] = 54 #元组不可变，但元组中列表的元素可变，此时tuple玩(\u0026#39;ho\u0026#39;, \u0026#39;mo\u0026#39;, [11, 54, 14]) 序列解包 1 2 3 4 5 6 7 8 9 In [1]: student_tuple = (\u0026#39;Amanda\u0026#39;, 114) In [2]: name, grades = student_tuple #序列可以分配给用逗号分隔的变量列表，此时name为\u0026#39;Aman\u0026#39;，grades为114 In [3]: number1 = 114 In [4]: number2 = 514 In [5]: number1, number2 = (number2, number1) #用打包和解包来交换两个变量的值 内置函数enumerate对列表中每个元素返回一个索引和值的元组\n1 2 3 4 5 6 7 In [6]: colors = [\u0026#39;red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;yellow\u0026#39;] In [7]: list(enumerate(colors)) #内置函数list创建一个列表包含enumerate的输出 Out[7]: [(0, \u0026#39;red\u0026#39;), (1, \u0026#39;orange\u0026#39;), (2, \u0026#39;yellow\u0026#39;)] In [8]: tuple(enumerate(colors)) #同理内置函数tuple从序列创建一个元组 Out[8]: ((0, \u0026#39;red\u0026#39;), (1, \u0026#39;orange\u0026#39;), (2, \u0026#39;yellow\u0026#39;)) 序列切片 1 2 3 4 5 6 7 8 9 10 11 12 13 In [1]: numbers = [2, 3, 5, 7, 11, 13, 17, 19] In [2]: numbers[2:6] #从第一个想要的对象开始到第一个不想要的对象结束的切片 Out[2]: [5, 7, 11, 13] In [3]: numbers[:6] #省略起始索引默认从0开始 Out[3]: [2, 3, 5, 7, 11, 13] In [4]: numbers[6:] #省略结束索引默认到序列末尾结束 Out[4]: [17, 19] In [5]: numbers[:] #省略开始索引和结束索引会复制整个序列 Out[5]: [2, 3, 5, 7, 11, 13, 17, 19] 切片的步长 1 2 3 4 5 In [6]: numbers[::2] #以2为步长构造间隔1个元素的切片 Out[6]: [2, 5, 11, 17] In [7]: numbers[::-1] #负数步长以倒序构造切片，该行代码等价于numbers[-1:-9:-1] Out[7]: [19, 17, 13, 11, 7, 5, 3, 2] 切片修改列表 1 2 3 4 5 6 7 8 9 10 In [8]: numbers[0:3] = [\u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;, \u0026#39;five\u0026#39;] #将numbers前三个元素替换 In [9]: numbers[0:3] = [] #将numbers前三个元素删除 In [10]: numbers = [2, 3, 5, 7, 11, 13, 17, 19] In [11]: numbers[::2] = [100, 100, 100, 100] #间隔1个元素赋值列表元素 In [12]: numbers Out[12]: [100, 3, 100, 7, 100, 13, 100, 19] del声明 1 2 3 4 5 6 7 8 9 10 11 In [1]: numbers = list(range(0, 10)) #创建列表[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] In [2]: del numbers[-1] #删除列表最后一个元素[0, 1, 2, 3, 4, 5, 6, 7, 8] In [3]: del numbers[0:2] #删除列表前两个元素[2, 3, 4, 5, 6, 7, 8] In [4]: del numbers[::2] #每隔一个步长删除列表中的一个元素[3, 5, 7] In [5]: del numbers[:] #删除列表的所有元素 In [6]: del numbers #删除numbers这个变量 序列搜索 index方法 1 2 3 4 5 6 7 8 9 10 11 12 In [1]: numbers = [3, 7, 1, 4, 2, 8, 5, 6] In [2]: numbers.index(5) #从索引0开始搜索列表，返回与关键词匹配的第一个元素的索引 Out[2]: 6 In [3]: numbers *= 2 In [4]: numbers.index(5, 7) #从索引7到列表末尾的所有元素中搜索5 Out[4]: 14 In [5]: numbers.index(7, 0, 4) #在索引0到3范围内查找值等于7的元素 Out[5]: 1 in和not in 1 2 3 4 5 In [6]: 1000 in numbers #检测1000是否在序列里 Out[6]: False In [7]: 1000 not in numbers #检测1000是否不在序列里 Out[7]: True 序列处理函数 filter函数（过滤） 1 2 3 4 In [1]: numbers = [10, 3, 7, 1, 9, 4, 2, 8, 5, 6] In [2]: list(filter(lambda x: x % 2 != 0, numbers)) #过滤出序列numbers中使得is_odd为真的元素 Out[2]: [3, 7, 1, 9, 5] map函数（映射） 1 2 In [3]: list(map(lambda x: x ** 2, numbers)) #将序列中元素平方处理后映射到新列表 Out[3]: [100, 9, 49, 1, 81, 16, 4, 64, 25, 36] 归约 内置函数len（求长度）、sum（求和）、min（求最小值）和max（求最大值）将序列的元素处理为单个值，称为归约\nkey函数（查找最值） 归约函数min和max使用数字列表作为参数，在更复杂的对象比如字符串中找最值需要使用key函数\n1 2 3 4 5 In [1]: colors = [\u0026#39;Red\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;Yellow\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;Blue\u0026#39;] In [2]: min(colors, key = lambda s: s.lower()) Out[2]: \u0026#39;Blue\u0026#39; #key的参数调用一个返回值的单参数函数对序列中元素进行处理再在min函数中作比较，因为字符串比较用的ASCII值小写字母比大写字母大，所以按字母表顺序需要用lower方法将所有字符串统一处理为小写字母 reverse函数（反向迭代） 1 2 3 4 In [1]: numbers = [10, 3, 7, 1, 9, 4, 2, 8, 5, 6] In [2]: reversed_numbers = [item for item in reversed(numbers)] #反向迭代序列numbers的值，此时reversed_numbers为[6, 5, 8, 2, 4, 9, 1, 7, 3, 10] zip函数（合并） zip函数同时遍历多个可迭代对象的数据并把相同索引的元素提取出来打包成元组返回\n1 2 3 4 5 6 7 8 names = [\u0026#39;Bob\u0026#39;, \u0026#39;Sue\u0026#39;, \u0026#39;Amanda\u0026#39;] grade_point_averages = [3.5, 4.0, 3.75] for name, gpa in zip(names, grade_point_averages): printf(f\u0026#39;Name={name}; GPA={gpa}\u0026#39;) ------ Name=Bob; GPA=3.5 Name=Sue; GPA=4.0 Name=Amanda; GPA=3.75 未完待续\n","date":"2024-11-15T00:00:00Z","permalink":"https://INKEM.github.io/p/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E9%80%9F%E8%A7%88%E4%B8%8A/","title":"【Python】基础语法速览（上）"},{"content":"操作臂逆运动学 上一章我们讨论了已知关节角，计算工具坐标系相对于固定坐标系的位姿的问题。在本章中我们将研究已知工具坐标系相对于固定坐标系的期望位姿，如何计算一系列满足期望要求的关节角，即逆运动学问题\n逆运动学方程的解 解的存在性 研究解是否存在放在操作臂上即研究操作臂的工作空间\n可达工作空间（Reachable Workspace）：手臂可以用至少一种姿态到达的位置\n灵巧工作空间（Dexterous Workspace）：手臂可以用任何姿态到达的位置\n我们用R（旋转关节）和P（移动关节）的字母组合来简记一个操作臂的关节连接顺序\n在上图的处于二维平面的RR操作臂中，如果$l_1\u003el_2$，其可达工作空间为外径$l_1+l_2$、内径$l_1-l_2$的圆环，没有灵巧工作空间；如果$l_1=l_2$，其可达空间为半径$l_1+l_2$的圆，圆心为灵巧工作空间\n如果要让操作臂达到一个三维空间内一般的目标位置和姿态，至少需要六个自由度。当操作臂自由度$n\u003c6$时，其工作空间会被局限在仅能由$n$个独立变量描述的$n$自由度子空间（Subspace），又由于操作臂关节的活动范围受限，其工作空间是对应的$n$自由度子空间的子集\n对于上图的RRR操作臂，其工具坐标系的位置局限在由两个独立坐标变量$x$、$y$描述的一个平面内，而姿态局限在该平面中的一个独立旋转角度变量$\\phi$，由此我们用三个独立变量描述出它的三自由度子空间为：\n$^0_3T=\\begin{bmatrix}c_\\phi\u0026-s_\\phi\u00260\u0026x\\\\s_\\phi\u0026c_\\phi\u00260\u0026y\\\\0\u00260\u00261\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n而其工作空间则进一步局限在该子空间中满足$\\sqrt{x^2+y^2}\\leqslant l_1+l_2+l_3$的部分中\n对于上图的RP操作臂，其工具坐标系的位置局限在由两个独立坐标变量$x$、$y$描述的一个平面内，而姿态也同时由$x$、$y$所决定，$^0\\hat{Y}_2$始终向下，$^0\\hat{Z}_2$与原点的位置矢量同向，$^0\\hat{X}_2$由$^0\\hat{Y}_2$、$^0\\hat{Z}_2$叉乘得到，其二自由度工作空间为：\n$^0_2T=\\begin{bmatrix}\\frac{y}{\\sqrt{x^2+y^2}}\u00260\u0026\\frac{x}{\\sqrt{x^2+y^2}}\u0026x\\\\\\frac{-x}{\\sqrt{x^2+y^2}}\u00260\u0026\\frac{y}{\\sqrt{x^2+y^2}}\u0026y\\\\0\u0026-1\u00260\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n多解问题 由于逆运动学方程是非线性方程，求解过程中往往遇到多解问题\n通过上图我们来直观感受：对于同一个绿色末端连杆的目标位姿，根据肘部方向的不同，前两根连杆有深蓝和浅蓝所示的两种方式可以达到\n但我们只能选择一个解来执行，因此要有解的选择标准。常见的选择条件一个是要求到达目标位姿的过程中每个运动关节的运动量最小，即就近原则，另一个是考虑运动轨迹中的障碍物。下图直观展示了这两种情况：\n解的个数取决于操作臂的关节数量、连杆参数和关节运动范围\n对于关节数量，考虑一种极限状态，当一个操作臂在一定长度内有无穷多个关节，即可看做是一根柔性的曲线，对固定的末端姿态，中间段有无穷多个解\n对于连杆参数，通常当连杆的非零参数越多，到达某一特定目标的方式也越多。以一个6R操作臂为例，下表展示了解的最大数目与等于零的连杆长度参数的数目之间的关系，非零参数越多，解的最大数目就越大\n$a_i$ 解的个数 $a_1=a_3=a_5=0$ $\\leqslant4$ $a_3=a_5=0$ $\\leqslant8$ $a_3=0$ $\\leqslant16$ 所有$a_i\\neq0$ $\\leqslant16$ 而关节运动范围则限制了解的选择\n逆运动学方程的解法 与线性方程组不同，非线性方程组没有通用的求解算法，我们只能用两大类解法来求解：封闭解（解析解，Closed-form Solutions）和数值解（Numerical Solutions）\n封闭解是一个关于方程自变量的解析函数，代入自变量即可解得因变量；数值解通过数值迭代求解。前者的缺点在于不是所有的非线性方程组都有封闭解，后者的缺点在于求解速度慢且不适应多解问题\n为此，我们在逆运动学中尽量避免数值解，在设计操作臂的结构时保证其存在封闭解\n逆运动学方程封闭解的解法包括代数解法和几何解法，前者纯靠代数运算，后者结合问题的几何性质，以下内容以数学计算为主，与机器人理论联系较少，可适当略读\n我们先研究开头举例的RRR操作臂来给出这两种解法，对于给定的目标位姿独立变量$(x,y,\\phi)$，求出三个关节的关节角$(\\theta_1,\\theta_2,\\theta_3)$\n代数解法 由前文求解的子空间，用目标位姿参数给出的位姿矩阵为：\n$^0_3T=\\begin{bmatrix}c_\\phi\u0026-s_\\phi\u00260\u0026x\\\\s_\\phi\u0026c_\\phi\u00260\u0026y\\\\0\u00260\u00261\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n由正向运动学，用关节变量给出的位姿矩阵为：\n$^0_3T=\\begin{bmatrix}c_{123}\u0026-s_{123}\u00260\u0026l_1c_1+l_2c_{12}\\\\s_{123}\u0026c_{123}\u00260\u0026l_1s_1+l_2s_{12}\\\\0\u00260\u00261\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n其中下标数字组合代表对应关节角的和，如$c_{12}$表示$\\cos(\\theta_1+\\theta_2+\\theta_3)$\n两矩阵联立得到四个非线性方程：\n$c_\\phi=c_{123}$①\n$s_\\phi=s_{123}$②\n$x=l_1c_1+l_2c_{12}$③\n$y=l_1s_1+l_2s_{12}$④\n对③和④同时平方再求和得：\n$x^2+y^2=l^2_1+l^2_2+2l_1l_2c_2$\n这里利用了三角函数两角和公式\n由此求解出$c_2=\\frac{x^2+y^2-l^2_1-l^2_2}{2l_1l_2}$\n上式有解的条件为等式右侧的值必须在$[-1,1]$之间，否则说明在物理结构上目标点位置太远，操作臂不可达\n假定目标点在工作空间内，则$s_2=\\pm\\sqrt{1-c^2_2}$\n$\\theta_2=\\textup{Atan2}(s_2,c_2)$\n式中正负符号的选择对应“肘部朝上”还是“肘部朝下”的多解问题\n接下来求$\\theta_1$\n令：\n$k_1=l_1+l_2c_2$\n$k_2=l_2s_2$\n则③和④可写成：\n$x=k_1c_1-k_2s_1$\n$y=k_1s_1+k_2c_1$\n求解该类方程可用变量代换改变常数$k_1$和$k_2$的形式，如果：\n$r=\\sqrt{k^2_1+k^2_2}$\n$\\gamma=\\textup{Atan2}(k_2,k_1)$\n则：\n$k_1=r\\cos\\gamma$\n$k_2=r\\sin\\gamma$\n则③和④可进一步写成：\n$\\frac{x}{r}=\\cos\\gamma\\cos\\theta_1-\\sin\\gamma\\sin\\theta_1$\n$\\frac{y}{r}=\\cos\\gamma\\sin\\theta_1-\\sin\\gamma\\cos\\theta_1$\n因此：\n$\\cos(\\gamma+\\theta_1)=\\frac{x}{r}$\n$\\sin(\\gamma+\\theta_1)=\\frac{y}{r}$\n得：\n$\\gamma+\\theta_1=\\textup{Atan2}(\\frac{y}{r},\\frac{x}{r})=\\textup{Atan2}(y,x)$\n从而：\n$\\theta_1=\\textup{Atan2}(y,x)-\\textup{Atan2}(k_2,k_1)$\n最后$\\theta_3$由$\\theta_1+\\theta_2+\\theta_3=\\phi$解出\n几何解法 画出以三个关节为顶点的三角形，由余弦定理得：\n$x^2+y^2=l^2_1+l^2_2-2l_1l_2\\cos(\\theta_2+\\pi)$\n由此求解出$c_2=\\frac{x^2+y^2-l^2_1-l^2_2}{2l_1l_2}$\n为求解出$\\theta_1$，需求出图中$\\psi$和$\\beta$的表达式\n$\\beta$是位置矢量与$\\hat{X}_0$的夹角，可得：\n$\\beta=\\textup{Atan2}(y,x)$\n可在三角形再次利用余弦定理解出$\\cos\\psi=\\frac{x^2+y^2+l^2_1-l^2_2}{2l_1\\sqrt{x^2+y^2}}$\n为使几何关系成立，求反余弦需使$0\\leqslant\\psi\\leqslant\\pi$\n于是$\\theta_1=\\beta\\pm\\psi$，当$\\theta_2\u003c0$取正，当$\\theta_2\u003e0$取负\n最后$\\theta_3$由$\\theta_1+\\theta_2+\\theta_3=\\phi$解出\n万能公式 对于单变量的三角函数超越方程，可用万能公式代换化为多项式方程\n令$u=\\tan\\frac{\\theta}{2}$\n则$\\cos\\theta=\\frac{1-u^2}{1+u^2}$，$\\sin\\theta=\\frac{2u}{1+u^2}$\n三轴相交的Pieper解法 尽管一般的六自由度机器人没有封闭解，但在某些特殊情况下还是可解的。Pieper提出了一种求解最后三个连续轴相交于一点的六自由度操作臂的方法，核心思想为让$\\theta_1$、$\\theta_2$、$\\theta_3$层层分离\n当最后三个轴相交时，连杆坐标系$\\{4\\}$、$\\{5\\}$、$\\{6\\}$的原点均位于这个交点上，因此：\n$^0P_{6ORG}=^0P_{4ORG}=^0_1T^1_2T^2_3T^3P_{4ORG}=\\begin{bmatrix}x\\\\y\\\\z\\\\1\\end{bmatrix}$\n其中，$^3P_{4ORG}$即$^3_4T$的第四列，由第三章中相邻连杆变换矩阵公式代入得：\n$^0P_{4ORG}=^0_1T^1_2T^2_3T\\begin{bmatrix}a_3\\\\-d_4s\\alpha_3\\\\d_4c\\alpha_3\\\\1\\end{bmatrix}$\n将$^2_3T$乘进去得：\n$^0P_{4ORG}=^0_1T^1_2T\\begin{bmatrix}f_1(\\theta_3)\\\\f_2(\\theta_3)\\\\f_3(\\theta_3)\\\\1\\end{bmatrix}$\n式中：\n$f_1=a_3c_3+d_4s\\alpha_3s_3+a_2$\n$f_2=a_3c\\alpha_2s_3-d_4s\\alpha_3c\\alpha_2c_3-d_4s\\alpha_2c\\alpha_3-d_3s\\alpha_2$\n$f_3=a_3s\\alpha_2s_3-d_4s\\alpha_3s\\alpha_2c_3+d_4c\\alpha_2c\\alpha_3+d_3c\\alpha_2$\n继续将$^0_1T^1_2T$乘进去得：\n$^0P_{4ORG}=\\begin{bmatrix}c_1g_1-s_1g_2\\\\s_1g_1+c_1g_2\\\\g_3\\\\1\\end{bmatrix}$①\n式中：\n$g_1=c_2f_1-s_2f_2+a_1$\n$g_2=s_2c\\alpha_1f_1+c_2c\\alpha_1f_2-s\\alpha_1f_3-d_2s\\alpha_1$\n$g_3=s_2s\\alpha_1f_1+c_2s\\alpha_1f_2+c\\alpha_1f_3+d_2c\\alpha_1$\n现在写出$^0P_{4ORG}$模的平方的表达式：\n$r=x^2+y^2+z^2=g_1^2+g_2^2+g_3^2$\n$r=f_1^2+f_2^2+f_3^2+a_1^2+d_2^2+2d_2f_3+2a_1(c_2f_1-s_2f_2)$\n上式与$z=g_3$联立得到一个方程组：\n$\\left\\{\\begin{matrix}r=(k_1c_2+k_2s_2)2a_1+k_3\\\\z=(k_1s_2-k_2c_2)s\\alpha_1+k_4\\end{matrix}\\right.$②\n式中：\n$k_1=f_1$\n$k_2=-f_2$\n$k_3=f_1^2+f_2^2+f_3^2+a_1^2+d_2^2+2d_2f_3$\n$k_4=f_3c\\alpha_1+d_2c\\alpha_1$\n该方程组的求解分三种情况：\n$1)$若$a_1=0$，则$r=k_3$，$r$已知，$k_3$是关于$\\theta_3$的一元函数，由万能公式解出$\\theta_3$\n$2)$若$s\\alpha_1=0$，则$z=k_4$，$z$已知，$k_4$是关于$\\theta_3$的一元函数，由万能公式解出$\\theta_3$\n$3)$否则，消元法消去$c_2$和$s_2$，得到：\n$\\frac{(r-k_3)^2}{4a_1^2}+\\frac{(z-k_4)^2}{s^2\\alpha_1}=k_1^2+k_2^2$\n由万能公式得到一个四次方程解出$\\theta_3$\n解出$\\theta_3$后，可由②解出$\\theta_2$，由①解出$\\theta_1$\n为了完成求解工作，还需要求出$\\theta_4$、$\\theta_5$、$\\theta_6$，由于这些轴相交，原点已经确定，故这些关节角只影响末端连杆的姿态。先利用已经解出的$\\theta_1$、$\\theta_2$、$\\theta_3$算出连杆坐标系$\\{4\\}$的初始姿态$^4_0R|_{\\theta_4=0}$，再计算出以此为参考坐标系的末端连杆的姿态描述：\n$^4_6R|_{\\theta_4=0}=^0_4R^{-1}|_{\\theta_4=0}{}_6^0R$\n用欧拉角定义最后三个关节角得到一个旋转矩阵后与$^4_6R|_{\\theta_4=0}$联立即可完成求解\n关于用欧拉角定义关节角： 由于不同关节角对应的转轴是不同连杆坐标系的关节轴，而欧拉角从始至终都是绕一个坐标系的主轴旋转，因此用欧拉角来描述关节角的变换过程时，我们有时需要使欧拉角在关节角的基础上多转$180^\\circ$，让欧拉角坐标系中的一个主轴能跟下一个连杆坐标系的关节轴对齐，便于用下一次旋转的欧拉角描述下一次旋转的关节角，可结合下图理解，其中连杆坐标系每次从蓝色变换到红色，欧拉角坐标系每次从橙色变换到绿色\n本章完\n","date":"2024-11-12T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep4.%E6%93%8D%E4%BD%9C%E8%87%82%E9%80%86%E8%BF%90%E5%8A%A8%E5%AD%A6/","title":"【机器人学导论】Ep4.操作臂逆运动学"},{"content":" 由于博主还未学习数字电路和计算机组成原理，因此本系列先开展单片机软件编程的内容，硬件结构的内容简单带过，会考虑安排在后续学习计划中，编程入门部分不会深入涉及单片机电路结构原理。博主已有C语言基础，因此相关内容不会从零开始赘述\n主要参考学习资料：B站【普中官方】51单片机手把手教学视频\n前置知识：C语言\n单片机套装：普中STC51单片机开发板A4标准版套餐7\n单片机介绍 单片机（Micro Controller Unit），简称MCU\n内部集成了CPU、RAM、ROM、定时器、中断系统、通讯接口等一系列电脑常用硬件功能\n单片机的任务是信息采集（依靠传感器）、处理（依靠CPU）和硬件设备（例如电机、LED等）的控制\n跟计算机相比，单片机是一个袖珍版计算机，一个芯片就能构成完整的计算机系统，但在性能上与计算机相差甚远，但单片机成本低、体积小、结构简单，在生活和工业控制领域大有所用的同时，学习使用单片机也是了解计算机原理与结构的最佳选择\n51单片机是对所有兼容Intel 8051指令系统的单片机的统称\nSTC89C52系列内部结构框图\nSTC89C52系列PDIP封装管脚图\n51单片机最小系统 能使51单片机工作的最简单最基础的电路统称为51单片机最小系统，由晶振电路、复位电路、电源电路构成，而要为单片机烧录程序还需要下载电路\n晶振电路 晶振电路为单片机正常工作提供一个时钟\n51单片机的时钟频率在0~40MHz运行，通常选用12MHz（便于计算时间）或11.059MHz（串行通信波特率为零）的晶振接在管脚18、19\n旁路电容作用：消除晶振接入电路一瞬间产生的电感干扰，一端接地，电容大小取决于晶振大小\n复位电路 复位电路提供系统复位的操作，当系统工作不正常或死机时可以重启系统\n复位的两种方式：手动按键复位（上图）和接通电源自动复位（下图）\nSTC89C51单片机为高电平复位，只要让引脚保持一段时间的高电平即可复位\n电源电路 单片机电压过大会烧毁电路，电压过小系统会运行不起来，因此需要挑选合适的电源电路\n下载电路 下载电路将编译文件下载到单片机\nC语言C51扩充内容 C51扩充数据类型 类型 长度 值域 说明 bit 位 0或1 位变量声明 sbit 位 0或1 特殊功能位声明 sfr 8位=1字节 0~255 特殊功能寄存器声明 sfr16 16位=2字节 0~65535 sfr的16位数据声明 * 1~3字节 对象的地址 例：\n1 2 3 4 sfr SCON = 0x98; //使用SCON控制单片机上地址为0x98的寄存器 sbit TI = SCON^1; //使用TI控制八位寄存器SCON位0~7中的位1 reg52头文件 reg52头文件定义了51单片机特殊功能寄存器和特殊功能位的名字以便我们访问\n1 2 3 #include \u0026lt;reg52.h\u0026gt;//直接在安装目录下寻找头文件 #include \u0026#34;reg52.h\u0026#34;//先在工程目录下寻找头文件，再到安装目录 //右键头文件可打开头文件内容 头文件内容（了解如何定义即可）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 /*-------------------------------------------------------------------------- REG52.H Header file for generic 80C52 and 80C32 microcontroller. Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc. All rights reserved. --------------------------------------------------------------------------*/ #ifndef __REG52_H__ #define __REG52_H__ /* BYTE Registers */ sfr P0 = 0x80; sfr P1 = 0x90; sfr P2 = 0xA0; sfr P3 = 0xB0; sfr PSW = 0xD0; sfr ACC = 0xE0; sfr B = 0xF0; sfr SP = 0x81; sfr DPL = 0x82; sfr DPH = 0x83; sfr PCON = 0x87; sfr TCON = 0x88; sfr TMOD = 0x89; sfr TL0 = 0x8A; sfr TL1 = 0x8B; sfr TH0 = 0x8C; sfr TH1 = 0x8D; sfr IE = 0xA8; sfr IP = 0xB8; sfr SCON = 0x98; sfr SBUF = 0x99; /* 8052 Extensions */ sfr T2CON = 0xC8; sfr RCAP2L = 0xCA; sfr RCAP2H = 0xCB; sfr TL2 = 0xCC; sfr TH2 = 0xCD; /* BIT Registers */ /* PSW */ sbit CY = PSW^7; sbit AC = PSW^6; sbit F0 = PSW^5; sbit RS1 = PSW^4; sbit RS0 = PSW^3; sbit OV = PSW^2; sbit P = PSW^0; //8052 only /* TCON */ sbit TF1 = TCON^7; sbit TR1 = TCON^6; sbit TF0 = TCON^5; sbit TR0 = TCON^4; sbit IE1 = TCON^3; sbit IT1 = TCON^2; sbit IE0 = TCON^1; sbit IT0 = TCON^0; /* IE */ sbit EA = IE^7; sbit ET2 = IE^5; //8052 only sbit ES = IE^4; sbit ET1 = IE^3; sbit EX1 = IE^2; sbit ET0 = IE^1; sbit EX0 = IE^0; /* IP */ sbit PT2 = IP^5; sbit PS = IP^4; sbit PT1 = IP^3; sbit PX1 = IP^2; sbit PT0 = IP^1; sbit PX0 = IP^0; /* P3 */ sbit RD = P3^7; sbit WR = P3^6; sbit T1 = P3^5; sbit T0 = P3^4; sbit INT1 = P3^3; sbit INT0 = P3^2; sbit TXD = P3^1; sbit RXD = P3^0; /* SCON */ sbit SM0 = SCON^7; sbit SM1 = SCON^6; sbit SM2 = SCON^5; sbit REN = SCON^4; sbit TB8 = SCON^3; sbit RB8 = SCON^2; sbit TI = SCON^1; sbit RI = SCON^0; /* P1 */ sbit T2EX = P1^1; // 8052 only sbit T2 = P1^0; // 8052 only /* T2CON */ sbit TF2 = T2CON^7; sbit EXF2 = T2CON^6; sbit RCLK = T2CON^5; sbit TCLK = T2CON^4; sbit EXEN2 = T2CON^3; sbit TR2 = T2CON^2; sbit C_T2 = T2CON^1; sbit CP_RL2 = T2CON^0; #endif 点亮第一个LED C51单片机GPIO介绍及LED线路 **GPIO（General Purpose Input Output）**是通用输入输出端口的简称，可以通过软件来控制其输入和输出\n51单片机引脚分类：\n电源引脚（Vcc/Vdd/Gnd/Vss） 晶振引脚（XTAL） 复位引脚（RST/Reset） 下载引脚（P3.0/P3.1） GPIO引脚（P0~P3） 详细管脚功能可在单片机手册中查询\nLED线路图\n程序1：点亮D1指示灯 1 2 3 4 5 6 7 #include \u0026#34;reg52.h\u0026#34; sbit LED1 = P2^0;//将控制D1灯的P2管脚第0位命名为LED1 void main() { LED1 = 0;//设置LED1为低电平，LED低电平0点亮，高电平1熄灭 } 效果图\n程序2：控制D1指示灯闪烁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026#34;reg52.h\u0026#34; typedef unsigned int u16; sbit LED1 = P2^0; void delay_10us(u16 time)//定义延时函数 { while(time --); //单次while循环时间约为10微秒，后续讲到定时器可以准确计时 } void main() { while(1) { LED1 = 0;//点亮D1灯 delay_10us(50000);//延时约488毫秒 LED1 = 1;//熄灭D1灯 delay_10us(50000); } } 程序3：LED流水灯 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026#34;reg52.h\u0026#34; #define LED_PORT P2//使用宏定义将P2端口定义 typedef unsigned char u8; typedef unsigned int u16; void delay_10us(u16 time) { while(time --); } void main() { u8 i = 0;//循环控制变量 while(1) { for(i = 0;i \u0026lt; 8;i++) { LED_PORT = ~(0x01 \u0026lt;\u0026lt; i);//见下文解读 delay_10us(50000); } } } LED_PORT用八位二进制数上的每一位分别控制八个LED灯的电平，要实现流水灯，其值应当这样变化：11111110→11111101→11111011→……\n不难想到可以通过左移运算符让二进制数的数位整体左移，但是二进制数左移后最右侧会补零而不是补一，因此采用对00000001左移再按位取反的方法\n代码中0x01采用十六进制是为了简洁\n额外介绍一个使用intrins头文件中左移右移的方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026#34;reg52.h\u0026#34; #include \u0026#34;intrins.h\u0026#34; #define LED_PORT P2 typedef unsigned char u8; typedef unsigned int u16; void delay_10us(u16 time) { while(time --); } void main() { u8 i = 0; LED_PORT =~ 0x01; while(1) { for(i = 0;i \u0026lt; 7;i++) { LED_PORT = _crol_(LED_PORT,1); //对LED_PORT左移1位，并将左侧移出去的数位补到右侧，即11111110→11111101 delay_10us(50000); } for(i = 0;i \u0026lt; 7;i++) { LED_PORT = _cror_(LED_PORT,1);//右移同理 delay_10us(50000); } } } 该程序进一步实现流水灯从左到右再从右到左来回闪烁的效果\n本章完\n","date":"2024-11-09T00:00:00Z","permalink":"https://INKEM.github.io/p/51%E5%8D%95%E7%89%87%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%AE%9E%E9%AA%8Cep1.%E7%82%B9%E4%BA%AEled/","title":"【51单片机】程序实验Ep1.点亮LED"},{"content":"修复了LaTex内联公式中下划线引起Markdown语法歧义导致公式无法正常显示的bug\n新增樱花背景和动态效果，默认模式为深色\n更改字体为初夏明朝体\nbug解决方法：\nhugo.yaml文件中第227行开始\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 markup: goldmark: extensions: passthrough: enable: true delimiters: block: - - \\[ - \\] - - $$ - $$ inline: - - \\( - \\) 在inline后新增行内分隔符\n1 2 - - $ - $ ","date":"2024-11-08T00:00:00Z","permalink":"https://INKEM.github.io/p/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%96%B0%E5%85%AC%E5%91%8A1/","title":"博客配置更新公告1"},{"content":" 主要参考学习资料及插图来源：\n《机器人学导论（第4版）》John J.Craig著\n台大机器人学之运动学——林沛群\n本章数理基础：矩阵的四则运算\n操作臂（正向）运动学 运动学讨论运动状态本身，不涉及产生运动的力\n连杆的描述 连杆参数 关节（Joint）分为移动关节和旋转关节，每个关节有一个自由度，对一个特定的轴移动或转动\n连杆（Link）为连接关节的杆件，视作刚体\n连杆的编号从固定基座开始，称固定基座为连杆0，第一个可动连杆为连杆1，以此类推，操作臂最末端的连杆为连杆n\n单个连杆：连杆长度和连杆扭转角\n连杆$i-1$连接了关节轴$i-1$和关节轴$i$，关节轴$i-1$和关节轴$i$之间公垂线长度$a_{i-1}$为连杆长度\n作一平面与两关节轴公垂线垂直，关节轴$i-1$和关节轴$i$在该平面上投影的夹角$\\alpha_{i-1}$为连杆扭转角（即空间中两直线夹角的定义） 平面图像表达空间关系可能存在视错觉，需结合文字描述来分析\n多杆串连：连杆偏距和关节角\n关节轴$i$上的两个相邻连杆沿公共轴线方向的距离$d_i$为连杆偏距\n两个相邻连杆绕公共轴线旋转的夹角$\\theta_i$为关节角\n对于首端连杆（固定基座）和末端连杆（末端执行器），习惯设定$a_0=a_n=0$，$\\alpha_0=\\alpha_n=0$\n对于关节$1$，若为转动关节，$\\theta_1$任取，$d_1=0$；若为移动关节，$d_1$任取，$\\theta_1=0$。关节$n$同理 连杆参数\n由此，机器人的每个连杆都可以用上述四个运动学参数来描述\n对于转动关节，$\\theta_i$为关节变量，其他三个连杆参数固定不变；对于移动关节，$d_i$为关节变量，其他三个连杆参数固定不变。这种用连杆参数描述机构运动关系的规则称为Denavit-Hartenberg方法（简称D-H表示法）\n连杆坐标系 中间连杆坐标系\n按以下方法确定连杆上的固连坐标系$\\{i\\}$：\n原点位于公垂线$a_i$与关节轴$i$的交点处\n$\\hat{Z}_i$轴与关节轴$i$重合\n$\\hat{X}_i$轴：当$a_i\\ne0$，沿$a_i$方向由关节$i$指向关节$i+1$；当$a_i=0$，垂直于$\\hat{Z}_i$和$\\hat{Z}_{i+1}$所在的平面\n$\\hat{Y}_i$轴由右手定则确定\n由于$\\hat{Z}_i$轴可选取两个方向，且当关节轴$i$与$i+1$相交时$\\hat{X}_i$轴可选取两个方向，建立的坐标系并不唯一 首末端连杆坐标系\n首端连杆坐标系$\\{0\\}$与关节$1$初始姿态时（关节变量为$0$）的坐标系$\\{1\\}$重合\n末端连杆坐标系$\\{N\\}$原点位于公垂线$a_{N-1}$与关节轴$\\{N\\}$交点处，$\\hat{X}_N$轴与$\\hat{X}_{N-1}$轴同向\n连杆坐标系中的D-H表示法\n$a_i=$沿$\\hat{X}_i$轴从${\\hat{Z}_i}$移动到$\\hat{Z}_{i+1}$的距离\n$\\alpha_i=$绕$\\hat{X}_i$轴从$\\hat{Z}_i$旋转到$\\hat{Z}_{i+1}$的角度\n$d_i=$沿$\\hat{Z}_i$轴从$\\hat{X}_{i-1}$移动到$\\hat{X}_i$的距离\n$\\theta_i=$绕$\\hat{Z}_i$轴从$\\hat{X}_{i-1}$旋转到$\\hat{X}_i$的角度\n$a_i\u003e0$，$\\alpha_i$、$d_i$和$\\theta_i$的值相对于坐标系主轴方向有正负\n建立连杆坐标系的步骤\n1.画出各关节轴的延长线\n2.找出相邻关节轴$i$和$i+1$的公垂线或交点，以关节轴$i$和$i+1$的交点或公垂线与关节轴$i$的交点作为连杆坐标系$\\{i\\}$的原点\n3.规定$\\hat{Z}_i$轴沿关节轴$i$的指向\n4.规定$\\hat{X}_i$轴沿公垂线的指向，若关节轴$i$与$i+1$相交则垂直于关节轴$i$与$i+1$所在的平面\n5.按右手定则确定$\\hat{Y}_i$轴\n6.补充首末端连杆坐标系\n坐标系的标准命名\n基（Base）坐标系$\\{B\\}$位于操作臂的基座上\n固定（Settle）坐标系$\\{S\\}$位置与任务相关，比如工作台的一个角上\n腕部（Wrist）坐标系$\\{W\\}$位于操作臂的末端连杆\n工具（Tool）坐标系$\\{T\\}$位于机器人所夹持工具的末端\n目标（Goal）坐标系$\\{G\\}$是对机器人移动工具到达的位置描述 操作臂运动学 连杆变换（Link Transformation） 我们希望用四个连杆参数建立起相邻连杆坐标系$\\{i\\}$和$\\{i-1\\}$之间的变换关系，即$^{i-1}P=^{i-1}_{i}T^iP$ 我们考虑借由图中标出的四个连杆参数将$\\{i-1\\}$一步步变换为$\\{i\\}$\n将$\\{i-1\\}$绕$\\hat{X}_{i-1}$旋转$\\alpha_{i-1}$得到$\\{R\\}$\n将$\\{R\\}$沿$\\hat{X}_R$平移$a_{i-1}$得到$\\{Q\\}$\n将$\\{Q\\}$绕$\\hat{Z}_Q$旋转$\\theta_i$得到$\\{P\\}$\n将$\\{P\\}$沿$\\hat{Z}_P$平移$d_i$得到$\\{i\\}$\n于是变换矩阵可写成：\n$^{i-1}P=^{i-1}_{i}T^iP=^{i-1}_RT^R_QT^Q_PT^P_iT^iP$\n$^{i-1}_{i}T=^{i-1}_RT^R_QT^Q_PT^P_iT=R_X(\\alpha_{i-1})D_X(a_{i-1})R_Z(\\theta_i)D_Z(d_i)$\n最终计算得到：\n$^{i-1}_{i}T=\\begin{bmatrix}c\\theta_i\u0026-s\\theta_i\u00260\u0026a_{i-1}\\\\s\\theta_ic\\alpha_{i-1}\u0026c\\theta_ic\\alpha_{i-1}\u0026-s\\alpha_{i-1}\u0026-s\\alpha_{i-1}d_i\\\\s\\theta_is\\alpha_{i-1}\u0026c\\theta_is\\alpha_{i-1}\u0026c\\alpha_{i-1}\u0026c\\alpha_{i-1}d_i\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n左上角$3\\times3$为旋转矩阵，最右列为$\\{i\\}$的原点相对于$\\{i-1\\}$的原点的位置矢量\n计算出各个连杆变换矩阵，将其连乘就能得到$\\{N\\}$相对于$\\{0\\}$的变换矩阵：\n$^0_NT=^0_1T^1_2T^2_3T…^{N-1}_NT$\n驱动器空间、关节空间和笛卡尔空间 对一个具有$n$个自由度的操作臂来说，它的所有连杆位置可由一组$n$个关节变量确定，这样的一组变量被称为$n\\times1$的关节向量，所有关节向量组成的空间称为关节空间（Joint Space）\n至此，我们研究的是如何将已知的关节空间描述转化为在笛卡尔空间（Cartesian Space）中的描述，称为正向运动学（Forward Kinematics），反之则为逆运动学（Inverse Kinematics）\n我们一直假设每个运动关节都是直接由某种驱动器驱动，但许多机器人有时用两个驱动器以差动的方式驱动一个关节，有时用直线驱动器通过四连杆机构来驱动旋转关节，而测量操作臂位置的传感器常常安装在驱动器上，因此进行控制器运算时必须把关节向量表示成一组驱动器变量方程，即驱动向量，组成的空间称为驱动器空间（Actuator Space） 本章完\n","date":"2024-11-06T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep3.%E6%93%8D%E4%BD%9C%E8%87%82%E6%AD%A3%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6/","title":"【机器人学导论】Ep3.操作臂（正向）运动学"},{"content":" 主要参考学习资料及插图来源：\n《机器人学导论（第4版）》John J.Craig著\n台大机器人学之运动学——林沛群\n本章前置知识：矢量和矩阵的四则运算-单位矩阵-转置矩阵-逆矩阵-分块矩阵\n空间描述和变换2 复杂姿态描述 上一节我们用旋转矩阵来描述姿态，但仅限于绕其中一个主轴的单自由度旋转，且我们得知姿态描述中包含三个独立变量，接下来我们讨论如何用三个参数描述空间中的任意姿态\n任何三自由度的旋转都可以拆解成三个单自由度的旋转，由于旋转不满足交换律，所以多次旋转的先后顺序需要明确定义。而旋转转轴也需要明确定义，围绕方向固定不动的参考坐标系主轴旋转的拆解方式称为固定角（Fixed Angles），围绕转动坐标系当下的主轴旋转的拆解方式称为欧拉角（Euler Angles）\nX-Y-Z固定角 给定参考坐标系$\\{A\\}$和我们要描述姿态的坐标系$\\{B\\}$，从固定角的视角来看，任意姿态的$\\{B\\}$都可以由以下过程表示：将$\\{B\\}$与$\\{A\\}$重合，先绕$\\hat{X}_A$旋转$\\gamma$角，再绕$\\hat{Y}_A$旋转$\\beta$角，最后绕$\\hat{Z}_A$旋转$\\alpha$角得到最终的$\\{B\\}$，因而可以推导$\\{B\\}$到$\\{A\\}$的等价旋转矩阵：$^A_BR_{XYZ}(\\gamma,\\beta,\\alpha)=R_Z(\\alpha)R_Y(\\beta)R_X(\\gamma)=\\begin{bmatrix}c\\alpha\u0026-s\\alpha\u00260\\\\s\\alpha\u0026c\\alpha\u00260\\\\0\u00260\u00261\\end{bmatrix}\\begin{bmatrix}c\\beta\u00260\u0026s\\beta\\\\0\u00261\u00260\\\\-s\\beta\u00260\u0026c\\beta\\end{bmatrix}\\begin{bmatrix}1\u00260\u00260\\\\0\u0026c\\gamma\u0026-s\\gamma\\\\0\u0026s\\gamma\u0026c\\gamma\\end{bmatrix}$\n（矩阵书写顺序与实际旋转操作顺序相反，从旋转一个矢量的角度来看，是因为旋转矩阵乘在矢量的左边，所以右侧的矩阵会先与矢量相乘）\n(等价旋转矩阵下标表示绕主轴旋转的操作顺序，可以根据实际情况调换)\n最终得到：\n$^A_BR_{XYZ}(\\gamma,\\beta,\\alpha)=\\begin{bmatrix}c\\alpha c\\beta\u0026c\\alpha c\\beta s\\gamma-s\\alpha c\\gamma\u0026c\\alpha s\\beta c\\gamma+s\\alpha s\\gamma\\\\s\\alpha c\\beta\u0026s\\alpha s\\beta s\\gamma+c\\alpha c\\gamma\u0026s\\alpha s\\beta c\\gamma-c\\alpha s\\gamma\\\\-s\\beta\u0026c\\beta s\\gamma\u0026c\\beta c\\gamma\\end{bmatrix}$①\n反过来，如果已知旋转矩阵各个元素的数值，逆求三个固定角，令\n$^A_BR_{XYZ}(\\gamma,\\beta,\\alpha)=\\begin{bmatrix}r_{11}\u0026r_{12}\u0026r_{13}\\\\r_{21}\u0026r_{22}\u0026r_{23}\\\\r_{31}\u0026r_{32}\u0026r_{33}\\end{bmatrix}$\n则\n$\\left\\{\\begin{matrix}\\beta=\\mathrm{Atan2}(-r_{31},\\sqrt{r_{11}^2+r_{21}^2})\\\\ \\alpha=\\mathrm{Atan2}(\\frac{r_{21}}{c\\beta},\\frac{r_{11}}{c\\beta})\\\\ \\gamma=\\mathrm{Atan2}(\\frac{r_{31}}{c\\beta},\\frac{r_{33}}{c\\beta})\\end{matrix}\\right.$\n$(\\beta\\neq 90^{\\circ})$\n（式中$\\mathrm{Atan2}(y,x)=arctan\\frac{y}{x}$，即反正切函数的双参量表示法，可以根据$x$和$y$的符号判别角的象限，而单输入值的反正切函数无法区分）\n上式中$\\cos\\beta$只考虑正根以得到单解来建立各种姿态表示法之间一一对应的映射函数，但在某些情况下有必要求出所有的解，会在第四章说明\n如果$\\beta=90^{\\circ}$，则只能求出$\\alpha$和$\\gamma$的和或差，在这种情况下一般取$\\alpha=0$，$\\gamma=\\left\\{\\begin{matrix}\\mathrm{Atan2}(r_{12},r_{22})(\\beta=90^{\\circ})\\\\-\\mathrm{Atan2}(r_{12},r_{22})(\\beta=-90^{\\circ})\\end{matrix}\\right.$\n结合式①即可理解求解公式的推导\nZ-Y-X欧拉角 给定参考坐标系$\\{A\\}$和我们要描述姿态的坐标系$\\{B\\}$，从欧拉角的视角来看，任意姿态的$\\{B\\}$都可以由以下过程表示：将$\\{B\\}$与$\\{A\\}$重合，先绕$\\hat{Z}_B$转$\\alpha$角得到$\\{B'\\}$，再绕$\\hat{Y}_{B'}$转$\\beta$角得到$\\{B''\\}$，最后绕$\\hat{X}_{B''}$转$\\gamma$角得到最终的$\\{B\\}$（欧拉角选取转轴的顺序与固定角相反，原因会在下面解释）\n借由$\\{B\\}$的中间状态$\\{B'\\}$和$\\{B''\\}$和欧拉角的定义表达$^A_BR$，我们可以写出：\n$^A_BR=^A_{B'}R^{B'}_{B''}R^{B''}_{B}R$\n即：\n$^A_BR_{X'Y'Z'}(\\gamma,\\beta,\\alpha)=R_{Z'}(\\alpha)R_{Y'}(\\beta)R_{X'}(\\gamma)=\\begin{bmatrix}c\\alpha\u0026-s\\alpha\u00260\\\\s\\alpha\u0026c\\alpha\u00260\\\\0\u00260\u00261\\end{bmatrix}\\begin{bmatrix}c\\beta\u00260\u0026s\\beta\\\\0\u00261\u00260\\\\-s\\beta\u00260\u0026c\\beta\\end{bmatrix}\\begin{bmatrix}1\u00260\u00260\\\\0\u0026c\\gamma\u0026-s\\gamma\\\\0\u0026s\\gamma\u0026c\\gamma\\end{bmatrix}$\n相乘后得：\n$^A_BR_{X'Y'Z'}(\\gamma,\\beta,\\alpha)=\\begin{bmatrix}c\\alpha c\\beta\u0026c\\alpha c\\beta s\\gamma-s\\alpha c\\gamma\u0026c\\alpha s\\beta c\\gamma+s\\alpha s\\gamma\\\\s\\alpha c\\beta\u0026s\\alpha s\\beta s\\gamma+c\\alpha c\\gamma\u0026s\\alpha s\\beta c\\gamma-c\\alpha s\\gamma\\\\-s\\beta\u0026c\\beta s\\gamma\u0026c\\beta c\\gamma\\end{bmatrix}$\n我们发现，这个结果与以相反顺序绕固定轴旋转三次得到的结果完全相同，因而逆求解公式也相同\n可以这样更深地理解固定角与欧拉角之间的关系：两种姿态描述方法不同的解释在于运用了旋转矩阵两种不同的作用，一是在同一个坐标系下旋转矢量，二是将矢量的坐标在不同坐标系之间变换。固定角是用前者描述$\\{A\\}$的三个主轴矢量旋转到$\\{B\\}$的过程，而欧拉角是用后者将在$\\{B\\}$下的主轴矢量坐标一步步借由中间坐标系变换到$\\{A\\}$\n其他转角组合 在实际情况我们会遇到更多按不同顺序进行绕主轴的三个旋转，所有排列总共24种，固定角12种，欧拉角12种，都被称为转交排列设定法（需要注意第一次转动和最后一次转动绕同一个主轴也是一种排列，只要保证相邻两次切换围绕的主轴即可）\n除此之外，姿态描述还有轴角表示法和四元数表示法，完全解释篇幅较长，若有余力我会写拓展专题\n映射（Mapping） 映射是将矢量从一个坐标系投影到另一个坐标系的变换\n坐标平移 我们用矢量$^AP_{BORG}$表示$\\{B\\}$的原点相对于$\\{A\\}$的位置\n当$\\{A\\}$与$\\{B\\}$姿态相同，位置不同时，由矢量加法的几何意义：\n$^AP=^BP+^AP_{BORG}$\n坐标旋转 当$\\{A\\}$与$\\{B\\}$位置相同，姿态不同时，由上一篇所介绍的旋转矩阵转换矢量坐标的作用：\n$^AP=^A_BR^BP$\n一般变换 当$\\{A\\}$与$\\{B\\}$位置和姿态都不同时，可以先将$\\{B\\}$旋转到和$\\{A\\}$相同的姿态得到$\\{B'\\}$，以$\\{B'\\}$为中间坐标系对$^BP$进行旋转变换，再作$\\{B'\\}$到$\\{A\\}$的平移变换：\n$^AP=^A_BR^BP+^AP_{BORG}$②\n为了简化算式，我们将平移和旋转整合起来，定义齐次变换矩阵：\n$^A_BT=\\begin{bmatrix}^A_BR\u0026^AP_{BORG}\\\\\\mathbf{0}^T\u00261\\end{bmatrix}$\n其中$\\mathbf{0}^T$表示三维零向量的转置\n这样式②可写为：\n$\\begin{bmatrix}^AP\\\\1\\end{bmatrix}=\\begin{bmatrix}^A_BR\u0026^AP_{BORG}\\\\\\mathbf{0}^T\u00261\\end{bmatrix}\\begin{bmatrix}^BP\\\\1\\end{bmatrix}$\n这样我们就以一个简单的矩阵形式表示了一般变换的旋转和平移\n复合变换 复合变换借用中间坐标系求解两坐标系的相对关系\n例如已知$\\{C\\}$相对于$\\{B\\}$，并且已知$\\{B\\}$相对于$\\{A\\}$，已知$^CP$求$^AP$，可先将$^CP$变换成$^BP$再变换成$^AP$：\n$^BP=^B_CT^CP$\n$^AP=^A_BT^BP=^A_BT^B_CT^CP$\n由此定义$^A_CP=^A_BT^B_CT$\n逆变换 已知$^A_BT$求$^B_AT$可以直接对$^A_BT$求逆矩阵，但还可以利用变换的性质\n关于$^B_AT$的旋转变换，由旋转矩阵的性质可知$^B_AR=^A_BR^T$\n关于$^B_AT$的平移变换，将$^AP_{BORG}$变换成$\\{B\\}$中的描述：$^B(^AP_{BORG})=^B_AT^AP_{BORG}=^B_AR^AP_{BORG}+^BP_{AORG}$\n上式左侧为零，可得：$^BP_{AORG}=-^B_AR^AP_{BORG}=-^A_BR^T{}^AP_{BORG}$\n由此$^B_AT=\\begin{bmatrix}^B_AR^T\u0026-^A_BR^T{}^AP_{BORG}\\\\\\mathbf{0}^T\u00261\\end{bmatrix}=^A_BT^{-1}$\n变换方程 图中$\\{D\\}$可以用两种不同的方式表达成变换相乘的方式：\n$^U_DT=^U_AT^A_DT$\n$^U_DT=^U_BT^B_CT^C_DT$\n两个表达式构造成一个变换方程：\n$^U_AT^A_DT=^U_BT^B_CT^C_DT$\n如有$n$个未知变换和$n$个变换方程，变换可由变换方程解出。设上式中所有变换除了$^B_CT$外均已知，可解出：\n$^B_CT=^U_BT^{-1}{}^U_AT^A_DT^C_DT^{-1}$\n算子（Operator） 算子是对矢量进行平移和旋转操作的变换\n$^A_BT$除了变换以外，也可以充当算子对矢量或点进行平移或转动\n平移算子 将$^AP_1$指向的点沿$^AQ$进行平移得到一个新的矢量$^AP_2$，计算如下：\n$^AP_2=^AP_1+^AQ$\n用矩阵算子写出平移变换，有：\n$^AP_2=D(Q)^AP_1$\n算子$D_Q$可以被看成是一个特殊形式的齐次变换：\n$D(Q)=\\begin{bmatrix}I\u0026^AQ\\\\\\mathbf{0}^T\u00261\\end{bmatrix}$\n旋转算子 由上一篇所介绍的旋转矩阵描述刚体转动状态的作用，可以得到旋转算子的定义：将矢量$^AP_1$用旋转$R$变换成一个新的矢量$^AP_2$\n当一个旋转矩阵作为算子时无需写出上下标，因为不涉及两个坐标系，但我们将用另一个符号说明是绕哪个轴旋转的，写成：\n$^AP_2=R_K(\\theta)^AP_1$\n符号$R_K(\\theta)$是一个旋转算子，表示绕$\\hat{K}$轴旋转$\\theta$角度，例如绕$\\hat{Z}$轴旋转$\\theta$的算子：\n$R_z(\\theta)=\\begin{bmatrix}c\\theta\u0026-s\\theta\u00260\u00260\\\\s\\theta\u0026c\\theta\u00260\u00260\\\\0\u00260\u00261\u00260\\\\0\u00260\u00260\u00261\\end{bmatrix}$\n变换算子 与一般变换一样，将平移和旋转整合起来我们得到通用的变换算子。因为只涉及一个坐标系，所以没有上下标。算子$T$将矢量$^AP_1$平移并旋转得到一个新矢量：$^AP_2=T^AP_1$\n齐次变换矩阵 源于旋转矩阵在上一篇所讲的三个作用，在这一篇我们也探索出了齐次变换矩阵的三个作用：\n1.描述位姿：$^A_BT$表示$\\{B\\}$相对于$\\{A\\}$，其中$^A_BR$的各列是定义$\\{B\\}$主轴方向的单位矢量，$^AP_{BORG}$确定了$\\{B\\}$的原点\n2.变换映射：$^A_BT$是映射$^BP\\rightarrow^AP$\n3.变换算子：$^A_BT$将$^AP_1$变换为$^AP_2$\n本章我们只考虑了位置矢量的变换，而速度矢量和力矢量由于类型不同，它们的变换形式也不同，将在第五章讨论\n本章完\n","date":"2024-11-03T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep2.2.%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%8F%98%E6%8D%A2-2/","title":"【机器人学导论】Ep2.2.空间描述和变换-2"},{"content":" 主要参考学习资料：\n《机器人学导论（第4版）》John J.Craig著\n台大机器人学之运动学——林沛群（本文插图来自该课程课件）\n本章前置知识：矢量和矩阵的四则运算-单位矩阵-转置矩阵-逆矩阵-正交矩阵\n空间描述和变换 描述 我们用$\\{A\\}$来表示一个坐标系(Frame)\n讨论问题之前，我们需要建立一个世界坐标系(World Frame)，之后定义的位置和姿态都是参照世界坐标系定义的笛卡尔坐标系\n一个平面中的物体拥有沿$x$轴、$y$轴两个方向移动的自由度和绕垂直于平面的轴转动的自由度（Degree Of Freedom，可简记为DOF），即两个移动自由度和一个转动自由度，共三个自由度\n同理，一个空间中的物体拥有沿$x$轴、$y$轴、$z$轴三个方向移动的自由度和绕这三个轴转动的自由度，即三个移动自由度和三个转动自由度，共六个自由度\n位置描述 位置描述涵盖刚体在三个方向上的移动自由度\n一旦建立了坐标系，我们可以用一个$3\\times 1$的位置矢量给世界坐标系中的任何点定位\n矢量用一个左上标来表明其定义在哪个坐标系，例如$^AP$的元素数值是沿坐标系$\\{A\\}$三个主轴方向上的投影，矢量的各个元素用下标$x$、$y$和$z$来标明：\n$^AP=^A\\begin{bmatrix}p_x\\\\p_y\\\\p_z\\end{bmatrix}$\n（其中矩阵左上标表示矩阵中坐标都是相对于该坐标系而言，由于格式输入限制位置偏下）\n姿态描述 姿态描述涵盖刚体三个方向上的转动自由度\n我们可以在刚体上固定一个坐标系$\\{B\\}$，用$\\{B\\}$相对于$\\{A\\}$的描述来表示物体的姿态，而$\\{B\\}$可以用该坐标系三个主轴方向的单位矢量来确定\n我们用$\\hat{X}_B$、$\\hat{Y}_B$和$\\hat{Z}_B$来表示$\\{B\\}$主轴方向的单位矢量，当$\\{A\\}$作为参考坐标系时，它们被写为$^A\\hat{X}_B$、$^A\\hat{Y}_B$和$^A\\hat{Z}_B$\n将这三个单位矢量按照$^A\\hat{X}_B$、$^A\\hat{Y}_B$和$^A\\hat{Z}_B$的顺序排列组成一个$3\\times3$的矩阵，称为旋转矩阵(Rotation Matrix)。表达$\\{B\\}$相对于$\\{A\\}$的旋转矩阵记为$_B^AR$\n$_B^AR$=$\\begin{pmatrix}^A\\hat{X}_B\u0026^A\\hat{Y}_B\u0026^A\\hat{Z}_B\\end{pmatrix}$\n又$^A\\hat{X}_B$、$^A\\hat{Y}_B$和$^A\\hat{Z}_B$是以$\\{A\\}$为参考，所以矢量中各个元素的数值为$\\hat{X}_B$、$\\hat{Y}_B$和$\\hat{Z}_B$分别在$\\{A\\}$三个主轴方向上的投影长度，因而上式可以进一步写为\n$_B^AR=\\begin{pmatrix}^A\\hat{X}_B\u0026^A\\hat{Y}_B\u0026^A\\hat{Z}_B\\end{pmatrix}=\\begin{bmatrix}\\hat{X}_B\\cdot\\hat{X}_A\u0026\\hat{Y}_B\\cdot\\hat{X}_A\u0026\\hat{Z}_B\\cdot\\hat{X}_A\\\\\\hat{X}_B\\cdot\\hat{Y}_A\u0026\\hat{Y}_B\\cdot\\hat{Y}_A\u0026\\hat{Z}_B\\cdot\\hat{Y}_A\\\\\\hat{X}_B\\cdot\\hat{Z}_A\u0026\\hat{Y}_B\\cdot\\hat{Z}_A\u0026\\hat{Z}_B\\cdot\\hat{Z}_A\\end{bmatrix}$\n又矩阵中各个矢量均为单位矢量，点积之值也是$\\hat{X}_B$、$\\hat{Y}_B$和$\\hat{Z}_B$对于$\\{A\\}$的方向余弦，该矩阵又称为方向余弦矩阵(Direction Cosine Matrix)\n综上，我们用旋转矩阵描述了刚体的姿态\n旋转矩阵 接下来重点介绍旋转矩阵的性质与作用\n性质 将旋转矩阵中各个点积前后矢量互换，我们有如下推导（其中右上标T为转置符号）：\n$_B^AR=\\begin{pmatrix}^A\\hat{X}_B\u0026^A\\hat{Y}_B\u0026^A\\hat{Z}_B\\end{pmatrix}=\\begin{bmatrix}\\hat{X}_B\\cdot\\hat{X}_A\u0026\\hat{Y}_B\\cdot\\hat{X}_A\u0026\\hat{Z}_B\\cdot\\hat{X}_A\\\\\\hat{X}_B\\cdot\\hat{Y}_A\u0026\\hat{Y}_B\\cdot\\hat{Y}_A\u0026\\hat{Z}_B\\cdot\\hat{Y}_A\\\\\\hat{X}_B\\cdot\\hat{Z}_A\u0026\\hat{Y}_B\\cdot\\hat{Z}_A\u0026\\hat{Z}_B\\cdot\\hat{Z}_A\\end{bmatrix}$ $=\\begin{bmatrix}\\hat{X}_A\\cdot\\hat{X}_B\u0026\\hat{X}_A\\cdot\\hat{Y}_B\u0026\\hat{X}_A\\cdot\\hat{Z}_B\\\\\\hat{Y}_A\\cdot\\hat{X}_B\u0026\\hat{Y}_A\\cdot\\hat{Y}_B\u0026\\hat{Y}_A\\cdot\\hat{Z}_B\\\\\\hat{Z}_A\\cdot\\hat{X}_B\u0026\\hat{Z}_A\\cdot\\hat{Y}_B\u0026\\hat{Z}_A\\cdot\\hat{Z}_B\\end{bmatrix}=\\begin{bmatrix}\\hat{X}_A{^T}\\\\\\hat{Y}_A{^T}\\\\\\hat{Z}_A{^T}\\end{bmatrix}$$=\\begin{pmatrix}^A\\hat{X}_B\u0026^A\\hat{Y}_B\u0026^A\\hat{Z}_B\\end{pmatrix}^T=^B_AR^T$\n由此$^A_BR=^B_AR^T$\n又由：\n$^A_BR{^T}^A_BR=\\begin{bmatrix}\\hat{X}_A{^T}\\\\\\hat{Y}_A{^T}\\\\\\hat{Z}_A{^T}\\end{bmatrix}\\begin{pmatrix}^A\\hat{X}_B\u0026^A\\hat{Y}_B\u0026^A\\hat{Z}_B\\end{pmatrix}=I_3$\n其中$I_3$是$3\\times3$的单位矩阵，因此：\n$^A_BR=^B_AR^{-1}=^B_AR{^T}$\n即$^B_AR$的转置矩阵等于它的逆矩阵，又同时等于$^A_BR$。由线性代数可知，前者是正交矩阵的性质\n旋转矩阵有九个数字，但只有三个矢量两两垂直、均为单位矢量总共六个条件约束，因此只有三个数字是独立变量，与空间中转动具有三个自由度相符\n作用 除了前文所讲的描述一个刚体的姿态外，旋转矩阵还有两个作用\n1.转换矢量的坐标\n矢量$P$相对于$\\{B\\}$的坐标表示：$^BP=^Bp_x\\hat{X}_B+^Bp_y\\hat{Y}_B+^Bp_z\\hat{Z}_B$\n矢量$P$相对于$\\{A\\}$的坐标表示：$^AP=^Ap_x\\hat{X}_A+^Ap_y\\hat{Y}_A+^Ap_z\\hat{Z}_A$\n$^BP$和$^AP$只是坐标表示不同，本质上是同一个矢量，由此矢量$P$相对于$\\{A\\}$的坐标也可以用$^BP$在$\\{A\\}$三个主轴上的投影计算：\n$^Ap_x=^BP\\hat{X}_A=^Bp_x\\hat{X}_B\\hat{X}_A+^Bp_y\\hat{Y}_B\\hat{X}_A+^Bp_z\\hat{Z}_B\\hat{X}_A$\n$^Ap_y=^BP\\hat{Y}_A=^Bp_x\\hat{X}_B\\hat{Y}_A+^Bp_y\\hat{Y}_B\\hat{Y}_A+^Bp_z\\hat{Z}_B\\hat{Y}_A$\n$^Ap_z=^BP\\hat{X}_A=^Bp_x\\hat{X}_B\\hat{Z}_A+^Bp_y\\hat{Y}_B\\hat{Z}_A+^Bp_z\\hat{Z}_B\\hat{Z}_A$\n用矩阵表示则为：\n$^AP=^A\\begin{bmatrix}p_x\\\\p_y\\\\p_z\\end{bmatrix}=\\begin{bmatrix}\\hat{X}_B\\cdot\\hat{X}_A\u0026\\hat{Y}_B\\cdot\\hat{X}_A\u0026\\hat{Z}_B\\cdot\\hat{X}_A\\\\\\hat{X}_B\\cdot\\hat{Y}_A\u0026\\hat{Y}_B\\cdot\\hat{Y}_A\u0026\\hat{Z}_B\\cdot\\hat{Y}_A\\\\\\hat{X}_B\\cdot\\hat{Z}_A\u0026\\hat{Y}_B\\cdot\\hat{Z}_A\u0026\\hat{Z}_B\\cdot\\hat{Z}_A\\end{bmatrix}^B\\begin{bmatrix}p_x\\\\p_y\\\\p_z\\end{bmatrix}=^A_BR^BP$\n由此得到$\\{B\\}$相对于$\\{A\\}$的旋转矩阵可以将$P$的表示由相对于$\\{B\\}$转换为相对于$\\{A\\}$\n2.描述刚体转动的状态\n分别研究坐标系绕三个主轴旋转的状态\n以$\\{A\\}$绕$\\hat{Z}_A$逆时针旋转$\\theta$（以后不标明旋转方向默认为逆时针旋转）得到$\\{B\\}$为例，计算此时$\\{B\\}$相对于$\\{A\\}$的旋转矩阵得：\n$^A_BR=\\begin{bmatrix}\\cos\\theta\u0026-\\sin\\theta\u00260\\\\\\sin\\theta\u0026\\cos\\theta\u00260\\\\0\u00260\u00261\\end{bmatrix}=\\begin{bmatrix}c\\theta\u0026-s\\theta\u00260\\\\s\\theta\u0026c\\theta\u00260\\\\0\u00260\u00261\\end{bmatrix}$\n（由于我们将在计算中用到许多三角函数，因此三角函数用对应首字母简记）\n由此，我们将绕$\\hat{Z}_A$旋转$\\theta$以这种方式计算出来的旋转矩阵记为$R_{\\hat{Z}_A}(\\theta)$，则：\n$R_{\\hat{Z}_A}(\\theta)=\\begin{bmatrix}c\\theta\u0026-s\\theta\u00260\\\\s\\theta\u0026c\\theta\u00260\\\\0\u00260\u00261\\end{bmatrix}$\n同理得到：\n$R_{\\hat{X}_A}(\\theta)=\\begin{bmatrix}1\u00260\u00260\\\\0\u0026c\\theta\u0026-s\\theta\\\\0\u0026s\\theta\u0026c\\theta\\end{bmatrix}$\n$R_{\\hat{Y}_A}(\\theta)=\\begin{bmatrix}c\\theta\u00260\u0026s\\theta\\\\0\u00261\u00260\\\\-s\\theta\u00260\u0026c\\theta\\end{bmatrix}$\n通过接下来的例子我们来理解这类旋转矩阵如何描述刚体转动的状态\n$^AP=^A(p_x\\;p_y\\;p_z)^T$对$\\hat{X}_A$旋转$\\theta$得到$^AP'$，$^AP'=?$\n不妨让$\\{A\\}$跟着$^AP$同步旋转，得到$\\{A'\\}$，那么$^AP'$相对于$\\{A'\\}$的坐标跟$^AP$相对于$\\{A\\}$的坐标相等，而后者已知\n又通过题目条件和前文定义我们知道$^A_{A'}R=R_{\\hat{X}_A}(\\theta)=\\begin{bmatrix}1\u00260\u00260\\\\0\u0026c\\theta\u0026-s\\theta\\\\0\u0026s\\theta\u0026c\\theta\\end{bmatrix}$\n利用旋转矩阵转换矢量坐标的作用，我们可以把$^AP'$相对于$\\{A'\\}$的坐标转换为相对于原坐标系$\\{A\\}$的坐标，即：\n$^AP'=^A_{A'}R^AP=R_{\\hat{X}_A}(\\theta)^AP$\n所以旋转矩阵$R(\\theta)$可以计算矢量在同一坐标系下旋转后的坐标\n位姿描述 位置和姿态的组合称为位姿\n我们同样用$\\{A\\}$来表示一个位姿\n以$\\{A\\}$为参考描述位姿$\\{B\\}$，结合前文的位置描述和姿态描述，我们用$^A_BR$表示$\\{B\\}$的姿态，用$^AP_{BORG}$表示$\\{B\\}$的原点的位置矢量（下标ORG意为原点origin），于是位姿描述记为：\n$\\{B\\}=\\{^A_BR,{\\,}^AP_{BORG}\\}$\n下一篇文章将讲述本章后半部分空间中的变换内容\n","date":"2024-11-01T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep2.1.%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0%E5%92%8C%E5%8F%98%E6%8D%A2-1/","title":"【机器人学导论】Ep2.1.空间描述和变换-1"},{"content":" 主要参考学习资料：\n《机器人学导论（第4版）》John J.Craig著\n台大机器人学之运动学——林沛群\n前置课程：博主目前只对线性代数和理论力学方面有一定基础，学习过程中遇到额外必要的前置知识我会做补充或者开辟新的知识笔记专栏\n概述 本章简要介绍机器人学导论中的基础名词和学习内容，具体内容将在后续展开\n知识体系 本知识笔记以《机器人学导论》一书为主，书中内容结构如下：\n第1章 概述\n第2章 空间描述和变换\n第3章 操作臂运动学\n第4章 操作臂逆运动学\n第5章 雅可比：速度和静力\n第6章 操作臂动力学\n第7章 轨迹生成\n第8章 操作臂的机构设计\n第9章 操作臂的线性控制\n第10章 操作臂的非线性控制\n第11章 操作臂的力控制\n第12章 机器人编程语言及编程系统\n第13章 离线编程系统\n操作臂的力学与控制 在机器人领域，机械臂（操作臂）是起步最早、现今最成熟的技术，而机器人学知识也跟随此路线发展而来，因此对机器人知识的学习从机械臂开始\n以下内容将按顺序在书中后面12个章节一一讨论\n位置和姿态的描述 研究机器人学需要考虑三维空间中物体的空间状态，可以用两个重要特性描述：位置和姿态\n为了用数学方法表示和计算这些参量，我们一般在物体上设置一个坐标系（位姿），然后在某个参考坐标系中描述该位姿的位置和姿态\n任意位姿都能用作参考坐标系，因此我们经常将物体空间属性的描述从一个位姿变换到另一个位姿 操作臂正运动学 运动学研究物体的运动而不考虑引起这种运动的力，操作臂运动学的研究对象为运动的全部几何和时间特性（位置、速度、加速度和位置变量对于其他变量的高阶微分）\n大部分操作臂由刚性连杆组成，相邻连杆由关节连接，允许相对转动\n如果是转动关节，两个相邻连杆的相对位移被称为关节角；如果是滑（移）动关节，位移被称为关节偏移量\n操作臂自由度的个数是使操作臂具有确定运动时必须给出的独立运动的数目，或操作臂独立驱动的关节数\n组成操作臂运动链的自由端称为末端执行器，通常采用末端执行器上的工具坐标系相对于操作臂固定底座的基坐标系来描述操作臂的位置\n正运动学根据已知的各个关节的关节角计算末端执行器的位置和姿态，这个过程被称为从关节空间描述到笛卡尔空间描述的操作臂位置表示\n笛卡尔空间：用三个变量描述空间一点的位置，用另外三个变量描述物体的姿态\n操作臂逆运动学 逆运动学根据给定的末端执行器的位置和姿态计算所有关节可达到给定位置和姿态的关节角\n逆运动学计算涉及的运动学方程的解的存在性定义了操作臂的工作空间 （末端执行器活动范围） 速度，静力，奇异点 除了静态定位问题，对于运动中的操作臂，我们定义雅可比矩阵来方便地进行机构的速度分析\n雅可比矩阵定义了从关节空间速度向笛卡尔空间速度的映射\n在奇异点，这种映射不可逆（给定的末端执行器的运动状态超出了关节运动能力的限制），同时某些关节的运动可能无法引起末端执行器的有效运动，称为局部退化\n当操作臂接触工件或工作面，并施加一个静力，需要解决如何设定关节力矩来产生要求的接触力和力矩\n动力学 动力学研究产生运动所需要的力\n控制操作臂末端执行器的运动速度需要关节驱动器产生一组复杂的扭矩函数来实现，取决于末端执行器的运动路径和速度、连杆的质量特性和负载、关节摩擦等，扭矩函数通过操作臂动力学方程来求解，用于操作臂的控制和仿真\n轨迹生成 计算每个关节运动的连续函数来平稳控制操作臂从一点运动到另外一点的过程为轨迹生成\n操作臂从起点到目标点需要确定一些中间路径点，通过一系列路径点的连续函数被称为样条函数\n笛卡尔轨迹生成将末端执行器的期望运动转化为一系列等效的关节运动 操作臂设计与传感器 为特定任务设计的机器人为专用机器人，能够完成各种任务的为通用机器人。从经济角度考虑，操作臂的机械设计由期望执行的任务决定，设计者需考虑几何尺寸、速度、承载能力、关节的数量与几何布局等因素，这些因素影响了操作臂工作空间的大小和性质、操作臂结构的刚度以及其他属性\n完整的操作臂设计还包括：驱动器的选择和位置、传动系统以及内部位置传感器（有时是力传感器）\n线性位置控制 位置控制系统不仅包括理想状态下产生期望运动的力矩的计算，更要考虑自动补偿由于系统参数引起的误差以及抑制引起系统偏离期望轨迹的扰动。为此，通过控制算法对位置和速度传感器进行检测，计算出驱动器的扭矩指令。第9章讨论基于操作臂动力学的线性近似得出的控制算法\n非线性位置控制 考虑操作臂完整的非线性动力学的非线性控制算法，比简单的线性控制方法性能更好\n力控制 当操作臂在自由空间中运动时，只有位置控制有意义\n当接触零件、工具或工作表面时，操作臂控制力的能力极其重要\n当操作臂在部分方向受到作用表面约束时，需要采用混合控制方式，在某些方向用位置控制规律来控制，而其余方向用力控制规律来控制\n机器人编程 机器人编程语言是用户和工业机器人交互的接口\n操作者指定操作臂末端执行器的一个特殊点为操作点，也叫TCP（工具中心点）\n通过一系列路径点确定路径，同时确定不同路径段上TCP的速度，依据这些输入，轨迹生成算法规划处机器人运动的所有细节。轨迹生成的输入问题由机器人编程语言的指令来给出\n离线编程与仿真 离线编程系统是一种机器人编程环境，可以在不需要机器人停机的状态下对机器人进行编程，也可以在没有做出机器人实物的情况下对机器人设计进行仿真\n本章完\n","date":"2024-10-30T00:00:00Z","permalink":"https://INKEM.github.io/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E5%AF%BC%E8%AE%BAep1.%E6%A6%82%E8%BF%B0/","title":"【机器人学导论】Ep1.概述"},{"content":"蜂鸣器实验 蜂鸣器介绍 蜂鸣器是一种一体化结构的电子讯响器，采用直流电压供电，广泛应用于电子产品中作为发声器件\n蜂鸣器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型\n与LED相比，由于51单片机的I/O口的驱动电流不足，蜂鸣器无法直接使用其来驱动，而是通过放大电路实现驱动\n","date":"0001-01-01T00:00:00Z","permalink":"https://INKEM.github.io/p/","title":""}]